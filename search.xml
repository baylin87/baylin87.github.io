<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>危机意识</title>
      <link href="/2019/06/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20190601-%E5%8D%B1%E6%9C%BA%E6%84%8F%E8%AF%86/"/>
      <url>/2019/06/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20190601-%E5%8D%B1%E6%9C%BA%E6%84%8F%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>危机意识是指对紧急或困难关头的感知及应变能力。 危机来自外部与内部。 从外部环境的不可控性及内部条件的可变性，均可看到危机是客观存在的。<br>危机意识的前提是稳步发展，市场永远充满了变数，只有时刻保持居安思危的心态，正视缺点、不断创新、永不放弃，才有可能使基业长青。</p></blockquote><a id="more"></a><p>目前大环境局势不太好。</p><h1 id="什么是自由"><a href="#什么是自由" class="headerlink" title="什么是自由"></a>什么是自由</h1><p>能真正影响行动的关键，我们要的自由，最根本不是财富，财富只是工具，我们要的自由，本质是<strong>时间的自主权</strong></p><p>个人财富自由，指的是某个人再也不用为了满足生活必需而出售自己的时间了</p><p>专注成长而不是专注成功</p><p>财富自由不是终点，那只是通往终点过程中的一个里程碑而已</p><p>精明的交易员在进场交易之前，都要知道两个最基本的事——交易的底线，让自己利益最大化的交易法则（策略）</p><p>我们所说的“活在未来”，本质上来看，只能是“思维上的活在未来”。</p><h1 id="财富自由之路"><a href="#财富自由之路" class="headerlink" title="财富自由之路"></a>财富自由之路</h1><p>通往财富自由之路的路径，起码有两个：</p><ul><li><p>自己做出一个有长期成长（或长期成长率）的公司</p></li><li><p>用自己的钱投资那些已经证明自己有长期成长（或长期成长率）的公司……</p></li></ul><p>而第二条路径又分两个层次：</p><p>在那些有长期成长（或者长期成长率）的公司股票尚未公开流通之时投资（比如天使投资、风险投资、PE等等就在做这样的事情），此为所谓的“一级市场”；</p><p>在那些有长期成长（或者长期成长率）的公司股票公开流通之后投资，此为所谓的“二级市场” 。对普通人来说，这可能是更好的选择</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡说八道 </tag>
            
            <tag> 面筋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN Keyboard dismiss</title>
      <link href="/2019/04/27/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20190427-RN%20Keyboard%20dismiss/"/>
      <url>/2019/04/27/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20190427-RN%20Keyboard%20dismiss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>公司用的RN锁定0.30，很多新功能或者老bug只能手动修复，蛋疼。</p></blockquote><a id="more"></a><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>当点击TextInput键盘弹起时，如果此时后端报错，input不失焦，键盘也不隐藏，emmmmm</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blurOnSubmit</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextInput.State.blurTextInput(TextInput.State.currentlyFocusedField())</span><br></pre></td></tr></table></figure><h2 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h2><p>手动调用 <code>keyboard.dismiss()</code></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://github.com/FaridSafi/react-native-gifted-chat/issues/405" target="_blank" rel="noopener">github-issue-Keyboard won’t dismiss when area outside of keyboard is tapped</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="/2019/03/26/20190326-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2019/03/26/20190326-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>今天处理下数组的去重。</p><a id="more"></a><h1 id="基础款"><a href="#基础款" class="headerlink" title="基础款"></a>基础款</h1><p>要求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="keyword">in</span> ===&gt; list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出out ===&gt; unionList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>要求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="keyword">in</span> ===&gt; list = [&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;,&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;,&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;]</span><br><span class="line">输出out ===&gt; unionList = [&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;,&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;]</span><br></pre></td></tr></table></figure><h1 id="究极体"><a href="#究极体" class="headerlink" title="究极体"></a>究极体</h1><p>要求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="keyword">in</span> ===&gt; list = [</span><br><span class="line">    &#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'哈'</span>,</span><br><span class="line">      batch: <span class="string">'1-1'</span>,</span><br><span class="line">      other: <span class="string">'yiyi'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'哈'</span>,</span><br><span class="line">      batch: <span class="string">'1-2'</span>,</span><br><span class="line">      other: <span class="string">'yier'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'哈'</span>,</span><br><span class="line">      batch: <span class="string">'1-1'</span>,</span><br><span class="line">      other: <span class="string">'yier'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        code: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'呵'</span>,</span><br><span class="line">      batch: <span class="string">'2-1'</span>,</span><br><span class="line">      other: <span class="string">'eryi'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">primaryKey: code + batch</span><br><span class="line"></span><br><span class="line">输出out ===&gt; unionList = [</span><br><span class="line">    &#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'哈'</span>,</span><br><span class="line">      batch: <span class="string">'1-1'</span>,</span><br><span class="line">      other: <span class="string">'yiyi'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'哈'</span>,</span><br><span class="line">      batch: <span class="string">'1-2'</span>,</span><br><span class="line">      other: <span class="string">'yier'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">        code: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'呵'</span>,</span><br><span class="line">      batch: <span class="string">'2-1'</span>,</span><br><span class="line">      other: <span class="string">'eryi'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native Keyboard Covering Inputs</title>
      <link href="/2019/02/28/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20190228-RN%20Keyboard%20Covering%20Inputs/"/>
      <url>/2019/02/28/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20190228-RN%20Keyboard%20Covering%20Inputs/</url>
      
        <content type="html"><![CDATA[<p>当键盘遮挡住被输入TextInput时，尝试过几种解决思路：</p><ol><li>外侧包一层<code>ScrollView</code>，然后通过<code>ScrollView</code>的<code>scrollTo()</code>来滚到键盘上方，其中的难点在于 <strong>怎么计算需要滚动的值</strong>，原lego里的Scroll + Input有对应实现，但有bug💔</li><li>用<code>react native</code>的<code>KeyboardAvoidingView</code>组件，但在需要用<code>ScrollView</code>的地方很诡异，遂放弃</li><li>用<code>transform</code>向Y轴平移啊，还不用动<code>TextInput</code>，结合 <code>animation</code>提升用户体验，简直爽得起飞🛫️，😄<a id="more"></a></li></ol><blockquote><p>20190531更新：1. 实测IOS对动画有一定延时。。 2. 为兼容iPHONE X等全面屏，需对<code>offset</code>单独设置大些的值</p></blockquote><p>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardShift</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    shift: <span class="keyword">new</span> Animated.Value(<span class="number">0</span>),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidShowSub = Keyboard.addListener(<span class="string">'keyboardDidShow'</span>, <span class="keyword">this</span>.handleKeyboardDidShow);</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidHideSub = Keyboard.addListener(<span class="string">'keyboardDidHide'</span>, <span class="keyword">this</span>.handleKeyboardDidHide);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidShowSub.remove();</span><br><span class="line">    <span class="keyword">this</span>.keyboardDidHideSub.remove();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleKeyboardDidShow = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">height</span>: windowHeight &#125; = Dimensions.get(<span class="string">'window'</span>);</span><br><span class="line">    <span class="keyword">const</span> keyboardHeight = event.endCoordinates.height;</span><br><span class="line">    <span class="keyword">const</span> currentlyFocusedField = TextInputState.currentlyFocusedField();</span><br><span class="line">    UIManager.measure(currentlyFocusedField, (originX, originY, width, height, pageX, pageY) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> fieldHeight = height;</span><br><span class="line">      <span class="keyword">const</span> fieldTop = pageY;</span><br><span class="line">      <span class="keyword">const</span> gap = (windowHeight - keyboardHeight) - (fieldTop + fieldHeight) - offset;</span><br><span class="line">      <span class="keyword">if</span> (gap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Animated.timing(</span><br><span class="line">        <span class="keyword">this</span>.state.shift,</span><br><span class="line">        &#123;</span><br><span class="line">          toValue: gap,</span><br><span class="line">          duration: <span class="number">300</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ).start();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleKeyboardDidHide = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Animated.timing(</span><br><span class="line">      <span class="keyword">this</span>.state.shift,</span><br><span class="line">      &#123;</span><br><span class="line">        toValue: <span class="number">0</span>,</span><br><span class="line">        duration: <span class="number">300</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children, ...other &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; shift &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ScrollView</span><br><span class="line">        keyboardShouldPersistTaps=<span class="string">"handled"</span></span><br><span class="line">        &#123;...other&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;Animated.View style=&#123;[styles.container, &#123; <span class="attr">transform</span>: [&#123; <span class="attr">translateY</span>: shift &#125;] &#125;]&#125;&gt;</span><br><span class="line">          &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Animated.View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ScrollView&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KeyboardShift.propTypes = &#123;</span><br><span class="line">  children: PropTypes.element.isRequired,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li><a href="https://codeburst.io/react-native-keyboard-covering-inputs-72a9d3072689" target="_blank" rel="noopener">React Native Keyboard Covering Inputs – codeburst</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>moment.js踩的周选择坑</title>
      <link href="/2019/02/25/20190225-moment.js%E8%B8%A9%E7%9A%84%E5%91%A8%E9%80%89%E6%8B%A9%E5%9D%91/"/>
      <url>/2019/02/25/20190225-moment.js%E8%B8%A9%E7%9A%84%E5%91%A8%E9%80%89%E6%8B%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><code>moment.js</code>是一个强大的JavaScript日期处理类库，加上antd与moment.js的强耦合，必须用。</p><p>故事的开始要从前段时间做的一个需求的其中一个功能：</p><blockquote><p>用户可选择默认周期为“下周（下周一~下周日）”，支持当前周往后再选4周（W+1 ~ W+4）<br><a id="more"></a><br>当时的实现四周日期如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setWeekList(howMuch = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (howMuch === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> item = &#123;</span><br><span class="line">    start: moment().day(<span class="string">'Monday'</span>).add(<span class="number">7</span> * howMuch, <span class="string">'d'</span>).format(<span class="string">'YYYY-MM-DD'</span>),</span><br><span class="line">    end: moment().day(<span class="string">'Monday'</span>).add((<span class="number">7</span> * howMuch) + <span class="number">6</span>, <span class="string">'d'</span>).format(<span class="string">'YYYY-MM-DD'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.weekList.unshift(&#123; ...item &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setWeekList(howMuch - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>正常工作日使用是没有问题的，但周日选择会出现问题：<br>我们日常认为的周起始是周一，但moment.js中默认为周日。。。导致周日时取的下周为下下周==。</p><p>正确姿势：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setWeekList(howMuch = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (howMuch === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * WARNING:</span></span><br><span class="line"><span class="comment">   * `moment().startOf('isoWeek');` set to the first day (Monday) of this week according to ISO 8601, 12:00 am</span></span><br><span class="line"><span class="comment">   * `moment().day('Monday')` default first day --- Sunday</span></span><br><span class="line"><span class="comment">   * doc: https://momentjs.com/docs/#/manipulating/start-of/</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123;</span><br><span class="line">    start: moment()</span><br><span class="line">            .startOf(<span class="string">'isoWeek'</span>)</span><br><span class="line">            .add(<span class="number">7</span> * howMuch, <span class="string">'d'</span>)</span><br><span class="line">            .format(<span class="string">'YYYY-MM-DD'</span>),</span><br><span class="line">    end: moment()</span><br><span class="line">          .startOf(<span class="string">'isoWeek'</span>)</span><br><span class="line">          .add((<span class="number">7</span> * howMuch) + <span class="number">6</span>, <span class="string">'d'</span>)</span><br><span class="line">          .format(<span class="string">'YYYY-MM-DD'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.weekList.unshift(&#123; ...item &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setWeekList(howMuch - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-判断单调数组</title>
      <link href="/2019/01/07/20190107-Leetcode%E5%88%A4%E6%96%AD%E5%8D%95%E8%B0%83%E6%95%B0%E7%BB%84/"/>
      <url>/2019/01/07/20190107-Leetcode%E5%88%A4%E6%96%AD%E5%8D%95%E8%B0%83%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>今天看了道算法题，</p><blockquote><p>判断一个数组是否为单调数组，是返回 <code>true</code>，不是返回 <code>false</code>。</p></blockquote><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [6,5,4,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,5]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>单调即数组后一项都比前一项大，或都比前一项小<br>重点是 <strong>每一项</strong> 和 <strong>比较</strong></p><ul><li>要能遍历每一项，需要循环数组</li><li>比较，这个就有文章了</li></ul><h2 id="怎么比较"><a href="#怎么比较" class="headerlink" title="怎么比较"></a>怎么比较</h2><p>因为有两种情况</p><ul><li>要么后一项都比前一项大</li><li>要么后一项都比前一项小</li></ul><p>因此最简单的是两个if判断一下，于是就有<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; list</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isMonotonic = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> incMon(list) || decMon(list)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> incMon = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isMon = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;list.length<span class="number">-1</span>; i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>] &gt; <span class="number">0</span>) isMon = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decMon = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isMon = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;list.length<span class="number">-1</span>; i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>] &lt; <span class="number">0</span>) isMon = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMon;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>emmm，上面这段是有bug的，因为就算循环了，但判断条件只要有一项满足即为true，因此无法检测类似[1,3,2]这种数组，怎么办？</p><p>问题在哪呢？</p><p>上面两个incMon和decMon的前提假设是传入的数组不是单调数组，如果假设传入是单调，只要判断出有一项不符合，就返回false，那应该就不会有问题了。</p><p>于是，改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; list</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isMonotonic = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> incMon(list) || decMon(list)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> incMon = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isMon = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;list.length<span class="number">-1</span>; i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>] &lt; <span class="number">0</span>) isMon = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decMon = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> isMon = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;list.length<span class="number">-1</span>; i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>] &gt; <span class="number">0</span>) isMon = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isMon;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>嗯，</p><blockquote><p>条件判断应该尽量判断特殊情况。</p></blockquote><p>再看看刚才代码，感觉两个增减判断函数里for循环功能类似，仅判断条件不一样，第六感告诉我这还有优化空间。</p><p>心中默念：</p><blockquote><p>写代码的目的是为了有一天能不写代码。</p></blockquote><p>来，继续。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>非单调的情况是</p><ul><li>递增的出现<code>list[i]-list[i+1] &gt; 0</code></li><li>递减的出现<code>list[i]-list[i+1] &lt; 0</code></li></ul><p>然后可以有<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; list</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isMonotonic = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> incFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> decFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, i&lt;list.length<span class="number">-1</span>,i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>]&gt;<span class="number">0</span>) incFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>]&lt;<span class="number">0</span>) decFlag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incFlag || decFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>嗯，看着优雅多了</p><h1 id="ShowCase"><a href="#ShowCase" class="headerlink" title="ShowCase"></a>ShowCase</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>咦，当数组只有一个数的时候必定是单调函数，就不用再费事去循环了！<br>再优化下，加个判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; list</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> isMonotonic = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">+    <span class="keyword">if</span>(list.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> incFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> decFlag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, i&lt;list.length<span class="number">-1</span>,i+=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>]&gt;<span class="number">0</span>) incFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(list[i]-list[i+<span class="number">1</span>]&lt;<span class="number">0</span>) decFlag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incFlag || decFlag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，这回应该不错了。</p><h1 id="还有别的方法嘛？"><a href="#还有别的方法嘛？" class="headerlink" title="还有别的方法嘛？"></a>还有别的方法嘛？</h1><p>有的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isMonotonic = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="number">0</span>; <span class="comment">//increasing - 1; decreasing -2</span></span><br><span class="line">  <span class="keyword">if</span> (A.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag === <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mobx源码初读笔记</title>
      <link href="/2019/01/02/20190102-mobx%E6%BA%90%E7%A0%81/"/>
      <url>/2019/01/02/20190102-mobx%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>mobx 3.1.9</p><h1 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h1><ul><li>autorun</li><li>observable</li><li>globalstate</li><li>reaction</li></ul><p>实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bankUser = mobx.observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  income: <span class="number">3</span>,</span><br><span class="line">  debit: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mobx.autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'张三的账户存款:'</span>, bankUser.income);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="可观察watcher"><a href="#可观察watcher" class="headerlink" title="可观察watcher"></a>可观察watcher</h2><p>调用 <code>mobx.observable()</code> 方法，创建了 observable 对象， 对象的所有属性都拷贝至一个克隆对象并将克隆对象设置成 可观察 — 猜测使用的是es6的proxy方法</p><p>观察员watcher有两个非常重要的行为特征：</p><ul><li>当有人请求观察员所监控的值（比如income）时，会触发 MobX 所提供的 <code>reportObserved</code> 方法；</li><li>当观察员所监控的值（比如income）发生变化时，会触发 MobX 所提供的 <code>propagateChanged</code> 方法；</li></ul><h2 id="自动执行autorun"><a href="#自动执行autorun" class="headerlink" title="自动执行autorun"></a>自动执行autorun</h2><p>含义： 响应式函数 —— 响应观察值的变化而自动执行指定的函数。</p><p>脉络</p><ol><li><p>创建 <code>Reaction</code> 类型对象，关键特征是 <strong>监督并控制任务的执行</strong></p></li><li><p>分配任务</p></li><li><p>立即执行一次autorun中的函数，通过reaction.schedule() </p></li></ol><blockquote><p><strong>reaction.schedule</strong></p><ul><li>探长入列</li><li>让队列所有探长执行 <code>runReaction</code> 方法</li></ul></blockquote><h2 id="探长是个啥玩意儿"><a href="#探长是个啥玩意儿" class="headerlink" title="探长是个啥玩意儿"></a>探长是个啥玩意儿</h2><p>主流程大致只有 4 步：</p><ul><li>开始执行（runReaction）</li><li>判断是否执行（shouldCompute）</li><li>执行任务（onInvalidate）</li><li>结束</li></ul><blockquote><p>有一个很重要的 shouldCompute 判断方法步骤，根据这个方法探长可以自行判断 是否执行任务，并非所有的任务都需要执行，这一步的作用是优化 MobX 执行效率。</p></blockquote><h3 id="开始执行（runReaction）"><a href="#开始执行（runReaction）" class="headerlink" title="开始执行（runReaction）"></a>开始执行（runReaction）</h3><p>为开始执行做准备工作<br>用 startBatch() 开头，用 endBatch() 结尾，中间隔着 onInvalidate。</p><p>startBatch() 和 endBatch() 这两个方法一定是成对出现，用于影响 globalState 的 inBatch 属性，表明开启/关闭 一层新的事务</p><h3 id="执行任务（onInvalidate）"><a href="#执行任务（onInvalidate）" class="headerlink" title="执行任务（onInvalidate）"></a>执行任务（onInvalidate）</h3><p>onInvalidate 是 Reaction 类的一个属性，且在初始化 Reaction 时传入到构造函数中的，这样做的目的是方便做扩展。</p><p>autorun 方法本质就是一种预定义好的 Reaction —— 你可以依葫芦画瓢，将自定义 onInvalidate 方法传给 Reaction 来实现自己的 计划任务</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Mobx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keydown长按时短暂卡顿问题</title>
      <link href="/2018/04/16/20180416-keydown%E9%95%BF%E6%8C%89%E6%97%B6%E7%9F%AD%E6%9A%82%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/16/20180416-keydown%E9%95%BF%E6%8C%89%E6%97%B6%E7%9F%AD%E6%9A%82%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><code>keydown</code> 属于键盘事件（<a href="https://www.w3.org/TR/uievents/#events-keyboardevents" target="_blank" rel="noopener">Keyboard Events</a>），当键盘按下某个按键时触发，且默认情况下，长按某按键会重复触发。但事件会判断用户是否长按还是连续按下，因此会有一定延迟（有点类似移动端适配时onclick事件会有300ms延迟）。一般情况下该延迟很难察觉，但在开发JS游戏时，发现该延迟会严重降低游戏体验，给玩家一种十分卡顿的感觉。此时就很有必要解决该问题。</p><a id="more"></a><p>不废话，先看代码逻辑：</p><p>Game 类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Game</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bindEvent();</span><br><span class="line">  <span class="keyword">this</span>.start();</span><br><span class="line">  <span class="keyword">this</span>.plane = <span class="keyword">new</span> Plane();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听事件函数</span></span><br><span class="line">Game.prototype.bindEvent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里使用JQuery方法获取DOM</span></span><br><span class="line">  $(<span class="built_in">document</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> event = event || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">if</span>(event.keyCode == <span class="number">37</span>) &#123;game.plane.left();&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event.keyCode == <span class="number">39</span>) &#123;game.plane.right();&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主循环函数</span></span><br><span class="line">Game.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    game.plane.render();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Plane 类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Plane.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">game.ctx.drawImage(<span class="keyword">this</span>.plane,<span class="keyword">this</span>.x,game.canvas.height - <span class="number">124</span> - <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//飞机左移</span></span><br><span class="line">Plane.prototype.left = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x -=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//飞机右移</span></span><br><span class="line">Plane.prototype.right = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x +=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.x &gt;= game.canvas.width - <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>.x = game.canvas.width - <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>throttle</code> 和 <code>debounce</code> 是解决请求和响应速度不匹配问题的两个方案。二者的差异在于选择不同的策略。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.w3.org/TR/uievents/#events-keyboardevents" target="_blank" rel="noopener">W3关于keyboardevents的解释</a></li><li><a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="noopener">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从new操作符看原型与原型链</title>
      <link href="/2018/04/06/20180406-%E4%BB%8Enew%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9C%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/04/06/20180406-%E4%BB%8Enew%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9C%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>ECMA-262中，把对象定义为：”无序属性的集合，其属性可以为基本类型值、对象或者函数。”而一般我们要创建对象（更准确一点叫做创建对象实例）时，会使用 <code>new</code> 操作符。最简单的如 <code>new Object()</code> ，然后我们把创建对象实例的那个东西（也就是 <code>new</code> 操作符后面跟着的那个东西，一般都是一个函数）叫做构造函数（有人也叫做构造器）。再然后我们会把 <code>new Object()</code> 的返回值赋值给一个变量如 <code>obj</code> ，写成 <code>var obj=new Object();</code> ，而后我们就会对obj进行各种操作，但其中到底发生了什么？</p><a id="more"></a><h1 id="当-new-Foo-被执行"><a href="#当-new-Foo-被执行" class="headerlink" title="当 new Foo(...) 被执行"></a>当 <code>new Foo(...)</code> 被执行</h1><blockquote><p>引用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN</a> 上关于当 <code>new Foo(...)</code> 被执行，会发生如下事情：</p><ol><li>创建一个从<code>Foo.prototype</code> 继承的新对象；</li><li>构造函数 <code>Foo</code> 使用指定的参数调用，并将<code>Foo</code> 中的 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 相当于<code>new Foo()</code>，即如果没有指定参数列表，则使用无参调用Foo；</li><li>构造函数返回的对象成为整个 <code>new</code> 表达式的结果。如果构造函数没有显式地返回一个对象，那么将使用步骤1中创建的对象。(通常构造函数不返回值，但是它们可以选择这样做，如果它们想要覆盖正常的对象创建过程。)</li></ol></blockquote><p>上面那段说白了就是：</p><ol><li>使用 <code>new</code> 操作符时，会创建一个新对象，该新对象的 <code>__proto__</code> 属性指向其构造函数的原型，即 <code>Foo.prototype</code>；</li><li>构造函数中的 <code>this</code> 会指向新对象；</li><li>执行构造函数中语句；</li><li>如果构造函数定义了返回值且返回值是对象（包括数组、函数之类的），则返回值为这些对象；如果构造函数未定义返回值（默认返回<code>Undefined</code>）或定义的返回值是基本类型（<code>Undefined</code>类型、<code>Null</code>类型、<code>Boolean</code>类型、<code>Number</code>类型、<code>String</code>类型），则返回 <code>new</code> 创建的那个新对象。</li></ol><p><strong>需注意的是：</strong>新对象的 <code>__proto__</code> 属性指向其构造函数的原型，即 <code>Foo.prototype</code>，而不是指向 <code>Foo</code> 。 <code>Foo.prototype</code> 为创建 <code>Foo</code> （一般为使用 <code>function Foo(){...}</code>）时创建的的属性，<code>prototype</code>中包括一个名为 <code>constructor</code> 的属性，该属性才是指向 <code>Foo</code>。</p><p>举例说明：</p><ul><li><p>关于第一点的例子：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180406-%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BE%8B%E5%AD%90.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="new创建Foo对象举例"></p></li></ul><ul><li><p>关于第四点的例子：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180406-new%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="new返回值的例子"></p></li></ul><h1 id="字面量定义-prototype"><a href="#字面量定义-prototype" class="headerlink" title="字面量定义 prototype"></a>字面量定义 <code>prototype</code></h1><p>还需要注意的一点为，如果通过字面量形式定义 <code>prototype</code> 时，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  name : <span class="string">"Nicholas"</span>, </span><br><span class="line">  age : <span class="number">29</span>, </span><br><span class="line">  job: <span class="string">"Software Engineer"</span>, </span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="keyword">this</span>.name); &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 Person.prototype 的 constructor 属性就不是指向 Person 了 而是指向默认的 Object ，因为字面量形式相当于重写 prototype，如需像关键字声明那样使 constructor 指向 Person，需在字面量中手动声明，这个要特别注意。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  <span class="keyword">constructor</span> : Person,</span><br><span class="line">  name : "Nicholas", </span><br><span class="line">  age : 29, </span><br><span class="line">  job: "Software Engineer", </span><br><span class="line">  sayName : function () &#123; alert(<span class="keyword">this</span>.name); &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN上关于new操作符的解释</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">张鑫旭关于jQuery的原理和机制的解释</a></li><li><a href="http://www.jb51.net/article/79437.htm" target="_blank" rel="noopener">极易被忽视的javascript面试题七问七答</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】MDN：transform-function</title>
      <link href="/2018/03/21/20180321-MDN%EF%BC%9Atransform-function/"/>
      <url>/2018/03/21/20180321-MDN%EF%BC%9Atransform-function/</url>
      
        <content type="html"><![CDATA[<p>原文地址：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function" target="_blank" rel="noopener">MDN : transform-function</a></p><p><strong>transform-function</strong>用于对元素的显示做变换。通常，这种变换可以由矩阵表示，并且可以使用每个点上的矩阵乘法来确定所得到的图像。</p><p>以下为3D图像关于各种转换函数的定义。</p><a id="more"></a><h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective()"></a>perspective()</h3><p> <code>perspective()</code> 这个CSS函数定义了 z=0平面与用户之间的距离，以便给三维定位元素一定透视度。当每个3D元素的z&gt;0时会显得比较大，而在z&lt;0时会显得比较小。其影响的程度由这个属性的值来决定。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>(<span class="selector-tag">l</span>)</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>l</p><p>该参数是一个 <code>length</code>， 给定从用户（显示屏）到z = 0平面的距离。 它用于将透视转换(3D)应用于元素。 如果它是0或负值，则不应用3D变换。</p></li></ul><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-rotate_19.5.png" alt="rotate()"> <code>rotate()</code> 这个CSS 函数 定义一个旋转属性，将元素在不变形的情况下旋转到不动点周围( <code>transform-origin</code>属性指定) 。 移动量由指定角度定义；如果为正值，则运动将为顺时针，如果为负值，则为逆时针 。 180°的旋转称为点反射 (<em>point reflection</em>)。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rotate</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 <code>angle</code>， 代表旋转的角度。正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotate3d"><a href="#rotate3d" class="headerlink" title="rotate3d()"></a>rotate3d()</h3><p> <code>rotate3d()</code> 这个CSS 函数定义一个3D旋转功能，该旋转使元素能够绕固定轴移动而不变形。 其中移动量由指定角度定义；如果为正值，则运动将为顺时针，如果为负值，则为逆时针。</p><p>在三维空间中，旋转有三个自由度，各表示某条旋转轴。 旋转轴由[x，y，z]向量定义，且过原点（由 <code>transform-origin</code> CSS属性定义）。 如果向量没有标准化，即它的三个坐标的平方之和不是1，它将在内部被标准化。 不可标准化的向量，如空向量[0,0,0]，将导致旋转不被应用，但不会影响整个CSS属性。</p><p>注意：相对于平面上的旋转，三维旋转的组成通常不是可交换位置顺序的，这意味着旋转的应用顺序是至关重要的。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rotate3d</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>, <span class="selector-tag">z</span>, <span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>x</em></p><p>该参数为”<code>number</code>“ 类型值， 描述旋转轴向量的x坐标 。</p></li><li><p><em>y</em></p><p>该参数为 “<code>number</code>“ 类型值，描述旋转轴向量的y坐标。</p></li><li><p><em>z</em></p><p>该参数为 “<code>number</code>“ 类型值，描述旋转轴向量的z坐标。</p></li><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度 。 正角度表示顺时针旋转，负角度表示逆时针旋转 。</p></li></ul><h3 id="rotateX"><a href="#rotateX" class="headerlink" title="rotateX()"></a>rotateX()</h3><p> <code>rotateX()</code> 这个CSS 函数定义了将元素在横坐标上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。.</p><p><code>rotateX(a)</code>是 <code>rotate3D(1, 0, 0, a)</code>的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rotateX</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“， 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotateY"><a href="#rotateY" class="headerlink" title="rotateY()"></a>rotateY()</h3><p> <code>rotateY()</code> 这个CSS 函数定义了将元素在纵坐标上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。</p><p><code>rotateY(a)</code> 是 <code>rotate3D(0, 1, 0, a)</code> 的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rotateY</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotateZ"><a href="#rotateZ" class="headerlink" title="rotateZ()"></a>rotateZ()</h3><p> <code>rotateZ()</code>这个CSS 函数定义了将元素在z轴上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。</p><p><code>rotateZ(a)</code>是 <code>rotate3D(0, 0, 1, a)</code> 的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rotateZ</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale()"></a><code>scale()</code></h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scale_2_2.png" alt="scale()"></p><p>The <code>scale()</code> CSS 函数可改变元素的大小。 它可以增大或减小元素的大小，并且缩放量由矢量定义，并且它可以使在一个方向上比另一个方向更多。</p><p>这种变换的特点是矢量的坐标可定义在每个不同方向上各子完成一定比例缩放。如果矢量的两个坐标相等，则缩放是均匀的或各向同性的，并且元素的形状被保留。在这种情况下，缩放函数定义了一个同调变换。</p><p>当超出 <code>[-1, 1]</code>范围外时，缩放将在坐标方向上放大元素；当在该范围内时，它在该方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。</p><p>注意： <code>scale()</code> 函数仅在欧几里德平面(2D)中应用转换。要在空间中进行缩放，必须使用 <code>scale3D()</code> 函数。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">scale</span>(<span class="selector-tag">sx</span>) 或</span><br><span class="line"><span class="selector-tag">scale</span>(<span class="selector-tag">sx</span>, <span class="selector-tag">sy</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>sx</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的横坐标。</p></li><li><p><strong>sy</strong></p><p>该参数为 “<code>number</code>“ 类型值，代表缩放矢量的纵坐标 。 如果不存在，则其默认值为 <strong>sx</strong>，从而导致保持元素形状进行均匀缩放。</p></li></ul><h3 id="scale3d"><a href="#scale3d" class="headerlink" title="scale3d()"></a><code>scale3d()</code></h3><p> <code>scale3d()</code> CSS 函数可改变元素的大小。由于缩放的量由矢量定义，因此可以改变不同方向的尺寸。</p><p>这种变换的特点是矢量的坐标定义在每个方向上完成多少缩放。如果矢量的三个坐标都相等，则缩放是均匀的或各向同性的，并且保持元素形状。在这种情况下，这个缩放函数就是定义了一个同调变换。</p><p>当超出[-1，1]的范围之外时，缩放比例将在坐标方向上放大元素；当在[-1，1]范围内时，它在当前方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">scale3d</span>(<span class="selector-tag">sx</span>, <span class="selector-tag">sy</span>, <span class="selector-tag">sz</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>sx</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的横坐标。</p></li><li><p><em>sy</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的纵坐标。</p></li><li><p><em>sz</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的z轴坐标。</p></li></ul><h3 id="scaleX"><a href="#scaleX" class="headerlink" title="scaleX()"></a>scaleX()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scaleX_2.png" alt="scaleX()"> <code>scaleX()</code> 这个CSS函数是用一个常数因子来修改每个单元点的横坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度也不守恒。</p><p><code>scaleX(sx)</code> 是 <code>scale(sx, 1)</code> 和 <code>scale3d(sx, 1, 1)</code> 的简写形式。</p><p><code>scaleX(-1)</code> 表示通过原点的垂直轴定义轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">scaleX</span>(<span class="selector-tag">s</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值， 表示在元素的每个点的横坐标上应用的缩放因子。</p></li></ul><h3 id="scaleY"><a href="#scaleY" class="headerlink" title="scaleY()"></a>scaleY()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scaleY_2.png" alt="scaleY()"></p><p> <code>scaleY()</code> 这个 CSS函数用一个常数因子修改每个元素点的纵坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度不守恒。</p><p><code>scaleY(sy)</code> 是 <code>scale(1, sy)</code> 和 <code>scale3d(1, sy, 1)</code> 的简写形式。</p><p><code>scaleY(-1)</code> 定义了通过原点的水平轴的轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">scaleY</span>(<span class="selector-tag">s</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值，表示在元素的每个点的纵坐标上应用的缩放因子。</p></li></ul><h3 id="scaleZ"><a href="#scaleZ" class="headerlink" title="scaleZ()"></a>scaleZ()</h3><p> <code>scaleZ()</code> 这个CSS函数是用一个常数因子来修改每个单元点的z轴坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度也不守恒。</p><p><code>scaleZ(sz)</code> 是 <code>scale3d(1, 1, sz)</code> 的简写形式。</p><p><code>scaleZ(-1)</code> 定义了通过原点的z轴的轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">scaleZ</span>(<span class="selector-tag">s</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值，表示在元素的每个点的z轴坐标上应用的缩放因子。</p></li></ul><h3 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h3><p> <code>skew()</code> 这个CSS函数是一种用于拉伸，或者说是平移，该函数会使得在每个方向上扭曲元素上的每个点以一定角度。这是通过将每个坐标增加一个与指定角度成比例的值和到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">skew</span>(<span class="selector-tag">ax</span>)       或</span><br><span class="line"><span class="selector-tag">skew</span>(<span class="selector-tag">ax</span>, <span class="selector-tag">ay</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>ax</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿着横坐标扭曲元素的角度 。</p></li><li><p><em>ay</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿纵坐标扭曲元素的角度 。</p></li></ul><h3 id="skewX"><a href="#skewX" class="headerlink" title="skewX()"></a>skewX()</h3><p> <code>skewX()</code> 这个CSS函数是用于水平拉伸，它将元素的每个点在水平方向上扭曲一定角度。这是通过将横坐标增加一个与指定角度成比例的值以及到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">skewX</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿着横坐标扭曲元素的角度。</p></li></ul><h3 id="skewY"><a href="#skewY" class="headerlink" title="skewY()"></a>skewY()</h3><p> <code>skewY()</code> 这个CSS函数是用于垂直拉伸，它将元素的每个点在垂直方向上扭曲一定角度。这是通过将纵坐标增加一个与指定角度成比例的值以及到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">skewY</span>(<span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为一个角度 “<code>angle</code>“ ，表示用于沿着纵坐标扭曲元素的角度。</p></li></ul><h3 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translate_2.png" alt="translate()"> <code>translate()</code> 这个CSS 函数用于移动元素在平面上的位置。这种变换的特点是矢量的坐标定义了它在每个方向上的移动量。</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translate</span>(<span class="selector-tag">tx</span>)       或</span><br><span class="line"><span class="selector-tag">translate</span>(<span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>tx</em></p><p>该参数为 “<code>length</code>“ ，表示要移动矢量的横坐标。</p></li><li><p><em>ty</em></p><p>该参数为 “<code>length</code>“ ，表示要移动矢量的纵坐标。 如果不写，则默认与 <strong>tx </strong>值相等，例如 :  <code>translate(2)</code> 表示 <code>translate(2, 2)</code>。</p></li></ul><h3 id="translate3d"><a href="#translate3d" class="headerlink" title="translate3d()"></a>translate3d()</h3><p> <code>translate3d()</code> 这个CSS 函数用于移动元素在3D空间中的位置。 这种变换的特点是三维矢量的坐标定义了它在每个方向上的移动量。</p><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translate3d</span>(<span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>, <span class="selector-tag">tz</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>tx</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的横坐标。</p></li><li><p><em>ty</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的纵坐标。</p></li><li><p><em>tz</em></p><p>该参数为 “<code>length</code>“ 代表移动矢量的z轴坐标。 该值不能使用百分比 “<code>percentage</code>“ ；如果使用会被认为是无效属性。</p></li></ul><h3 id="translateX"><a href="#translateX" class="headerlink" title="translateX()"></a><code>translateX()</code></h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translateX_2.png" alt="translateX()"> <code>translateX()</code> 这个CSS 函数用于在平面上水平移动元素。 这个转换的特点是 “<code>length</code>“ 定义了它的水平移动量。</p><p><code>translateX(tx)</code> 是 <code>translate(tx, 0)</code>的简写形式。</p><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translateX</span>(<span class="selector-tag">t</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的横坐标。</p></li></ul><h3 id="translateY"><a href="#translateY" class="headerlink" title="translateY()"></a>translateY()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translateY_2.png" alt="translateY()"> <code>translateY()</code> 这个CSS 函数用于在平面上垂直移动元素。 这个转换的特点是通过 “<code>length</code>“ 定义了它的垂直移动量。</p><p><code>translateY(ty)</code> 是 <code>translate(0, ty)</code>的简写形式。</p><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translateY</span>(<span class="selector-tag">t</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数为 “<code>length</code>“ 代表移动矢量的横坐标。该参数不能使用百分比 “<code>percentage</code>“ ；如果使用百分比形式，会被认为是无效参数。</p></li></ul><h3 id="translateZ"><a href="#translateZ" class="headerlink" title="translateZ()"></a>translateZ()</h3><p> <code>translateZ()</code> 这个CSS 函数用于3D空间的z轴方向移动元素， 这个转换的特点是通过 “<code>length</code>“ 定义了它的z轴方向移动量。</p><p><code>translateZ(tz)</code> 是 <code>translate3d(0, 0, tz)</code>的简写形式。</p><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">translateZ</span>(<span class="selector-tag">t</span>)</span><br></pre></td></tr></table></figure><h4 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数是 “<code>length</code>“ ，代表移动矢量的z轴坐标。</p></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 外文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> transform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从onmouseover和onmouseenter说起</title>
      <link href="/2018/03/13/20180313-%E4%BB%8Eonmouseover%E5%92%8Conmouseenter%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/03/13/20180313-%E4%BB%8Eonmouseover%E5%92%8Conmouseenter%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>初学JS时，<code>onmouseover</code> 和 <code>onmouseenter</code> 触发几乎一样，但在使用 <code>onmouseover</code> 和 <code>onmouseout</code> 时，发现如果在父级元素上定义事件，鼠标移动到其子元素上也会触发该事件，如下图所示，我在父div上设置<code>mouseover</code>，希望实现鼠标移入div时，其子元素p能显示，然后鼠标移走时，p再消失，类似某宝商品简介效果：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseoverBug.gif?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="onmouseover使用时的一个Bug"></p><p>可以发现当鼠标从div盒子下方移入时，子盒子p会出现鬼畜现象。。。而使用 <code>onmouseenter</code> 和 <code>mouseleave</code> 时不会出现此种现象。</p><p>另外，还有如下神奇的事件：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseenter.gif" alt></p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseover.gif" alt></p><a id="more"></a><p>三个div盒子的层级关系为 红div (box1)&gt; 黄div2(box2) &gt; 绿div3 (box3)，当鼠标移入绿div时，使用 <code>mouseover</code>出现的是 box3 box2 box1 ，而使用 <code>mouseenter</code> 时出现的是box1 box2 box3。</p><p>上图的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style type="text/</span>css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">          *&#123;</span></span><br><span class="line"><span class="string">            margin:0;</span></span><br><span class="line"><span class="string">            padding: 0;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          #box1&#123;</span></span><br><span class="line"><span class="string">             position:relative;</span></span><br><span class="line"><span class="string">             width:600px;</span></span><br><span class="line"><span class="string">             height: 600px;</span></span><br><span class="line"><span class="string">             background:red;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          #box2&#123;</span></span><br><span class="line"><span class="string">             position: absolute;</span></span><br><span class="line"><span class="string">             width:300px;</span></span><br><span class="line"><span class="string">             height: 300px;</span></span><br><span class="line"><span class="string">             background:yellow;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          #box3&#123;</span></span><br><span class="line"><span class="string">             position:absolute;</span></span><br><span class="line"><span class="string">             width:150px;</span></span><br><span class="line"><span class="string">             height: 150px;</span></span><br><span class="line"><span class="string">             background:green;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>box1<span class="string">"&gt;</span></span><br><span class="line"><span class="string">         &lt;div id=box2&gt;</span></span><br><span class="line"><span class="string">                &lt;div id=box3&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">         &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">         //获取元素</span></span><br><span class="line"><span class="string">         var box1 = document.getElementById("</span>box1<span class="string">");</span></span><br><span class="line"><span class="string">         var box2 = document.getElementById("</span>box2<span class="string">");</span></span><br><span class="line"><span class="string">         var box3 = document.getElementById("</span>box3<span class="string">");</span></span><br><span class="line"><span class="string">         box1.onmouseover = function  () &#123;</span></span><br><span class="line"><span class="string">           console.log("</span>box1<span class="string">");</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">         box2.onmouseover= function  () &#123;</span></span><br><span class="line"><span class="string">           console.log("</span>box2<span class="string">");</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">         box3.onmouseover= function  () &#123;</span></span><br><span class="line"><span class="string">           console.log("</span>box3<span class="string">");</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：jQuery中的<code>mouseover</code>和<code>mouseout</code>也有类似现象。</p></blockquote><p>究其原因为 <strong>事件冒泡（event bubbling）</strong>。</p><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>JavaScript与HTML之间的交互是通过 <strong>事件</strong> 实现的。</p><blockquote><p>事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间</p></blockquote><p>而 事件流 就是页面接收事件的顺序。早期 IE 和 Netscape开发团队 提出了两种不同的（几乎相反） 事件流 概念 。IE的事件流是事件冒泡流，而 Netscape 的事件流是事件捕获流。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180313-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="DOM事件流"></p><p>开始时，<code>onmouseenter</code>为IE 独有，其他浏览器并不支持，后来各浏览器才陆续支持该事件。 </p><blockquote><p>Firefox started supporting <code>onmouseenter</code> in version 10 (January 2012) and Chrome started supported it in version 30 (October 2013) </p></blockquote><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>每个元素都有其对应事件处理函数，未定义时事件处理函数一般为 <code>null</code> 。事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p>当某元素达到触发条件时，事件处理函数会从该元素的事件处理函数一直执行到最外层 (根) 的事件处理函数后才算结束（<strong>从内到外</strong>–现象类似冒泡）。</p><blockquote><p>引用 MDN 上 关于 <code>mouseenter</code> 和 <code>mouseover</code> 的说明：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-MDN%E5%85%B3%E4%BA%8Emouseenter%E8%A7%A3%E9%87%8A.png" alt="MDN上关于mouserenter和mouseover的解释"></p></blockquote><p>值得注意的是，事件都属于异步语句，因此与内外层级定义事件处理函数顺序无关，但同一元素定义多个同一事件的事件处理函数，后者会覆盖前者。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获刚好与事件冒泡思想相反，事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。当某元素达到触发条件时，事件处理函数会从最外层 (根) 的事件处理函数一直执行到该元素的事件处理函数后才算结束（<strong>从外到内</strong>–现象类似捕获）。</p><h2 id="DOM-0级-和-DOM-2级"><a href="#DOM-0级-和-DOM-2级" class="headerlink" title="DOM 0级 和 DOM 2级"></a>DOM 0级 和 DOM 2级</h2><h3 id="DOM-0级"><a href="#DOM-0级" class="headerlink" title="DOM 0级"></a>DOM 0级</h3><p>一般以on开头的事件以及jQuery中类似的那些事件都属于DOM 0级的事件，这些事件只有冒泡而无捕获，除<code>onmouerenter</code> 和 <code>onmouseleave</code> 外。</p><h3 id="DOM-2级"><a href="#DOM-2级" class="headerlink" title="DOM 2级"></a>DOM 2级</h3><p>DOM 2级事件的定义一般都使用 <code>addEventListen(事件类型，callBack,Boolean)</code> ，其中 <code>Boolean</code> 为 <code>true</code> 时表捕获阶段，<code>false</code>时为冒泡阶段。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过以上知识也就能解释开始案例中的现象：</p><p> <code>mouseover</code> 和 <code>mouseout</code> 在移动到其子元素上也会触发！</p><p>当鼠标首次移入到 <code>div</code> 的下方时触发了<code>div</code> 的<code>mouseover</code> 事件 ，此时<code>p</code>标签重叠在 <code>div</code> 上，此时 鼠标在 <code>p</code>元素上，触发了 <code>div</code> 的<code>mouseover</code> 事件，当 <code>p</code> 元素 离开 ，鼠标回到 <code>div</code> 上，再次触发 <code>div</code> 的 <code>mouseover</code> 事件，如此循环。</p><p>至于第二个例子的现象，我个人觉得是 <code>mouseenter</code> 遵循的是 <strong>事件捕获</strong>，而  <code>mouseover</code> 遵循的是 <strong>事件冒泡</strong>。</p><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JS中变量、函数声明提升优先级问题的实验</title>
      <link href="/2018/03/03/20180302-%E5%85%B3%E4%BA%8EJS%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E9%AA%8C/"/>
      <url>/2018/03/03/20180302-%E5%85%B3%E4%BA%8EJS%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>在复习JS-函数时遇到函数声明提升，回想起之前的变量声明的提升，加上JS无重载一说，若出现同名函数，则后者会覆盖前者。想搞清楚既然变量、函数都能提升，那他们之间的优先级是什么，遂做个小实验验证一下。</p><p>其实我是被自己写的一题给绕晕了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>变量声明、函数声明都会提升执行顺序</li><li>优先级：函数声明 &gt; 变量声明</li></ul><p>验证过程如下：</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="变量声明的提升"><a href="#变量声明的提升" class="headerlink" title="变量声明的提升"></a>变量声明的提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;  </span><br><span class="line"><span class="comment">//结果为控制台打印 undefined</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>这就是变量声明提升–JS中，变量的声明会在其作用域内的最先运行。</p><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//结果为控制台打印该函数</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><h3 id="函数表达式声明"><a href="#函数表达式声明" class="headerlink" title="函数表达式声明"></a>函数表达式声明</h3><p>函数声明提升不适用于函数表达式，但在判断优先级时可作为很强的干扰项，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//结果为控制台打印 undefined</span></span><br></pre></td></tr></table></figure><p>其实这个就是变量声明的提升。。。等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Chrome 63.0.3239.132 (正式版)  （64位）</li></ul><h2 id="变量声明与函数表达式声明"><a href="#变量声明与函数表达式声明" class="headerlink" title="变量声明与函数表达式声明"></a>变量声明与函数表达式声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> <span class="comment">//变量声明提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//后者覆盖前者</span></span><br></pre></td></tr></table></figure><h2 id="变量声明与函数声明"><a href="#变量声明与函数声明" class="headerlink" title="变量声明与函数声明"></a>变量声明与函数声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//函数声明提升</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;<span class="comment">//变量声明提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;<span class="comment">//函数声明提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>这里有个疑问，到底是var a;变量声明提升在前，还是function a 函数声明在前。验证了一下，不管谁在前，运行结果都一样。</p><p>个人开始认为应该是 变量 (全局) 声明在前，函数声明提升在后，后者覆盖前者，所以第一个 <code>console.log(a);</code> 打印函数a。</p><p><strong>验证：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>);</span><br><span class="line"><span class="comment">//控制台打印出window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/20180302-102320.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt></p><p>后查阅<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="noopener">《You Don’t Know JS:Scope &amp; Closures》</a>的第四章关于声明提升的说法是，<code>function</code> 声明 优先于 <code>var</code> 声明，尽管 <code>var</code> 写在前，但 <code>function</code> 声明优先，<code>var</code> 声明被忽略了。</p><p>被忽略了？？</p><p>emmmm…</p><h2 id="函数声明与函数表达式声明"><a href="#函数声明与函数表达式声明" class="headerlink" title="函数声明与函数表达式声明"></a>函数声明与函数表达式声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">haha();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> haha = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"●"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"□"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">haha();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为：</span></span><br><span class="line"><span class="comment">// □ 函数声明的优先级高于表达式声明</span></span><br><span class="line"><span class="comment">// ● 优先级低的覆盖前者</span></span><br></pre></td></tr></table></figure><p>这或许是要看JS引擎源码才能知道答案吧…</p><p>所以，</p><p><strong>开头那题的答案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a () &#123;console.log("aa")&#125;  函数声明提升至最前</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//100  变量声明并赋值后覆盖了前者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;  函数表达式声明覆盖了前者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;  无新赋值了。</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="noopener">MDN关于函数的讲解</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="noopener">You-Dont Know-JS:Scope &amp; Closures—Chapter 4: Hoisting</a></li><li><a href="https://www.cnblogs.com/oxiaojiano/p/7918967.html" target="_blank" rel="noopener">cnblogs上一篇关于优先级问题的文章</a></li><li><a href="http://www.jb51.net/article/79437.htm" target="_blank" rel="noopener">极易被忽视的javascript面试题七问七答</a></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo同步源文件至GitHub</title>
      <link href="/2018/02/26/20180226-Hexo%E5%90%8C%E6%AD%A5%E6%BA%90%E6%96%87%E4%BB%B6%E8%87%B3GitHub/"/>
      <url>/2018/02/26/20180226-Hexo%E5%90%8C%E6%AD%A5%E6%BA%90%E6%96%87%E4%BB%B6%E8%87%B3GitHub/</url>
      
        <content type="html"><![CDATA[<p>以前用Hexo最大的痛点就是想在其他电脑上写文章然后更新站点很麻烦，或者换系统后发现忘记备份源文件，然后以前写的东西又得通过各种方法找回再重新部署。没办法，静态站点就是这样。</p><p>此时程序员思维就出现了，能不能在我每次写完新文章后自动备份源文件，或者我在<code>hexo d</code>的时候一起把我的<code>.md</code>文件也deploy上去。</p><p>当然，方法各种，这里我直接使用 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 这个小插件的功能，相对简单些。</p><a id="more"></a><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>直接一句话搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>当然，作者说如果想使用最新版，可用下面的命令：</p><ul><li>对于npm版本低于4的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install git+git@github.com:hexojs/hexo-deployer-git.git --save</span></span><br></pre></td></tr></table></figure><ul><li>对于npm版本低于5的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install git+ssh://git@github.com:hexojs/hexo-deployer-git.git --save</span></span><br></pre></td></tr></table></figure><blockquote><p>查看自己npm版本的命令：<code>npm --version</code></p></blockquote><p>其实如果你原先就是将hexo部署在GitHub Pages，那这个插件是已经安装过了，只需要进行相关配置就行。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>修改hexo根目录下的<code>_config.yml</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> _config.yaml</span></span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line">    branch: src</span><br><span class="line">    extend_dirs: /</span><br><span class="line">    ignore_hidden: false</span><br><span class="line">    ignore_pattern:</span><br><span class="line">        public: .</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>第一个master分支是你静态页面所在分支，也就是<code>hexo g</code>后生成的<code>public</code>文件夹中的内容</li><li>第二个src分支就是备份你源文件的，具体参数请参考原作者写的</li></ul><p>如此之后，在每次<code>hexo d</code>后就能将你的源文件备份至<code>src</code>分支，没有更爽。</p><p>当然，安装后每次 deploy 会比原来稍慢点。</p><p>还有，未配置过<code>git user</code>信息的会提示要配置user.mail和user.name：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email "you@example.com"</span><br><span class="line">git config --global user.name "Your Name"</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git 的GitHub地址</a> </li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Hexo官方关于deployment的说明</a></li><li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">知乎上关于换电脑后hexo该怎么更新的回答</a></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS笔试基础知识点</title>
      <link href="/2018/01/18/20180118-JS%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/01/18/20180118-JS%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>听公开课讲得一些JS笔试中容易出现的知识点。</p><p>与其说是知识点，不如说是—“那些年走过的JS大坑”</p><p>一般关于JS的笔试会走两极端—-要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）</p><a id="more"></a><h1 id="字面量相关"><a href="#字面量相关" class="headerlink" title="字面量相关"></a>字面量相关</h1><p>定义：计算机能识别类型的数据。</p><h2 id="特殊字面量"><a href="#特殊字面量" class="headerlink" title="特殊字面量"></a>特殊字面量</h2><p>顾名思义，计算机识别不了的—NaN，指的不是一个正常的数。</p><h2 id="常见考察点"><a href="#常见考察点" class="headerlink" title="常见考察点"></a>常见考察点</h2><ul><li>正数/0=正无穷Infinity</li><li>0/0=NaN</li><li>parseInt(“string”); 将字符串转为整数的数字类型，条件：纯数字字符串或数字开头字符串，其他为NaN</li><li>数据类型参与数值运算：<ul><li>”数据类型—数字、字符串、undefined、布尔、null”；</li><li>”数学运算— + - * / %”。</li><li>非数字参与数学运算会把非数字转换（<strong>隐式转换</strong>）为数字再参与运算。除null、false转换为0，数字字符串转为数字，其余包括undefined为NaN</li></ul></li></ul><h1 id="各种运算符"><a href="#各种运算符" class="headerlink" title="各种运算符"></a>各种运算符</h1><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><ul><li><code>==</code> 相等  <code>===</code>全等于，即除判断值是否相等，还要判断数据类型，如<code>1</code>和<code>true</code>。<code>!=</code> 不相等（与<code>==</code>相反）</li><li>比较运算的结果就是布尔值，<code>true</code>/<code>false</code></li><li>其他数据参与比较运算时，也会隐式转换为数字参与运算</li><li><code>NaN</code>参与的话，无论与谁都是不等于<code>false</code></li><li><code>IsNaN()</code>方法，判断一个数是否能转为<code>NaN</code>，能<code>true</code>，否<code>false</code>，能转的有：非数字字符串、<code>undefined</code></li></ul><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>上面说到了比较运算符 <code>==</code> 和<code>===</code>，下面总结一下与等式(包括<code>==</code>, <code>===</code>, <code>!=</code>, 和 <code>!==</code>)相关的东西。</p><p>首先说下<code>==</code>和<code>===</code>的区别，<code>==</code>只检查<strong>值(value)</strong>是否相同，而<code>===</code>不仅比较<strong>值(value)</strong>还要检查<strong>数据类型(type)</strong>是否相同，所以<code>==</code>又叫做<strong>松等于(loose-equality)</strong> ，<code>===</code>又叫做<strong>严格等于(strict-equality)</strong>。</p><blockquote><p><strong>注1：</strong>在比较时，若比较两端非<code>number</code>类型，则会自动转换为<code>number</code>类型再进行比较。</p><p><strong>注2：</strong>如果比较两个非原始值，比如对象<code>object</code>（包括函数<code>function</code>和数组<code>array</code>）。因为这些值实际上是通过引用保存的，所以<code>==</code>和<code>===</code>比较都只是检查引用是否匹配，而不是基本值。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"42"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">a == b;<span class="comment">// true</span></span><br><span class="line">a === b;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"1,2,3"</span>;</span><br><span class="line"></span><br><span class="line">a == c;<span class="comment">// true</span></span><br><span class="line">b == c;<span class="comment">// true</span></span><br><span class="line">a == b;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这时候就有一个问题，什么时候使用<code>==</code>，什么时候使用<code>===</code>呢？有如下几个基本规则：</p><ul><li>如果比较两端值的类型是<code>boolean</code>类型，<code>true/false</code>，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>如果比较两端的值是些特别的值(<code>0</code>, <code>&quot;&quot;</code>, or <code>[]</code> – empty array)，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>其他都用<code>==</code>吧</li></ul><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><p>有等式当然就有不等式，有<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, 和 <code>&gt;=</code>四种不等式。一般用于比较<code>number</code>类型，但在JavaScript中<code>string</code>值也能被比较。</p><blockquote><p><strong>注：</strong>这里没有严格不等式。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">41</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"42"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"43"</span>;</span><br><span class="line"></span><br><span class="line">a &lt; b;<span class="comment">// true</span></span><br><span class="line">b &lt; c;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"foo"</span>;</span><br><span class="line"></span><br><span class="line">a &lt; b;<span class="comment">// false</span></span><br><span class="line">a &gt; b;<span class="comment">// false</span></span><br><span class="line">a == b;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>例子二中 b值的类型是<code>string</code>，在参与不等式比较时，会强制转换为<code>NaN</code>，而<code>NaN</code>和谁都不相等，包括和它自己。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 +="></a>赋值运算符 +=</h2><ul><li>必须有变量参与运算</li><li>特殊：++递加- -递减，变量出现一次叫做使用一次。可为a++或++a</li></ul><h2 id="逻辑运算符-amp-amp-、-、"><a href="#逻辑运算符-amp-amp-、-、" class="headerlink" title="逻辑运算符 &amp;&amp; 、||、!"></a>逻辑运算符 &amp;&amp; 、||、!</h2><ul><li>规律：逻辑与和逻辑或，答案都与第一个操作数a能够判读为true/false有关，如判断为假的有—null、undefined、0、NaN、” ” 空字符串；判断为真—非0非NaN数字、非空字符串</li><li>与运算&amp;&amp;：a&amp;&amp;b，如果a为true，则结果就是b；如果a为false，则为false</li><li>逻辑或||：a||b，如果a为true，结果就是true；如果a为false，则结果为b</li><li>逻辑非：</li></ul><h2 id="Truthy-amp-Falsy"><a href="#Truthy-amp-Falsy" class="headerlink" title="Truthy &amp; Falsy"></a>Truthy &amp; Falsy</h2><p>总结一下一些奇葩的<code>boolean</code>类型，一般性的布尔值没什么好说的。特别提下一些会被判断为truthy和falsy。</p><p>一些特别的”falsy”如下：</p><ul><li><code>&quot;&quot;</code> (empty string)</li><li><code>0</code>，<code>-0</code>，<code>NaN</code> (invalid number)</li><li><code>null</code>,<code>undefined</code></li><li><code>false</code></li></ul><p>一些特别的“truthy”如下:</p><ul><li><code>&quot;hello&quot;</code></li><li><code>42</code></li><li><code>true</code></li><li><code>[ ]</code>, <code>[ 1, &quot;2&quot;, 3 ]</code> (arrays)</li><li><code>{ }</code>, <code>{ a: 42 }</code> (objects)</li><li><code>function foo() { .. }</code> (functions)</li></ul><h2 id="三元运算符—"><a href="#三元运算符—" class="headerlink" title="三元运算符— ? :"></a>三元运算符— ? :</h2><p>或作为条件分支语句</p><p>​         Boolean_expression? true_value : false_value;</p><h1 id="变量、作用域"><a href="#变量、作用域" class="headerlink" title="变量、作用域"></a>变量、作用域</h1><ul><li>JS中无{}块作用域，只有函数结构function封住一个作用域。</li><li>局部变量/全局变量。不同作用域中如都定义了同一个名字的变量，有一个查找作用域链—从内到外(如本层(层指的是function)有直接使用，如无依次向外层查找)</li><li>如变量未定义直接使用会提示引用错误，但可先使用再定义变量，但会导致变量声明提升问题undefined—JS解释器解释代码时，会将所有变量定义的过程提升到作用域代码最前面，相当于先定义了，但未赋值，默认undefined。</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>这个必考。。。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>函数就是闭包。</li><li>函数是一种对象型数据，对象型数据创建时有一个数据原型，如果将一个对象型数据赋值给变量，则变量中存的不是原型，而是指针/地址</li><li>如果将一个变量赋值给另一个变量，相当于将地址复制一份给另一个变量</li><li>每一个通过function定义的函数都是一个新的闭包</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n+ i++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fo();</span><br><span class="line">f(<span class="number">20</span>);</span><br><span class="line">fo()(<span class="number">20</span>);</span><br><span class="line">fo()(<span class="number">10</span>);</span><br><span class="line">f(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>   <span class="comment">//n=20,i=0,n+i=20,i++后得1，输出20</span></span><br><span class="line"><span class="number">20</span> <span class="comment">//创建新闭包，结果同上</span></span><br><span class="line"><span class="number">10</span> <span class="comment">//同理</span></span><br><span class="line"><span class="number">11</span> <span class="comment">//由于前f(20);影响，i为1，第二次执行f();则为11，I、i++后得3</span></span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">arr1.push(arr1.shift());</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>数组也是对象型数据，存储给变量时，给的是指向数据原型的地址。</li><li>shift();</li><li>push();</li></ul><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5.6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr2[0]=8;    #[8,5,6,7]</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr1.push(arr1.shift());#[5,6,7,8]</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md" target="_blank" rel="noopener">You-Dont-Know-JS:: Up &amp; Going</a></li></ul><p>待续。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面筋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL7.0日志分析记录</title>
      <link href="/2017/12/20/20171220-RHEL7.0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/12/20/20171220-RHEL7.0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一个客户服务老挂，检查服务器，无法ping通且登录界面黑屏，只能强行重启，尝试检查日志发现默认日志为重启删除，坑。</p><a id="more"></a><p><strong>服务器信息</strong></p><ul><li>Red Hat Enterprise Linux Server release 7.0 (Maipo)</li></ul><h1 id="日志相关回顾"><a href="#日志相关回顾" class="headerlink" title="日志相关回顾"></a>日志相关回顾</h1><p>一般位置：<code>/var/log</code></p><h2 id="常见日志："><a href="#常见日志：" class="headerlink" title="常见日志："></a>常见日志：</h2><ul><li><p>/var/log/boot.log</p><p>顾名思义，系统启动日志，仅保留本次开机</p></li><li><p>/var/log/cron</p><p>所有<code>crontab</code>计划任务日志</p></li><li><p>/var/log/lastlog</p><p>记录系统所有账号最后登录信息</p></li></ul><ul><li><p>/var/log/maillog &amp;  /var/log/mail/*</p><p>往来邮件日志记录</p></li><li><p>/var/log/messages</p><p>系统重要信息基本都在这，为必看日志</p></li><li><p>/var/log/secure</p><p>凡是需要账号密码的日志都在里面</p></li></ul><h2 id="主要进程服务-daemon"><a href="#主要进程服务-daemon" class="headerlink" title="主要进程服务(daemon)"></a>主要进程服务(daemon)</h2><ul><li>systemd-journald.service  7系列版本新增，默认存在内存中，重启即失效，本次日志分析主要用的</li><li>rsyslog.service 记录系统和网络的信息，配置文件<code>/etc/rsyslog.conf</code></li><li>logrotate 用于日志自动化处理的服务，配置文件<code>/etc/logrotate.conf</code></li></ul><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><ul><li>debug </li><li>info</li><li>notice</li><li>warning(warn) </li><li>err(error)  重大错误信息</li><li>crit</li><li>alert</li><li>emerg(panic)</li></ul><blockquote><p>注：在讯息等级之前还有.[=!] 的连结符号，代表的意思是这样的：</p><ul><li>.：代表『比后面还要严重的等级(含该等级)都被记录下来』的意思，例如： mail.info代表只要是mail的资讯，而且该资讯等级严重于info (含info本身)时，就会被记录下来的意思。</li><li>.=：代表所需要的等级就是后面接的等级而已，其他的不要！</li><li>.!：有点反向选择的感觉，代表忽略大于等于这个等级的讯息！亦即是低于这个等级的才会被纪录的意思！</li></ul></blockquote><h1 id="使用journalctl查看日志"><a href="#使用journalctl查看日志" class="headerlink" title="使用journalctl查看日志"></a>使用journalctl查看日志</h1><h2 id="journalctl命令"><a href="#journalctl命令" class="headerlink" title="journalctl命令"></a>journalctl命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># journalctl [-nrpf] [--since TIME] [--until TIME] _optional </span></span><br><span class="line">选项与参数：</span><br><span class="line">预设会show出全部的<span class="built_in">log</span> 内容，从旧的输出到最新的日志</span><br><span class="line">-n ：show出最近的几行的意思～找最新的日志相当有用</span><br><span class="line">-r ：反向输出，从最新的输出到最旧的资料</span><br><span class="line">-p ：show出后面所接的日志重要性排序！</span><br><span class="line">-f ：类似tail -f 的功能，持续显示journal 日志的内容(即时监测时相当有帮助！)</span><br><span class="line">--since --until：设定开始与结束的时间，让在该期间的资料输出而已</span><br><span class="line">_SYSTEMD_UNIT=unit.service ：只输出unit.service 的日志而已</span><br><span class="line">_COMM=bash ：只输出与bash 有关的日志</span><br><span class="line">_PID=pid ：只输出PID 号码的日志</span><br><span class="line">_UID=uid ：只输出UID 为uid 的日志</span><br><span class="line">SYSLOG_FACILITY=[0-23] ：使用syslog.h 规范的服务相对序号来呼叫出正确的资料！</span><br></pre></td></tr></table></figure><p>例子：</p><p>查看特定优先级日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># journalctl -p err</span></span><br></pre></td></tr></table></figure><p>查看特定时间日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># journalctl --since "2017-12-17" --until "2017-12-19"</span></span><br></pre></td></tr></table></figure><p>显示本次启动后日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># journalctl -b [-0/-1/-2] #-0表本次启动信息，-1表上次启动</span></span><br></pre></td></tr></table></figure><h2 id="永久保存记录办法"><a href="#永久保存记录办法" class="headerlink" title="永久保存记录办法"></a>永久保存记录办法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@binlv ~]<span class="comment"># mkdir /var/log/journal</span></span><br><span class="line">[root@binlv ~]<span class="comment"># chown root:systemd-journal /var/log/journal/</span></span><br><span class="line">[root@binlv ~]<span class="comment"># chmod 2755 /var/log/journal/</span></span><br><span class="line">[root@binlv ~]<span class="comment"># killall -USR1 systemd-journald</span></span><br></pre></td></tr></table></figure><blockquote><p>注：默认情况下，日志大小不能超过所处文件系统的10%，也不可使所处文件系统空间低于15%。在 /etc/systemd/journald.conf 可进行大小容量上的调节；而在 /etc/logrotate.conf 则定义了那些日志文件记录、怎么记录、记录多少。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.linuxidc.com/Linux/2016-01/127729.htm" target="_blank" rel="noopener">RHEL7.0日志系统</a></li><li><a href="http://linux.vbird.org/linux_basic/0570syslog.php#whatis_syslog_1" target="_blank" rel="noopener">鸟哥私房菜之syslog</a></li><li><a href="http://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="noopener">Systemd 日志系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NBU catalog报错处理办法</title>
      <link href="/2017/12/08/20171208-NBU%20catalog%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
      <url>/2017/12/08/20171208-NBU%20catalog%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h1><ul><li><p>环境说明：</p><ul><li>NBU 7.7.3 Master Server</li><li>Windows Server 2008R2 x64操作系统</li></ul></li><li><p>NBU Master Server备份catalog一直报错，错误代码2</p><ul><li><p>status详细信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging relational database files <span class="keyword">for</span> catalog backup</span><br><span class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:30 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</span><br><span class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</span><br><span class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</span><br><span class="line">none of the requested files were backed up  (2)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检查系统进程 已运行700+进程，怀疑进程过多导致Master hang死</p></li></ul><a id="more"></a><h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>根据报错信息，定位<code>C:\Program Files\Veritas\NetBackupDB\staging</code>目录，删除该目录文件，重启服务后手动发起catalog备份，成功。</p><p>第二天再发起再次报错，非长久之计。</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>报case，协助工程师收集cab。</p><p>对于Windows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\windows\system32\chcp 437</span><br><span class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -use_reg_cmd 64 (<span class="keyword">for</span> 64bit)</span><br></pre></td></tr></table></figure><p>执行nbsu到network service卡住，询问工程师终止命令，执行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -c -use_reg_cmd 64</span><br></pre></td></tr></table></figure><p>产生LOG 的路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Veritas\netbackup\bin\support\output\nbsu (后缀名是cab)</span><br></pre></td></tr></table></figure><p>后操作如下</p><ol><li><p>Delete the outstanding nbtelemetry.exe processes in task manager, this in turn stopped the nbtelesched.exe processes. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br><span class="line">taskkill /im nbtelemetry.exe /f</span><br></pre></td></tr></table></figure><p>强制结束进程</p></li><li><p>Once these were deleted, went into directory Program files\Veritas\Netbackup\bin<br>Renamed nbtelemetry.exe and nbtelesched.exe to nbtelemetry.exe.old and nbtelesched.exe.old. </p><p>若无法重命名，重启机器再修改</p></li><li><p>Run regedit and go to the following key<br>HKLM(HKEY_LOCAL_MACHINE)\Software\VERITAS\NetBackup\CurrentVersion\Config\TELEMETRY_UPLOAD<br>Changed TELEMETRY_UPLOAD from YES to NO under the registry editor.</p><p>再次发起catalog备份，正常。</p></li></ol><p>观察几天，进程数不超过100，且备份catalog不报错.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="NBU-catalog"><a href="#NBU-catalog" class="headerlink" title="NBU catalog"></a>NBU catalog</h2><p>NetBackup自身有一索引数据库，主要记录每次备份的相关信息。比如从哪个Client备<br>份的，保留多长时间等。 </p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netbackup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle参数文件</title>
      <link href="/2017/12/05/20171205-Oracle%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6/"/>
      <url>/2017/12/05/20171205-Oracle%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为平时做数据库恢复需检查pfile文件，对这方面空白较多，查了点资料，详细了解一下。</p><a id="more"></a><h1 id="参数文件类型"><a href="#参数文件类型" class="headerlink" title="参数文件类型"></a>参数文件类型</h1><p>pfile –parameter file 文本文件</p><p>spfile –server parameter file  二进制文件</p><p>9i后才有，通过alter system 修改到spfile 下次启动生效</p><h2 id="pfile"><a href="#pfile" class="headerlink" title="pfile"></a>pfile</h2><p>作用：文件记录数据库配置与功能开启或关闭</p><p>数据库启动时需读取参数文件内容，实例启动后就一直在内存中。</p><p>文件位置：通过dbca图形工具建立数据库，有一个模板参数文件pfile</p><p><code>$ORACLE_BASE/admin/&lt;db_unique_name&gt;/pfile/init.ora.&lt;n+&gt;</code></p><p>修改到参数文件达到时候需要关闭数据库然后才有效</p><p>10g后只有spfile <code>$ORACLE_BASE/dbs/spfile$ORACLE_SID.ora</code></p><p>手工建库没有模板参数文件</p><p>##spfile</p><p>通过pfile文件可以定义spfile=’’路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql&gt; show parameter spfile</span><br></pre></td></tr></table></figure><p>数据库读取参数文件顺序</p><ol><li><code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code></li><li><code>ORACLE_HOME/dbs/spfile.ora</code></li><li><code>ORACLE_HOME/dbs/init&lt;SID&gt;.ora</code></li></ol><blockquote><p>注：</p><p>若维护的是RAC，不要执行create pfile from spfile;</p><p>因为若spfile文件丢失，启动一个实例，执行create spfile from pfile;后sfile会存放在<code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code>，再启动一个实例后会想修改参数文件会报错，为非共享文件。</p><p>维护ASM存放参数文件也不能使用create pfile命令</p></blockquote><h1 id="修改参数文件"><a href="#修改参数文件" class="headerlink" title="修改参数文件"></a>修改参数文件</h1><h2 id="修改pfile"><a href="#修改pfile" class="headerlink" title="修改pfile"></a>修改pfile</h2><p>pfile一般修改需要重启数据库才能生效</p><p>startup force</p><h2 id="修改spfile"><a href="#修改spfile" class="headerlink" title="修改spfile"></a>修改spfile</h2><p>参数分类：</p><p>系统参数：alter system set 参数=值 scope=memory|spfile|both [sid=’…’];</p><p>会话参数 alter session set 参数=值;</p><p>系统参数的分类：</p><ol><li>动态 alter system set 参数=值; alter system set 参数=值 scope=memory;</li><li>静态 alter system set 参数=值 scope=spfile;</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> pfile </tag>
            
            <tag> spfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+Hexo+SSL搭建个人站点</title>
      <link href="/2017/11/28/20171128-Nginx-Hexo-SSL%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"/>
      <url>/2017/11/28/20171128-Nginx-Hexo-SSL%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>给闲置VPS增加点用处系列</p><a id="more"></a><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx相关安装配置参照我的<a href="https://binlv.top/2017/11/27/20171127-部署Nginx服务与基本配置/" target="_blank" rel="noopener">上一篇关于Nginx配置的文章</a></p><h1 id="Hexo-部署至Nginx"><a href="#Hexo-部署至Nginx" class="headerlink" title="Hexo 部署至Nginx"></a>Hexo 部署至Nginx</h1><p>一般有三种方法</p><ul><li>git设置git hook方式</li><li>rsync同步本地Hexo至VPS</li><li>VPS上部署Hexo，并执行<code>hexo server</code> ，再配置Nginx反向代理，让域名指向 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></li></ul><h2 id="git-hook方式"><a href="#git-hook方式" class="headerlink" title="git hook方式"></a>git hook方式</h2><h3 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h3><p>安装git并创建仓库，设置git hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git -y</span><br><span class="line">mkdir &lt;git工作目录&gt; &amp;&amp; <span class="built_in">cd</span> &lt;git工作目录&gt;</span><br><span class="line">git init --bare</span><br><span class="line">nano &lt;git工作目录&gt;/hook/post-reveive</span><br></pre></td></tr></table></figure><p>将以下内容修改好放入<code>post-reveive</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">GIT_REPO=/var/www/blog.git  <span class="comment">#git仓库</span></span><br><span class="line">TMP_GIT_CLONE=/tmp/blog</span><br><span class="line">PUBLIC_WWW=/var/www/blog <span class="comment">#网站目录</span></span><br><span class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></span><br></pre></td></tr></table></figure><p>或使用如下命令放入<code>post-reveive</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -l</span></span><br><span class="line">git --work-tree=/var/www/blog --git-dir=/var/www/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>赋予执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure><h3 id="在本机配置"><a href="#在本机配置" class="headerlink" title="在本机配置"></a>在本机配置</h3><p>在博客目录下运行下面命令，安装 git 部署工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改博客的配置文件 _config.yml，修改deploy选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: 用户名@服务器地址:/var/www/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h1 id="开启站点HTTPS"><a href="#开启站点HTTPS" class="headerlink" title="开启站点HTTPS"></a>开启站点HTTPS</h1><p>https需要授权证书，这里使用的是<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a>家的免费证书。</p><p>对了，要开启HTTPS首先你得有个人域名，因为证书是给域名授权的。至于域名申请，万网之类的都行，然后解析指向你的服务器。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install letsencrypt</span><br></pre></td></tr></table></figure><p>获取证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">letsencrypt certonly</span><br></pre></td></tr></table></figure><p>根据提示完成获取，中间需要输入你的域名，最后出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- Congratulations! Your certificate and chain have been saved at</span><br><span class="line">  /etc/letsencrypt/live/&lt;你的域名&gt;/fullchain.pem. Your cert will</span><br><span class="line">  expire on 2017-09-17. To obtain a new or tweaked version of this</span><br><span class="line">  certificate <span class="keyword">in</span> the future, simply run certbot-auto again. To</span><br><span class="line">  non-interactively renew *all* of your certificates, run</span><br><span class="line">  <span class="string">"certbot-auto renew"</span></span><br><span class="line">- If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">  Donating to ISRG / Let<span class="string">'s Encrypt:   https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">  Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure><p>  就成功了，看提示，所有的证书文件在 <code>/etc/letsencrypt/live/你的域名</code>下，里面有下面几个文件证书文件，引用别人的解释下：</p><blockquote><ul><li><code>privkey.pem</code></li></ul><p>这是私匙，对应 Nginx 的 ssl_certificate_key 选项，或者 Apache2 的 SSLCertificateKeyFile 选项。</p><ul><li><code>cert.pem</code> </li></ul><p>服务器证书，这个只有 Apache2 低于 2.4.8 版本需要，对应 SSLCertificateFile 选项。</p><ul><li><code>chain.pem</code></li></ul><p>除服务器证书之外的所有证书，对于 1.3.7 版以上的 Nginx 对应 ssl_trusted_certificate 选项，对于低于2.4.8 的 Apache2 对应 SSLCertificateChainFile 选项。</p><ul><li><code>fullchain.pem</code></li></ul><p>包括上面的服务器证书和其他证书, Nginx 对应 ssl_certificate 选项，2.4.8 版以上的 Apache2 对应 SSLCertificateFile 选项。</p><p>如果是 Nginx，需要上面的 privkey.pem（对应 ssl_certificate_key 选项）和 fullchain.pem （对应 ssl_certificate 选项），还需要一个 dhparam.pem（对应 ssl_dhparam 选项） 需自己生成：</p><p>openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</p><p>这个文件创建稍微需要一点时间，注意看我的路径，我的是在 /etc/nginx/ssl/ 下，如果没有ssl这个目录就自己建一个，当然你换其他地方也行。</p></blockquote><p>有了这三个文件: <code>privkey.pem</code>、<code>fullchain.pem</code> 、<code>dhparam.pem</code> 就可以配置 Nginx 了。</p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name binlv.top;</span><br><span class="line">    <span class="comment">#实现访问http的时候自动跳转到https</span></span><br><span class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    server_name binlv.top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#不输出 Nginx 版本号及其他错误信息</span></span><br><span class="line">    server_tokens off;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开启 HSTS,这么写是为了提交到 https://hstspreload.org/</span></span><br><span class="line">        add_header Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains"</span> always;</span><br><span class="line">        <span class="comment"># 启用 XSS 保护，检查到 XSS 攻击时，停止渲染页面。</span></span><br><span class="line">    add_header X-XSS-Protection <span class="string">"1; mode=block"</span>;</span><br><span class="line">    </span><br><span class="line">        ssl_certificate /etc/letsencrypt/live/binlv.top/fullchain.pem;</span><br><span class="line">        ssl_certificate_key /etc/letsencrypt/live/binlv.top/privkey.pem;</span><br><span class="line">        ssl_dhparam /etc/nginx/ssl/dhparam.pem;</span><br><span class="line">        ssl_session_cache shared:SSL:50m;</span><br><span class="line">        ssl_session_timeout 1d;</span><br><span class="line">        ssl_session_tickets off;</span><br><span class="line">        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers <span class="string">'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'</span>;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        ssl_stapling on;</span><br><span class="line">        ssl_stapling_verify on;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/blog;</span><br><span class="line">        index index.php index.htm index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新配置后要重启一下Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></p><h2 id="设置证书自动更新"><a href="#设置证书自动更新" class="headerlink" title="设置证书自动更新"></a>设置证书自动更新</h2><p>Let’s Encrypt SSL 免费证书为短期证书，只有 90 天期限，提示到期前可以运行命令 <code>letsencrypt renew</code> 续期</p><p>实现定时更新证书，我们可以用linux自带的定时器crontab<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure></p><p>输入：　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　30 2 1 * * /usr/bin/letsencrypt renew &gt;&gt; /var/<span class="built_in">log</span>/letsencrypt/le-renew.log</span><br><span class="line">　　35 2 1 * * /usr/bin/systemctl reload nginx</span><br></pre></td></tr></table></figure></p><h2 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h2><p>如果想把授权的域名取消该怎么办呢？因为免费证书如果不定期更新的话几个月就会自动过期，所以删掉本地部署时对应创建的几个文件就行啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /etc/letsencrypt/live/www.example.com/</span><br><span class="line">rm -rf /etc/letsencrypt/archive/www.example.com/</span><br><span class="line">rm /etc/letsencrypt/renewal/www.example.com.conf</span><br></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>很多。。。</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7" target="_blank" rel="noopener">CentOS 7配置Nginx+SSL，参考</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">git hooks 官方文档</a></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Nginx服务与基本配置</title>
      <link href="/2017/11/27/20171127-%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/11/27/20171127-%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>个人站点原部署在<a href="https://github.com/baylin87/baylin87.github.io" target="_blank" rel="noopener">GitHub</a>，借助其<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub-Pages</a>功能实现免费的个人站点部署。后考虑到VPS资源闲置，加上GitHub-Pages貌似不能用<code>https</code>，就想迁移过去玩玩。</p><p>当然，实现方法有很多，我选的是用Nginx + Hexo部署。</p><a id="more"></a><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul><li>操作系统：Ubuntu 16.04.2 LTS (xenial)</li><li>Nginx version : nginx/1.12.2  built with OpenSSL 1.0.2g</li></ul><h1 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h1><p>Nginx安装与配置。</p><h2 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h2><p>Ubuntu 有对应apt安装包，但需配置。</p><p>1.获取Nginx认证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/keys/nginx_signing.key</span><br></pre></td></tr></table></figure><p>2.将该key添加到apt中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key add nginx_signing.key</span><br></pre></td></tr></table></figure><p>3.添加nginx软件源</p><p>For Ubuntu replace codename with Ubuntu distribution codename, and append the following to the end of the <code>etc/apt/sources.list</code>file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://nginx.org/packages/ubuntu/ xenial nginx</span><br><span class="line">deb-src http://nginx.org/packages/ubuntu/ xenial nginx</span><br></pre></td></tr></table></figure><p>4.更新源并安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure><p>5.启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>6.默认nginx配置文件路径</p><p><code>/usr/local/nginx/conf</code>,<code>/etc/nginx</code>, or<code>/usr/local/etc/nginx</code></p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name binlv.top;</span><br><span class="line"><span class="comment">#实现访问http的时候自动跳转到https</span></span><br><span class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2;</span><br><span class="line">listen [::]:443 ssl http2;</span><br><span class="line">server_name binlv.top;</span><br><span class="line"></span><br><span class="line"><span class="comment">#不输出 Nginx 版本号及其他错误信息</span></span><br><span class="line">server_tokens off;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        root &lt;--路径--&gt;;</span><br><span class="line">        index index.php index.htm index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>使nginx开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx document</a></li></ul><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="/2017/10/12/20171012-iptables/"/>
      <url>/2017/10/12/20171012-iptables/</url>
      
        <content type="html"><![CDATA[<h1 id="iptables完全控制"><a href="#iptables完全控制" class="headerlink" title="iptables完全控制"></a>iptables完全控制</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>搭建一套企业实际使用的防火墙规则</li><li>防攻击</li><li>数据包转发</li><li>实际使用意义</li></ol><a id="more"></a><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>—Linux用于数据包处理，iptables会调用其使用</p><h2 id="Hook-point"><a href="#Hook-point" class="headerlink" title="Hook point"></a>Hook point</h2><p>—数据包在Netfilter中的挂载点</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-01.png" alt="Netfilter与iptables关系"></p><h2 id="iptables规则组成"><a href="#iptables规则组成" class="headerlink" title="iptables规则组成"></a>iptables规则组成</h2><p><strong>4表5链</strong><br>表：filter、nat、mangle、raw<br>链：INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING</p><p><strong>作用：</strong></p><p>mangle:修改数据包，改变包头内容（TTL、TOS、MARK）<br>raw：数据包状态跟踪分析</p><p>filter：访问控制、规则匹配<br>nat：地址转发</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-02.png" alt="数据包在规则表、链匹配流程"></p><h2 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h2><ol><li>访问控制：ACCEPT、DROP、REJECT</li><li>改写数据包：SNAT、DNAT</li><li>信息记录：LOG</li></ol><h2 id="规则组成"><a href="#规则组成" class="headerlink" title="规则组成"></a>规则组成</h2><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-03.png" alt="iptables规则组成"></p><hr><h1 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp dprot 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>待续。</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zepto.js 源码分析</title>
      <link href="/2017/09/22/20170922-zepto/"/>
      <url>/2017/09/22/20170922-zepto/</url>
      
        <content type="html"><![CDATA[<p>尝试分析 Zepto 源码</p><h1 id="从-开始"><a href="#从-开始" class="headerlink" title="从 `#   开始"></a>从 `#   开始</h1><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script src=<span class="string">"js/zepto.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">    <span class="built_in">console</span>.log($);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>控制台打印 <code>$</code> 输出<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ƒ (selector, context)&#123;</span><br><span class="line">    <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>可见 <code>$</code> 应该是一个全局变量，然后给它赋值一个函数，查看源码第235行，写了如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ = ƒunction (selector, context)&#123;</span><br><span class="line">   <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>噢，确实是这样，但为什么没用var来声明，找找，发现其实是定义了的，在第9行声明了<code>var $</code> ，故其实zepto可写成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略N行代码...</span></span><br><span class="line">    </span><br><span class="line">    $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略N行代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.Zepto = Zepto</span><br><span class="line"><span class="built_in">window</span>.$ === <span class="literal">undefined</span> &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</span><br></pre></td></tr></table></figure><p>然后我们发现 <code>$</code> 其返回值又是一个zepto.init()应该又是一个函数，那我再打印<code>$()</code>应该就是返回init()执行结果，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回了一个叫 <code>Z</code>的对象</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Zepto.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible初步</title>
      <link href="/2017/09/01/20170901-ansible%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/09/01/20170901-ansible%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><ul><li>了解ansible能做什么</li><li>了解ansible部署环境</li><li>安装ansible管理主机</li></ul><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.ansible.com/" target="_blank" rel="noopener">ansible官方</a></li><li><a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">ansible的github Project</a></li><li><a href="http://ansible-tran.readthedocs.io" target="_blank" rel="noopener">ansible中文权威指南</a></li></ul><h1 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h1><h2 id="why-ansible"><a href="#why-ansible" class="headerlink" title="why ansible?"></a>why ansible?</h2><p>引用ansible在github上的介绍：</p><blockquote><p>Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications— automate in a language that approaches plain English, using SSH, with no agents to install on remote systems. </p></blockquote><p>简单说就是运维自动化，减少重复部署，使用SSH协议，且无需安装客户端。</p><p>要说缺点嘛，管理主机不能是Windows，Nagios也是==。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><ul><li>Python2.6以上</li><li>Linux/Unix各发行版</li></ul><p>安装过程略。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170901-ansible01.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="python模块"></p><p>本机环境</p><ul><li>Ubuntu 16.04.3 LTS (GNU/Linux 4.10.0-28-generic x86_64)</li><li>Python 2.7.12</li><li>OpenSSH_7.2p2 Ubuntu-4ubuntu2.2, OpenSSL 1.0.2g  1 Mar 2016</li><li>ansible 2.0.0.2</li></ul><h2 id="ansible连接远程主机原理"><a href="#ansible连接远程主机原理" class="headerlink" title="ansible连接远程主机原理"></a>ansible连接远程主机原理</h2><p>默认会在本地的 OpenSSH可用时会尝试用其进行远程通讯.这会启用ControlPersist(一个性能特性,SSH_5.6以上支持),<a href="https://zh.wikipedia.org/zh-hans/Kerberos" target="_blank" rel="noopener">Kerberos</a>,和在~/.ssh/config中的配置选项如 Jump Host setup.然而,当你使用Linux企业版6作为主控机(红帽企业版及其衍生版如CentOS),其OpenSSH版本可能过于老旧无法支持ControlPersist. 在这些操作系统中,Ansible将会退回并采用 paramiko (由Python实现的高质量OpenSSH库). 如果你希望能够使用像是Kerberized SSH之类的特性,烦请考虑使用Fedora, OS X, 或 Ubuntu 作为你的主控机直到相关平台上有更新版本的OpenSSH可供使用,或者启用Ansible的“accelerated mode”.</p><h2 id="添加受控主机"><a href="#添加受控主机" class="headerlink" title="添加受控主机"></a>添加受控主机</h2><p>将管理主机公钥添加到受控主机的.ssh/authorized_keys文件中。</p><p>最快的方法是使用<code>ssh_copy_id</code>命令。</p><p>添加好测试一下。</p><p>然后编辑<code>/etc/ansible/hosts</code>文件，将受控主机IP地址添加到文件中。</p><p>执行<code>ansible all -m ping</code>，如返回<code>SUCCESS</code>则成功，如其他，则可使用<code>-vvvv</code>参数输出详细log，排错。</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> 自动化运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker machine</title>
      <link href="/2017/08/14/20170814-docker-machine/"/>
      <url>/2017/08/14/20170814-docker-machine/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="noopener">官方参考文档</a></p><p><a href="https://yq.aliyun.com/articles/110806" target="_blank" rel="noopener">阿里Docker CE镜像源站</a></p></blockquote><h1 id="What-is-Docker-Machine"><a href="#What-is-Docker-Machine" class="headerlink" title="What is Docker Machine ?"></a>What is Docker Machine ?</h1><p>Docker Machine is <strong>a tool that lets you install Docker Engine on virtual hosts</strong>, and manage the hosts with <code>docker-machine</code> commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.</p><p>当在一台宿主机上安装docker，我们需要如下几个步骤（Ubuntu）</p><ol><li>安装 https CA 证书</li><li>添加 GPG key</li><li>添加 docker apt 源</li><li>安装 docker</li></ol><p>但对于多主机环境，每台都如此则显得重复工作且效率低下，因此有了docker-machine—能在多台主机上批量安装配置docker，主机可以是本地虚拟机、物理机、云主机等，支持环境如下：</p><ol><li>常规 Linux 操作系统</li><li>虚拟化平台 - VirtualBox、VMWare、Hyper-V</li><li>OpenStack</li><li>公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、Digital Ocean 等</li></ol><p>在docker machine中，都称之为Provider，不同Provider对应不同driver来安装配置docker host。</p><a id="more"></a><h1 id="Install-Docker-Machine"><a href="#Install-Docker-Machine" class="headerlink" title="Install Docker Machine"></a>Install Docker Machine</h1><ol><li><p>Install Docker </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure><p>If you would like to use Docker as a non-root user, you should now consider<br>adding your user to the “docker” group with something like:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker &lt;your username&gt;</span><br></pre></td></tr></table></figure><p><strong><a href="https://yq.aliyun.com/articles/29941?spm=5176.100239.blogcont110806.19.d0XnVG" target="_blank" rel="noopener">配置镜像加速器</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"填入你的阿里云专属加速器地址"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Download the Docker Machine binary and extract it to your PATH.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.12.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">sudo cp /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Check the installation by displaying the Machine version:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.12.2, build 9371605</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>Installing bash completion scripts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scripts=( docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash ); <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;scripts[@]&#125;</span>"</span>; <span class="keyword">do</span> sudo wget https://raw.githubusercontent.com/docker/machine/v0.12.2/contrib/completion/bash/<span class="variable">$&#123;i&#125;</span> -P /etc/bash_completion.d; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>To enable the <code>docker-machine</code> shell prompt, add <code>$(__docker_machine_ps1)</code> to your <code>PS1</code>setting in <code>~/.bashrc</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">'[\u@\h \W$(__docker_machine_ps1)]\$ '</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Use-Machine-to-run-Docker-containers"><a href="#Use-Machine-to-run-Docker-containers" class="headerlink" title="Use Machine to run Docker containers"></a>Use Machine to run Docker containers</h1><p>To run a Docker container,you:</p><ul><li>create a new(or start an exiting) Docker virtual machine</li><li>switch your environment to your new VM</li><li>use the docker client to create,load and manage containers</li></ul><h2 id="Machine-drivers—Generic"><a href="#Machine-drivers—Generic" class="headerlink" title="Machine drivers—Generic"></a>Machine drivers—Generic</h2><p>Create machines using an existing VM/Host with SSH.</p><p>This is useful if you are using a provider that Machine does not support directly or if you would like to import an existing host to allow Docker Machine to manage.</p><p>The driver will perform a list of tasks on create:</p><ul><li>If docker is not running on the host, it will be installed automatically.</li><li>It will update the host packages (<code>apt-get update</code>, <code>yum update</code>…).</li><li>It will generate certificates to secure the docker daemon.</li><li>The docker daemon will be restarted, thus all running containers will be stopped.</li><li>The hostname will be changed to fit the machine name.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver generic --generic-ip-address=192.168.56.104 host1</span><br></pre></td></tr></table></figure><h3 id="Sudo-privileges"><a href="#Sudo-privileges" class="headerlink" title="Sudo privileges"></a>Sudo privileges</h3><p>The user that is used to SSH into the host can be specified with <code>--generic-ssh-user</code> flag. This user has to have password-less sudo privileges. If it’s not the case, you need to edit the <code>sudoers</code>file and configure the user as a sudoer with <code>NOPASSWD</code>. See <a href="https://help.ubuntu.com/community/Sudoers" target="_blank" rel="noopener">https://help.ubuntu.com/community/Sudoers</a> .</p><h4 id="ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES"><a href="#ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES" class="headerlink" title="ENVIRONMENT VARIABLES AND DEFAULT VALUES"></a>ENVIRONMENT VARIABLES AND DEFAULT VALUES</h4><table><thead><tr><th>CLI option</th><th>Environment variable</th><th>Default</th></tr></thead><tbody><tr><td><code>--generic-engine-port</code></td><td><code>GENERIC_ENGINE_PORT</code></td><td><code>2376</code></td></tr><tr><td><strong>–generic-ip-address</strong></td><td><code>GENERIC_IP_ADDRESS</code></td><td>-</td></tr><tr><td><code>--generic-ssh-key</code></td><td><code>GENERIC_SSH_KEY</code></td><td>-</td></tr><tr><td><code>--generic-ssh-user</code></td><td><code>GENERIC_SSH_USER</code></td><td><code>root</code></td></tr><tr><td><code>--generic-ssh-port</code></td><td><code>GENERIC_SSH_PORT</code></td><td><code>22</code></td></tr></tbody></table><h2 id="create-过程："><a href="#create-过程：" class="headerlink" title="create 过程："></a>create 过程：</h2><p>① 通过 ssh 登录到远程主机。<br>② 安装 docker。<br>③ 拷贝证书。<br>④ 配置 docker daemon。<br>⑤ 启动 docker。</p><h1 id="Machine-CLI"><a href="#Machine-CLI" class="headerlink" title="Machine CLI"></a>Machine CLI</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line"></span><br><span class="line">  --debug, -DEnable debug mode</span><br><span class="line"></span><br><span class="line">  --storage-path, -s "/home/binlv/.docker/machine"Configures storage path [$MACHINE_STORAGE_PATH]</span><br><span class="line"></span><br><span class="line">  --tls-ca-cert CA to verify remotes against [$MACHINE_TLS_CA_CERT]</span><br><span class="line"></span><br><span class="line">  --tls-ca-key Private key to generate certificates [$MACHINE_TLS_CA_KEY]</span><br><span class="line"></span><br><span class="line">  --tls-client-cert Client cert to use for TLS [$MACHINE_TLS_CLIENT_CERT]</span><br><span class="line"></span><br><span class="line">  --tls-client-key Private key used in client TLS auth [$MACHINE_TLS_CLIENT_KEY]</span><br><span class="line"></span><br><span class="line">  --github-api-token Token to use for requests to the Github API [$MACHINE_GITHUB_API_TOKEN]</span><br><span class="line"></span><br><span class="line">  --native-sshUse the native (Go-based) SSH implementation. [$MACHINE_NATIVE_SSH]</span><br><span class="line"></span><br><span class="line">  --bugsnag-api-token BugSnag API token for crash reporting [$MACHINE_BUGSNAG_API_TOKEN]</span><br><span class="line"></span><br><span class="line">  --help, -hshow help</span><br><span class="line"></span><br><span class="line">  --version, -vprint the version</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">  activePrint which machine is active</span><br><span class="line"></span><br><span class="line">  configPrint the connection config for machine</span><br><span class="line"></span><br><span class="line">  createCreate a machine</span><br><span class="line"></span><br><span class="line">  envDisplay the commands to set up the environment for the Docker client</span><br><span class="line"></span><br><span class="line">  inspectInspect information about a machine</span><br><span class="line"></span><br><span class="line">  ipGet the IP address of a machine</span><br><span class="line"></span><br><span class="line">  killKill a machine</span><br><span class="line"></span><br><span class="line">  lsList machines</span><br><span class="line"></span><br><span class="line">  provisionRe-provision existing machines</span><br><span class="line"></span><br><span class="line">  regenerate-certsRegenerate TLS Certificates for a machine</span><br><span class="line"></span><br><span class="line">  restartRestart a machine</span><br><span class="line"></span><br><span class="line">  rmRemove a machine</span><br><span class="line"></span><br><span class="line">  sshLog into or run a command on a machine with SSH.</span><br><span class="line"></span><br><span class="line">  scpCopy files between machines</span><br><span class="line"></span><br><span class="line">  startStart a machine</span><br><span class="line"></span><br><span class="line">  statusGet the status of a machine</span><br><span class="line"></span><br><span class="line">  stopStop a machine</span><br><span class="line"></span><br><span class="line">  upgradeUpgrade a machine to the latest version of Docker</span><br><span class="line"></span><br><span class="line">  urlGet the URL of a machine</span><br><span class="line"></span><br><span class="line">  versionShow the Docker Machine version or a machine docker version</span><br><span class="line"></span><br><span class="line">  helpShows a list of commands or help for one command</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> docker-machine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker单主机网络管理实践</title>
      <link href="/2017/08/05/20170805-docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
      <url>/2017/08/05/20170805-docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>容器作为应用，必然需要与外界通信，包括容器之间和外部网络。</p><p>Docker网络从覆盖范围分</p><ul><li>单台主机上的容器网络★</li><li>跨多台主机的容器网络</li></ul><a id="more"></a><h1 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h1><p>容器间通信的三种方式：</p><ul><li>IP</li><li>Docker DNS Server</li><li>joined</li></ul><h2 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h2><p>Docker安装时，默认会在主机上创建三个网络，bridge、host、none。可用<code>docker network ls</code>查看</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>就是只有loopback的网络，无其他任何网卡。容器创建时可以用 <code>--network=none</code>来指定容器使用none网络</p><p>适应场景：一些安全性要求较高且不需联网的应用，如生成随机密码的容器，放在none里防止窃取。</p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>类似于虚拟机中共享主机网络的选项，即使容器共享其所在主机的网络栈，该容器的网络配置和主机完全一样。</p><p>适应场景：如容器对网络传输效率较高要求，则可使用host网络。注意考虑端口冲突。</p><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>类似于虚拟机中的桥接模式，可理解为一个软件交换机。默认情况下，不指定<code>--network</code>参数，创建的容器都会挂到一个叫<code>docker0</code>的Linux bridge上。可以使用命令<code>brctl show</code>查看。</p><p>注：首次使用<code>brctl</code>命令，可能会提示安装。<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-network.png" alt="network"></p><h3 id="自定义容器网络"><a href="#自定义容器网络" class="headerlink" title="自定义容器网络"></a>自定义容器网络</h3><p>user-defined网络</p><p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。bridge与前面类似，overlay 和 macvlan 用于创建跨主机的网络。</p><p><code>docker network create --driver bridge my_net</code></p><p>还可指定网段和网关，增加参数<code>--subnet</code>和<code>--gateway</code></p><p><code>docker network create --driver bridge --subnet 172.22.16.0/24 --gatewat 172.22.16.1 my_net2</code></p><p>要使用相关网络驱动即在创建docker容器时，指定<code>--network==xxx</code>其中xxx为驱动名称，当指定为有<code>--subnet</code>参数的驱动时，该容器可以通<code>ip</code>参数指定静态IP地址</p><p><code>docker run it --network=my_net2 --ip 172.22.16.8 busybox</code></p><h3 id="容器间连通"><a href="#容器间连通" class="headerlink" title="容器间连通"></a>容器间连通</h3><p>增加网卡使用<code>docker network connect</code>实现。</p><p>例如：为  CONTAINER ID为2a256932添加my_net2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my_net2 2a256932</span><br></pre></td></tr></table></figure><h4 id="Linux路由转发功能"><a href="#Linux路由转发功能" class="headerlink" title="Linux路由转发功能"></a>Linux路由转发功能</h4><p>Linux默认一般不开启路由转发 ip forwarding，查看/etc/sysctl.cfg中的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>‘1’ 说明启用。</p><p>查看防火墙iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables-save</span><br><span class="line"></span><br><span class="line">-A DOCKER-ISOLATION -i br-5d863e9f78b6 -o docker0 -j DROP</span><br><span class="line">-A DOCKER-ISOLATION -i docker0 -o br-5d863e9f78b6 -j DROP</span><br></pre></td></tr></table></figure><p><strong>iptables DROP 掉了网桥 docker0 与 br-5d863e9f78b6 之间双向的流量</strong>。</p><p>从规则的命名 <code>DOCKER-ISOLATION</code> 可知 docker 在设计上就是要隔离不同的 netwrok。</p><h2 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h2><p>当部署应用之前可能无法确定IP，部署之后再指定要访问的IP会比较麻烦。可通过docker自带的DNS解决问题。</p><p>在docker daemon中实现了一个内嵌的DNS Server ，使容器可以直接通过“容器名”通信。容器名为创建运行容器时指定<code>--name</code>参数确定。</p><p>注：docker dns 只能在user-defined网络中使用。</p><h2 id="joined容器"><a href="#joined容器" class="headerlink" title="joined容器"></a>joined容器</h2><p>joined指多个容器共享网络栈，使容器之间可以通过127.0.0.1直接通信。</p><p>当一个容器需要joined另一个容器，则在创建运行使指定<code>--network=container:容器name</code>即可。</p><p>joined 容器非常适合以下场景：</p><ol><li>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</li><li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li></ol><h1 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h1><p>注意：这里外部网络指的是容器网络以外的网络环境，而非特指Internet</p><p>具体过程已docker0 为例：</p><p>当容器要访问外网时，将数据包封装丢给网关，到达docker0，收到后将其交给MASQUERADE处理（将包源地址替换为主机地址发出去，即做了一次网络地址转换（NAT）），然后就和主机访问外网一样了。</p><h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>在主机通过 <code>iptables -t nat -S</code>可查看到一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>其含义是：如果网桥 <code>docker0</code> 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。</p><h2 id="抓包过程"><a href="#抓包过程" class="headerlink" title="抓包过程"></a>抓包过程</h2><p>使用tcpdump</p><ol><li>查看主机路由表</li><li>抓取相关网卡上数据包</li><li>结果分析</li></ol><p><code>ip r</code>查看默认路由从enp0s3出去，故监控enp0s3和docker0上的icmp数据包。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-ip%20route.jpg" alt></p><h1 id="外部世界访问容器"><a href="#外部世界访问容器" class="headerlink" title="外部世界访问容器"></a>外部世界访问容器</h1><p>docker可将容器对外提供服务的端口映射到主机的某个端口，外网通过该端口访问容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;host ip&gt;:&lt;映射的端口&gt;</span><br></pre></td></tr></table></figure><p>在容器启动时通过-p参数来映射端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80 httpd</span><br></pre></td></tr></table></figure><p>默认情况下容器的端口会随机映射到主机的一个端口。</p><p>可通过<code>docker ps</code>和<code>docker port</code>查看映射的端口情况、</p><p>若要指定映射到主机的某个端口，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 httpd</span><br></pre></td></tr></table></figure><p>意思是将容器的80端口映射到主机的8080端口上<strong>（别搞反了）</strong></p><p>每一个映射的端口，host 都会启动一个 <code>docker-proxy</code> 进程来处理访问容器的流量。</p><p>过程如下：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-docker%20port.jpg" alt></p><ol><li>docker-proxy 监听 host 的 32773 端口。</li><li>当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</li><li>httpd 容器响应请求并返回结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> Docker </tag>
            
            <tag> 网络管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说vSAN</title>
      <link href="/2017/07/29/20170729-VSAN/"/>
      <url>/2017/07/29/20170729-VSAN/</url>
      
        <content type="html"><![CDATA[<h1 id="vSAN"><a href="#vSAN" class="headerlink" title="vSAN"></a>vSAN</h1><p>要说vSAN就不得不提下<strong>超融合</strong>的概念，超融合是一个整体解决方案，是将<strong>计算虚拟化</strong>，<strong>软件定义存储</strong>，<strong>软件定义网络</strong>等解决方案集成到一起的一个整体解决方案。</p><a id="more"></a><p><strong>软件定义分布式存储</strong>是超融合(Hyper-Converged)的核心。引用VMware关于vSAN的一句介绍：</p><blockquote><p>VMware vSAN (formerly Virtual SAN), is the industry-leading software powering Hyper-Converged Infrastructure solutions.</p></blockquote><p>即vSAN是VMware对<a href="https://baike.baidu.com/item/%E8%B6%85%E8%9E%8D%E5%90%88%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">超融合架构</a>的一种解决方案。</p><p>而从功能上说，vSAN是基于<strong>对象</strong>的<strong>分布式策略</strong>存储，这里面的关键词有三个：</p><ul><li>对象</li><li>分布式</li><li>策略</li></ul><p>下面，将以这三个关键词展开对与vSAN的介绍。</p><h1 id="存储对象和组件"><a href="#存储对象和组件" class="headerlink" title="存储对象和组件"></a>存储对象和组件</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象指的是一个独立的存储块设备，大小没限制。vSAN的对象是<strong>带有叶子的RAID树</strong> 。在vSAN存储池Datastore 上虚拟机有五种不同类型的对象，每个虚拟机都是由这些对象的部分组合而成。这些对象是：</p><ul><li>VM Home（虚拟机主页）或“名字空间目录”；</li><li>VM swap （交换文件对象），开机时才会创建；</li><li>VMDK（虚拟磁盘），vSAN 5.5时最大2TB，6.0最大62TB；</li><li>Snapshots（快照），也叫增量盘，建立快照的每个对象都有，每个增量磁盘都是一个对象。</li><li>Memory（vmem，虚拟机内存文件），vSAN5.5时，当快照创建时，虚拟机内存以文件形式存放在VM Home里；而在vSAN 6.0时，虚拟机内存在vSANDatastore里实例化为独立的对象。</li></ul><blockquote><p>注：</p><ul><li>除虚拟机磁盘、增量磁盘（快照）和交换对象外，所有虚拟机文件都驻留在 vSAN 上一个称为虚拟机命名空间的区域中。这里的文件可以是.vmx、.log 文件、.vmdk 和快照增量磁盘描述符文件，以及可能位于虚拟机主目录中的所有其他文件。</li></ul><p>—-<a href="http://vsdsrevolution.blog.51cto.com/8674155/1384474/" target="_blank" rel="noopener">vSAN 第 4 部分 – 了解对象和组件</a></p></blockquote><p>因为由vSAN搭的vSphere虚拟化环境和我们平时玩的VMware Workstation中的虚机略有不同，在vSAN中，虚机是由大量不同的<strong>存储对象</strong>组成的，而非文件。</p><h2 id="组件-含Witness"><a href="#组件-含Witness" class="headerlink" title="组件(含Witness)"></a>组件(含Witness)</h2><p>组件（ Components）是对象的RAID树上的叶子，分布在vSAN集群中的各个主机上。其实，组件是按照两种主要的技术分布的：Striping（条带），即RAID 0；和Mirroring（镜像），即RAID 1。</p><p>注意，RAID的构成和组件的分布取决于最初创建的存储策略。下图是副本为2，条带为2的组件分布情况。每个存储对象都会以 RAID 树的形式部署在vSAN 中，树中的每一片叶子都视为一个组件。</p><p>条带数（也即副本横跨的盘数）</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-VMDKObject.jpeg" alt></p><p>vSAN5.5目前支持每台主机最多包含3000个组件，<strong>vSAN 6.0可达9000个组件</strong>。</p><p>容量大于255GB的对象会自动被分为多个组件。我们知道，vSAN6.0现在支持62TB的VMDK。然而，考虑到vSAN集群支持的最大组件数，需要谨慎衡量应用程序]是否真的需要这么大的VMDK。以单个62TBD VMDK为例，假设副本数为2时，按照255GB拆分，需要消耗约500个组件。</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>需要清楚的是，vSAN不是分布式文件系统，<strong>而是分布式对象存储系统。</strong>所谓分布式就是一个业务拆分成多个子业务，部署在不同服务器上，经常对比的一个概念就是集群，集群是同一个业务，部署在多个服务器上。</p><p>搭建vSAN，至少要三台服务器节点（即ESXi主机），两台主机存放副本，剩下一台存放“见证”（也即Witness，当群集中的虚拟机存储对象出现故障的时候，作为必要的仲裁对象）组件，可允许最多一台主机故障。</p><p>需要注意的是，尽管vSAN完全支持3个主机的配置，但如果可行，<strong>建议至少4个主机</strong>。这是因为，只有3个主机的vSAN集群，在发生故障时，有些情况下，vSAN无法在群集中的其他主机上重新构建（Rebuild）组件（Components）来允许另一次故障。同样，在3个主机配置下，vSAN不能在维护模式（Maintenance Mode）期间从主机迁移所有数据。</p><p>而4个主机的vSAN群集可以提供更高的灵活性。vSAN集群最多时可以支持64个主机。每台为vSAN提供存储资源的主机至少有一个SSD，及一个HDD（每个主机满配5个磁盘组，每个磁盘组为1块SSD+7块HDD，SSD作为缓存层，HDD作为持久化层，也称容量层）。每台主机至少6GB内存。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-vSAN.jpg" alt></p><p>上种属于混合配置，在混合配置中，缓存算法会尝试最大限度提高读写性能。<strong>缓存的70%为读缓存</strong>，用于存储频繁读取的磁盘块，从而最大限度减少对速度缓慢的磁盘的访问。<strong>缓存的30%为写缓存</strong>，用于执行写入操作，每个IO会先写入缓存层，再批量写入持久化层。如果可行，系统会合并多个写操作，并按顺序写入，从而再次最大限度提高磁盘性能。</p><p>并且在混合配置下，<strong>强烈推荐使用支持直通（Pass-Through）模式的磁盘控制器</strong>。方便扩容，只需简单插入新盘即可。</p><blockquote><p>注：</p><ul><li>Pass Through意味着，此控制器支持把磁盘直接呈现给ESXi主机。监控和管理由vSAN来实现</li><li>RAID 0 指每个磁盘必须配置为RAID 0卷，才能让ESXi主机看到它们。</li></ul></blockquote><p>还有一种为全闪存配置，全闪存配置下，vSAN必须使用万兆网口。</p><h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>VMware通过SPBM (Storage Policy Based Management) 来实现SDS自动化。SPBM 是一种通用的存储策略框架，可跨 Virtual SAN 控制并自动执行<strong>以虚拟机为中心的存储策略</strong>，并通过 Virtual Volumes 管理外部存储。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-SPBM.jpg" alt></p><p>目前6.0版本提供的存储策略一共五种。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-capability.jpg" alt></p><h2 id="允许故障数"><a href="#允许故障数" class="headerlink" title="允许故障数"></a>允许故障数</h2><p>即FTT</p><p>为了保证虚拟机持续可访问，组成虚拟机存储对象的组件必须至少有50%可用。所以在保证vSAN可用性的前提下，在故障数为1 的策略时，vSAN环境最少需要3台主机，因为</p><p>3台主机具有2个镜像副本和一个见证，你总是可以具有大于50%的可用组件。</p><p>那么，允许N个故障，vSAN群集要多少台主机？</p><table><thead><tr><th>允许的故障数N</th><th>RAID-1副本数N+1</th><th>vSAN群集中需要的主机数2N+1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>5</td></tr><tr><td>3</td><td>4</td><td>7</td></tr></tbody></table><h2 id="条带宽数"><a href="#条带宽数" class="headerlink" title="条带宽数"></a>条带宽数</h2><p>一般而言，默认条带宽度设置为 1 应能满足大部分虚拟机工作负载的需求。只有在确定写入取消暂存操作或读取缓存未命中的情况影响到了性能时，才应该更改条带宽度。</p><h2 id="闪存读取缓存预留"><a href="#闪存读取缓存预留" class="headerlink" title="闪存读取缓存预留"></a>闪存读取缓存预留</h2><p>该容量是指 SSD 上作为读取缓存保留给存储对象的闪存容量。以1TB 磁盘为例，如果我们将读取缓存预留限定为 1% 的增量，也就意味着缓存预留的增量为 10GB，在大多数情况下，这一增量远远超出了一个虚拟机的需求。</p><h2 id="对象空间预留"><a href="#对象空间预留" class="headerlink" title="对象空间预留"></a>对象空间预留</h2><p>vSAN 上部署的所有对象都采用精简置备。此功能定义了初始化期间可以预留的存储对象逻辑大小百分比。<strong>对象空间预留</strong>表示要预留的空间量,以整个对象地址空间的百分比来表示。</p><h2 id="强制置备"><a href="#强制置备" class="headerlink" title="强制置备"></a>强制置备</h2><p> 如果将此参数设置为非零值，则即使数据存储不满足虚拟机存储策略中指定的策略要求，也会置备对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.vmware.com/products/vSAN.html" target="_blank" rel="noopener">VMware官方关于vSAN产品的介绍</a></li><li><a href="https://baijia.baidu.com/s?old_id=269575" target="_blank" rel="noopener">VMware SDS 之一 :什么是vSAN</a></li><li><a href="http://blog.csdn.net/mooncarp/article/details/51012700" target="_blank" rel="noopener">vSAN的体系架构</a></li><li><a href="http://bbs.vmsky.com/thread-55484-1-1.html" target="_blank" rel="noopener">vSAN与传统存储的比较</a></li><li><a href="http://sanshileilei.blog.51cto.com/3105269/1374604" target="_blank" rel="noopener">VMware vSAN入门与配置</a></li><li><a href="http://vsdsrevolution.blog.51cto.com/8674155/1381072" target="_blank" rel="noopener">VMware R&amp;D 的集成工程团队存储架构师对vSAN的介绍与配置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> vSAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化开发</title>
      <link href="/2017/07/10/20170710-JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2017/07/10/20170710-JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="JS模块化开发"><a href="#JS模块化开发" class="headerlink" title="JS模块化开发"></a>JS模块化开发</h1><a id="more"></a><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul><li>不使用模块化</li><li>模块化开发</li></ul><p>规范：CommonJS、AMD、CMD</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 服务器端模块的规范—Node.js采用该规范</p><p>单独一个文件即一个模块，每个模块都是一个单独的作用域<br>输出模块变量的最好方法是使用 <code>module.exports</code> 对象 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i -= <span class="number">1</span> ; i++ &lt; max ; ) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  max *=1.1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; stat , exists &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>Asynchronous Module Definition，中文名是“异步模块定义”的意思</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>这个。。。对比 AMD</p><h3 id="ES6的module"><a href="#ES6的module" class="headerlink" title="ES6的module"></a>ES6的module</h3><p>ES6模块不是对象，而是通过export命令显式指定输出的代码，在通过import命令输入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat , exists , readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry Pi + openHAB 打造智能安防监控报警系统</title>
      <link href="/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是我毕业设计的项目，从选题到设计完成都是一个人独立完成，当然我参考了网上无数教程代码，最后完成算是达到我的预期，可最后答辩时功能演示出现状况，使老师觉得我做的也不怎么样（可能也是我表达能力差），不管了。反正我觉得特别好，至少我这段时间处理解决各种问题最终完成这个开始自己挖的坑还是非常有成就感。所以为感谢网上各位贡献的教程代码，让我可以顺利完成毕设，我也将自己的成果展示出来，与大家共享。</p><a id="more"></a><p>我打算把这篇文章作为整个设计过程的目录，方便整体把握和学习，希望和大家一起交流。</p><p><strong>特别说明：</strong></p><p>本设计中使用的代码大部分来源网络，参考了我都会注明出处。如果遗漏，可以留言，或原作者介意，也可联系我删除。</p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>咱先看实现的最终效果，如果你觉得喜欢或则有兴趣，可以继续往下读，没兴趣就随意了~</p><p><a href="http://binlv.top/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/" target="_blank" rel="noopener">智能安防监控报警系统效果展示</a></p><h1 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h1><p>这里面包括硬件部分（树莓派以及各传感器）的选择还有软件部分（操作系统、控制语言、开源物联网平台）的选择。</p><p><a href="http://binlv.top/2017/02/11/20170211-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9/" target="_blank" rel="noopener">智能安防监控报警系统—硬件设备选择</a></p><h1 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h1><p>这里包括了树莓派操作系统的安装、配置以及开源平台openHAB的安装等。</p><p><a href="http://binlv.top/2017/04/05/20170405-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">树莓派系统安装配置</a></p><p><a href="http://binlv.top/2017/05/10/20170510-OpenHab%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">openHAB安装配置</a></p><h1 id="传感器部分"><a href="#传感器部分" class="headerlink" title="传感器部分"></a>传感器部分</h1><p>这里包括了我选择的各个传感器怎么去使用、获取数据等。</p><p><a href="http://binlv.top/2017/04/10/20170410-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">树莓派GIPO入门(一)：LED灯</a></p><h1 id="openHAB实践"><a href="#openHAB实践" class="headerlink" title="openHAB实践"></a>openHAB实践</h1><p>openHAB是国外的一个开源物联网平台，我也是误打误撞发现的，之前用的yeelink，感觉界面不太友好还经常有BUG，只能放弃。</p><h1 id="邮件及短信提醒的实现"><a href="#邮件及短信提醒的实现" class="headerlink" title="邮件及短信提醒的实现"></a>邮件及短信提醒的实现</h1><p>这一部分折腾我比较久，因为邮件很容易被当作垃圾邮件发不出去，短信也几经波折。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> openHAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能安防监控报警系统---效果展示</title>
      <link href="/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/"/>
      <url>/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章是我分享的智能安防监控报警系统系列文章的效果展示部分。</p><blockquote><p>目录：<a href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">RaspberryPi+openHAB打造智能安防监控报警系统</a></p></blockquote><a id="more"></a><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><ul><li>温度监测、湿度监测、易燃气体检测等，并将温湿度等参数显示在APP中。</li><li>视频监控并通过客户端APP显示</li><li>控制及报警系统<ul><li>环境指数超过阈值通过邮件、短信等报警提醒</li><li>客户端APP能控制LED、安防功能</li><li>当实验室触发报警时及时将实验室情况给管理人员</li></ul></li></ul><p>下图是我最后连接好各传感器后的实物图</p><p><img src="http://olvboulzy.bkt.clouddn.com/Raspberry_full.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="硬件部分实物展示"></p><p>下面是连线图，用frizing画的，比较丑，将就着看看把。</p><p><img src="http://olvboulzy.bkt.clouddn.com/raspberry_lianxian.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="连线图"></p><p>然后是客户端APP主界面</p><p><img src="http://olvboulzy.bkt.clouddn.com/OpenHab_running.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="主界面"></p><p>可以看到第一组远程控制部分包括LED灯开关控制、安防（也就是红外感应）的控制；然后第二组实验室环境显示，包括温度、湿度，烟雾；第三组是视频监控部分，包括第一个动态和第二个静态；第四组是树莓派设备的运行状况显示，主要是CPU和GPU温度；最后一组是当前系统时间（我用来凑数的，哈哈哈）。</p><p><img src="http://olvboulzy.bkt.clouddn.com/Camera.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="视频监控部分"></p><p><img src="http://olvboulzy.bkt.clouddn.com/temperature.png" alt="系统运行状况"></p><p>报警包括蜂鸣器报警、邮件报警、短信报警</p><p>其中，邮件报警基本使用的是yeelink平台的阈值提醒，就是把数据上传，然后在上面设置触发阈值、邮件地址即可，不过经常不灵。也用openHAB里自带邮件发送，还有自己写的Python版的邮件发送，都不是很理想。短信使用的是阿里大于Python接口，那叫一个方便。</p><p><img src="http://olvboulzy.bkt.clouddn.com/warning.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="报警系统"></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本来我录了个演示视频的。。。后来手贱被我删了，找不到了，我在写这篇文章的时候设备已经上交学校，也演示不了好尴尬额。唉。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> openHAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle备份恢复</title>
      <link href="/2017/05/30/20170530-Oracle%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
      <url>/2017/05/30/20170530-Oracle%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://yq.aliyun.com/articles/45990?spm=5176.100239.blogcont156.11.X4s9k0" target="_blank" rel="noopener">细谈Oracle备份方法</a><br><a href="http://blog.csdn.net/leshami/article/details/5791585" target="_blank" rel="noopener">Oracle备份恢复概念</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p> Oracle数据库有两种运行方式：一是归档方式（ArchiveLog），二是不归档方式（NoArchiveLog）。</p><ul><li><p>归档方式<br>  当数据库发生故障时最大限度恢复数据库，可以保证不丢失任何已提交的数据，即恢复到最后一次commit；</p><p>  可实现冷备和热备；</p><p>  支持完全备份和非完全备份以及完全恢复与非完全恢复；</p><p>  但消耗系统10%性能，同时需要消耗更多存储空间；</p></li><li><p>非归档方式<br>  只能恢复数据库到最近的回收点，即最后一次全备；</p><p>  只支持冷备份（又称为一致性备份）；</p><p>  只能完全备份与完全恢复；</p></li></ul><a id="more"></a><h2 id="备份分类"><a href="#备份分类" class="headerlink" title="备份分类"></a>备份分类</h2><ul><li>物理备份<ul><li>冷备份<br>脱机备份—备份前数据库必须彻底关闭。</li><li>热备份<br>联机备份—只适用于归档方式</li></ul></li><li>逻辑备份<br> 将表、存储过程等数据使用Oracle的export等工具导出到二进制文件，后续根据需要再使用import工具导入数据库。</li></ul><h2 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h2><ul><li>RMAN<br> Recovery Manager。Oracle提供的DBA工具，用于管理备份和恢复操作。</li><li>EXP/IMP<br> 导入/导出方式—转储。如表空间迁移、表的抽取、检测逻辑和物理冲突等，适合小型数据库。</li><li>OS脚本</li></ul><h2 id="数据库实例启动关闭过程"><a href="#数据库实例启动关闭过程" class="headerlink" title="数据库实例启动关闭过程"></a>数据库实例启动关闭过程</h2><h3 id="数据库实例启动过程"><a href="#数据库实例启动过程" class="headerlink" title="数据库实例启动过程"></a>数据库实例启动过程</h3><p>当我们<code>startup</code>数据库时，数据库首先到<code>nomount</code>状态，然后启动到<code>mount</code>状态，再到<code>open</code>状态。</p><ul><li><p>nomount</p><p>实例启动</p><p>​        实例的启动通常包含下列任务：</p><p>​           a.按以下顺序在$ORACLE_HOME/dbs[win平台为database]目录下搜索下列文件,即如果第一个没找到，就找下一个</p><p>​               spfile<sid>.ora —&gt; spfile.ora —&gt; init<sid>.ora</sid></sid></p><p>​           b.分配SGA</p><p>​           c.启动后台进程</p><p>​           d.打开并修改告警<sid>.log文件及跟踪文件</sid></p><p>​       注意：</p><p>​           此阶段不打开任何的控制文件及数据文件。</p></li><li><p>mount</p></li></ul><p>​        mount阶段完成的任务：</p><p>​           a.启动实例并打开控制文件，将数据库与实例关联起来</p><p>​           b.利用参数文件中的说明，打开并锁定控制文件</p><p>​           c.读取控制文件以获取数据文件和重做日志文件的名字和状态信息，但不检查数据日志文件是否存在</p><p>​    注意：</p><p>​               这一步会读控制文件，如果这一步有一个控制文件损坏就无法启动</p><ul><li>open</li></ul><p>​       mount阶段完成的任务：</p><p>​           a.打开数据文件</p><p>​           b.打开联机日志文件</p><p>​     注意：</p><p>​            a.在此期间，Oracle服务器将校验所偶的数据文件和联机日志文件能否打开并对数据库作一致性检查</p><p>​           b.如果出现一致性错误，SMON进程将启动实例恢复</p><p>​           c.如果任一数据文件或联机日志文件丢失，Oracle服务器将报错</p><h3 id="数据库实例关闭"><a href="#数据库实例关闭" class="headerlink" title="数据库实例关闭"></a>数据库实例关闭</h3><p>​    关闭命令：shutdowm abort | immediate | transactional | normal (shutdown不带参数将缺省为normal)</p><p>​    关闭选项：</p><p>​       normal         —&gt;不准许新的连接，等待当前的session 结束，等待当前的事务结束，强制检查点并关闭文件</p><p>​       transactional —&gt;不准许新的连接，不等待当前的session结束，等待当前的事务结束，强制检查点并关闭文件。</p><p>​       immediate      —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，强制检查点并关闭文件。</p><p>​       abort          —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，不作强制检查点。</p><h2 id="数据库恢复过程"><a href="#数据库恢复过程" class="headerlink" title="数据库恢复过程"></a>数据库恢复过程</h2><p>restore  -&gt;  recover   -&gt;  open</p><p>数据文件转储  -&gt;  根据log等将差异弥补  -&gt;  打开数据库</p><p>datafile            control scn    </p><h1 id="备份策略选择"><a href="#备份策略选择" class="headerlink" title="备份策略选择"></a>备份策略选择</h1><h1 id="Oracle实例和Oracle数据库"><a href="#Oracle实例和Oracle数据库" class="headerlink" title="Oracle实例和Oracle数据库"></a>Oracle实例和Oracle数据库</h1><p>一个Oracle Server 由Oracle 实例和Oracle 数据库组成。一台SQL server服务器上可以<strong>存在</strong>多个不同的实例。一个实例下可以存在多个<strong>不同</strong>的数据库。</p><ul><li><p>Oracle实例（Instance）</p><p>内存结构（SGA）+一系列后台进程（Background Process）</p></li><li><p>Oracle数据库（Database）</p><p>控制文件（Controlfile）+  数据文件（datafile）+  联机日志文件（logfile） +  参数文件(pfile、spfile)  +  密码文件等</p><p>​</p></li></ul><p>未完待续。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> RMAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAC学习记录</title>
      <link href="/2017/05/23/20170523-Oracle%2011g%20RAC%20Installation%20Guide/"/>
      <url>/2017/05/23/20170523-Oracle%2011g%20RAC%20Installation%20Guide/</url>
      
        <content type="html"><![CDATA[<h1 id="RAC理论基础"><a href="#RAC理论基础" class="headerlink" title="RAC理论基础"></a>RAC理论基础</h1><p>在RAC术语中，主机通常叫做“节点”。<br>每个主机的硬件配置应该一样：</p><ul><li>每个主机至少需要两块网卡，一个用于集群内部私有通信—Private NIC，另一个网卡用于对外提供服务，如提供用户数据查询—公共网卡（Public NIC）；</li><li>每个主机还要有一个HBA卡，通过光纤连接到存储设备</li><li>除公共和私有IP，每个节点还有VIP（Virtual IP），宕机时使用<br>  共享存储</li><li>多实例，单一数据 架构</li><li>所有节点共享一个数据库</li><li>数据文件、联机日志、参数文件、控制文件必须存放在共享存储上</li><li>保证每个节点都能访问这个存储设备  <a id="more"></a></li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h2><ul><li>操作系统及补丁包<br>要求：OEL 使用 ASMlib、其他Linux使用udev<pre><code>内存：2G以上、SWAP 4G 、硬盘 30G以上</code></pre></li><li>创建所需组、用户和软件home目录<br> oracle - oinstall dba<br>  grid   - asmadmin</li><li>若部署GNS，需提前设置</li><li>设置存储空间</li></ul><h2 id="安装Oracle-Grid-Infrastructure"><a href="#安装Oracle-Grid-Infrastructure" class="headerlink" title="安装Oracle Grid Infrastructure"></a>安装Oracle Grid Infrastructure</h2><ul><li>包括Oracle Clusterware和Oracle ASM<br>11gR2 整合了Clusterware</li></ul><p>ASM安装是个重点<br>如使用OEL系统，自带asmlib但还是要安装asm-support（系统光盘中有）<br>如使用非OEL系统，有两种解决方案：</p><ol><li>安装对应内核的asmlib和asm-support，一般只适合较老版本Linux（Oracle对非自家Linux不提供支持，oracleasm最新支持到oracleasm-2.6.18-238.9.1.el5）</li><li>使用linux自带设备管理器udev，其中又有两种情形：<br>2.1 6.0版本以前的可以用scsi_id -g -u -s</li></ol><p>1.确认在所有RAC节点上已经安装了必要的UDEV包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 ~]# rpm -qa|grep udev</span><br><span class="line">udev-095-14.21.el5</span><br></pre></td></tr></table></figure></p><p>2.通过scsi_id获取设备的块设备的唯一标识名，假设系统上已有LUN sdc-sdp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in c d e f g h i j k l m n o p ;</span><br><span class="line">do</span><br><span class="line">echo "sd$i" "`scsi_id -g -u -s /block/sd$i` ";</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>sdc 1IET_00010001<br>sdd 1IET_00010002<br>sde 1IET_00010003<br>sdf 1IET_00010004<br>sdg 1IET_00010005<br>sdh 1IET_00010006<br>sdi 1IET_00010007<br>sdj 1IET_00010008<br>sdk 1IET_00010009<br>sdl 1IET_0001000a<br>sdm 1IET_0001000b<br>sdn 1IET_0001000c<br>sdo 1IET_0001000d<br>sdp 1IET_0001000e </p><p>以上列出于块设备名对应的唯一标识名</p><p>3.创建必要的UDEV配置文件，</p><p>首先切换到配置文件目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 ~]# cd /etc/udev/rules.d</span><br></pre></td></tr></table></figure></p><p>定义必要的规则配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 rules.d]# touch 99-oracle-asmdevices.rules </span><br><span class="line">[root@rh2 rules.d]# cat 99-oracle-asmdevices.rules</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010001", NAME="ocr1", OWNER="grid", GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010002", NAME="ocr2", OWNER="grid", GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010003", NAME="asm-disk1",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010004", NAME="asm-disk2",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010005", NAME="asm-disk3",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010006", NAME="asm-disk4",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010007", NAME="asm-disk5",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010008", NAME="asm-disk6",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010009", NAME="asm-disk7",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000a", NAME="asm-disk8",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000b", NAME="asm-disk9",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000c", NAME="asm-disk10", OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000d", NAME="asm-disk11", OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br><span class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000e", NAME="asm-disk12", OWNER="grid",  GROUP="asmadmin", MODE="0660"</span><br></pre></td></tr></table></figure></p><p>Result 为/sbin/scsi_id -g -u -s %p的输出–Match the returned string of the last PROGRAM call. This key may be<br>used in any following rule after a PROGRAM call.<br>按顺序填入刚才获取的唯一标识名即可</p><p>OWNER为安装Grid Infrastructure的用户，在11gr2中一般为grid，GROUP为asmadmin<br>MODE采用0660即可</p><p>NAME为UDEV映射后的设备名，<br>建议为OCR和VOTE DISK创建独立的DISKGROUP，为了容易区分将该DISKGROUP专用的设备命名为ocr1..ocrn的形式<br>其余磁盘可以根据其实际用途或磁盘组名来命名</p><ol start="4"><li>将该规则文件拷贝到其他节点上<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 rules.d]# scp 99-oracle-asmdevices.rules Other_node:/etc/udev/rules.d</span><br></pre></td></tr></table></figure></li></ol><p>5.在所有节点上启动udev服务，或者重启服务器即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 rules.d]# /sbin/udevcontrol reload_rules</span><br><span class="line">[root@rh2 rules.d]# /sbin/start_udev</span><br><span class="line">Starting udev:                                            [  OK  ]</span><br></pre></td></tr></table></figure></p><p>6.检查设备是否到位<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@rh2 rules.d]# cd /dev</span><br><span class="line">[root@rh2 dev]# ls -l ocr*</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 32 Jul 10 17:31 ocr1</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 48 Jul 10 17:31 ocr2</span><br><span class="line"></span><br><span class="line">[root@rh2 dev]# ls -l asm-disk*</span><br><span class="line">brw-rw---- 1 grid asmadmin 8,  64 Jul 10 17:31 asm-disk1</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 208 Jul 10 17:31 asm-disk10</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 224 Jul 10 17:31 asm-disk11</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 240 Jul 10 17:31 asm-disk12</span><br><span class="line">brw-rw---- 1 grid asmadmin 8,  80 Jul 10 17:31 asm-disk2</span><br><span class="line">brw-rw---- 1 grid asmadmin 8,  96 Jul 10 17:31 asm-disk3</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 112 Jul 10 17:31 asm-disk4</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 128 Jul 10 17:31 asm-disk5</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 144 Jul 10 17:31 asm-disk6</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 160 Jul 10 17:31 asm-disk7</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 176 Jul 10 17:31 asm-disk8</span><br><span class="line">brw-rw---- 1 grid asmadmin 8, 192 Jul 10 17:31 asm-disk9</span><br></pre></td></tr></table></figure></p><p>  2.2 6.0版本以后的-g失效,需使用</p><p>1.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>首先确认是 Linux 6.0以上版本</span><br><span class="line">[root@vrh6 dev]# cat /etc/issue          </span><br><span class="line">Oracle Linux Server release 6.2</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>添加记录到/etc/scsi_id.config</span><br><span class="line"></span><br><span class="line">echo "options=--whitelisted --replace-whitespace"  &gt;&gt; /etc/scsi_id.config</span><br></pre></td></tr></table></figure></p><ol start="3"><li>​<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>确认哪些块设备需要udev绑定</span><br><span class="line"></span><br><span class="line">[root@vrh6 dev]# ls -l sd*</span><br><span class="line">brw-rw----. 1 root disk 8,  0 Jun 30 09:29 sda</span><br><span class="line">brw-rw----. 1 root disk 8,  1 Jun 30 09:29 sda1</span><br><span class="line">brw-rw----. 1 root disk 8,  2 Jun 30 09:29 sda2</span><br><span class="line">brw-rw----. 1 root disk 8, 16 Jun 30 09:29 sdb</span><br><span class="line">brw-rw----. 1 root disk 8, 32 Jun 30 09:29 sdc</span><br><span class="line">brw-rw----. 1 root disk 8, 48 Jun 30 09:29 sdd</span><br><span class="line">brw-rw----. 1 root disk 8, 64 Jun 30 09:29 sde</span><br><span class="line">brw-rw----. 1 root disk 8, 80 Jun 30 09:29 sdf</span><br></pre></td></tr></table></figure></li></ol><p>例如在本实例中 sdb-&gt; sdf的块设备需要绑定</p><ol start="4"><li>将 b-&gt;f的编号放入for 循环中，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span><br><span class="line">for i in b c d e f ;</span><br><span class="line">do</span><br><span class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ol><p>就会生成sdb-&gt;sdf 设备绑定的RULE，在将这些RULE写入到/etc/udev/rules.d/99-oracle-asmdevices.rules中</p><p>也可以直接利用以下脚本 ，写出RULE到99-oracle-asmdevices.rules<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span><br><span class="line">for i in b c d e f ;</span><br><span class="line">do</span><br><span class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      &gt;&gt; /etc/udev/rules.d/99-oracle-asmdevices.rules</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><ol start="5"><li>之后运行用root运行/sbin/start_udev  即可</li></ol><blockquote><p>注：</p></blockquote><blockquote><p>使用vmware，需要在主机vmx文件中加入： disk.EnableUUID = “TRUE”，否则UUID出不来</p></blockquote><h2 id="安装Oracle-RAC"><a href="#安装Oracle-RAC" class="headerlink" title="安装Oracle RAC"></a>安装Oracle RAC</h2><h1 id="学会使用集群验证实用程序（CVU）"><a href="#学会使用集群验证实用程序（CVU）" class="headerlink" title="学会使用集群验证实用程序（CVU）"></a>学会使用集群验证实用程序（CVU）</h1><p>未完。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> RAC </tag>
            
            <tag> cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openHAB安装配置</title>
      <link href="/2017/05/10/20170510-openHAB%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/05/10/20170510-openHAB%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开源物联网平台，吸引我的是它可实现一次部署，即可同时支持Web、安卓、苹果等控制管理，且界面美观、可定制性强。较国内如yeelink，界面可定制化较弱，且开放性较差，还有待改进。</p><a id="more"></a><h1 id="openHAB简介"><a href="#openHAB简介" class="headerlink" title="openHAB简介"></a>openHAB简介</h1><p>openHAB将不同的家庭自动化系统、设备和技术集成到一个单一的解决方案中。它提供了统一的用户界面，以及在整个系统中实现自动化规则的通用方法，而不考虑涉及的制造商和子系统的数量。</p><p>即openHAB基本无关硬件，可安装在Linux、Windows、Mac OS X、及其他如Raspberry Pi等智能设备上。</p><h1 id="openHAB原理"><a href="#openHAB原理" class="headerlink" title="openHAB原理"></a>openHAB原理</h1><p>安装前首先要懂原理，不然后面出现啥问题会一脸懵逼。</p><p><img src="https://docs.openhab.org/images/distro.png" alt="官方关于OpenHab 原理图"></p><h1 id="openHAB安装"><a href="#openHAB安装" class="headerlink" title="openHAB安装"></a>openHAB安装</h1><p>参考官方教程-<a href="https://docs.openhab.org/installation/rasppi.html" target="_blank" rel="noopener">Raspberry Pi上的安装</a></p><h1 id="openHAB配置"><a href="#openHAB配置" class="headerlink" title="openHAB配置"></a>openHAB配置</h1><p>待续。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openHAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack初步</title>
      <link href="/2017/05/09/20170509-OpenStack%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/05/09/20170509-OpenStack%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="一型虚拟化"><a href="#一型虚拟化" class="headerlink" title="一型虚拟化"></a>一型虚拟化</h2><p>虚拟化平台直接安装在物理机上，如ESXi、Xen</p><h2 id="二型虚拟化"><a href="#二型虚拟化" class="headerlink" title="二型虚拟化"></a>二型虚拟化</h2><p>物理机安装操作系统，操作系统上再安装虚拟化软件，如KVM</p><a id="more"></a><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>KVM有一个内核模块—kvm.ko ，只用于管理<strong>虚拟CPU</strong>和<strong>内存</strong>。</p><p>IO虚拟化，如存储和网络设备虚拟化交给Linux内核和Qemu</p><h4 id="Libvirt"><a href="#Libvirt" class="headerlink" title="Libvirt"></a>Libvirt</h4><p>—KVM管理工具</p><p>包含 </p><p>  1、后台daemon程序libvirtd</p><p>服务程序，接收和处理API请求</p><p>  2、API库</p><p>用于开发基于Libvirt的高级工具，如virt-manager</p><p>  3、命令行工具virsh</p><p>KVM命令行工具</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职业规划与自我认知</title>
      <link href="/2017/05/02/20170502-%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E4%B8%8E%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
      <url>/2017/05/02/20170502-%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E4%B8%8E%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要毕业了，实习了一个多月。。。职业规划还一片空白，房价又那么贵，我该怎么办==。</p><p>这篇文章是我前几天无意间发现了，发现居然是挖坟，贴来自己看看，觉得还是很有启发意义的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>程序人生的四个象限和两条主线</p><a id="more"></a><p>| 作者 陈理捷 发布于 2013年12月18日. 估计阅读时间: 不到一分钟 | 14  讨论</p><p>零</p><p>为什么我们要自己做职业生涯规划？记得《社交网络》里边，CFO同学在知道自己股权被稀释时说了一句话，“我以为那些律师是我的律师。”</p><p>其实我们大多数人对HR几乎都存在类似的误解—— 你以为她是你的HR，其实她只是公司的HR。她们care的是如何编个理由用老板给的那点小钱留住一个高性价比的人才，而不是真正有助于你发展的职业路线图。昨天还含情脉脉和你讨论人生的知心姐姐明天就可能变成拿着劳动合同逼你主动离职的凶婆娘。和人性无关——这就是她们的工作，越专业的HR越擅长。</p><p>所以，你要自己来做这件事情。另外还有一个原因，你该去什么样的公司、做什么样的事情、拿多少钱，都取决于一个问题：你想成为一个什么样的人。工作只是人生的一部分，是用来支撑你人生价值的核心框架之一。在你自己没有想明白的时候，没有人能帮你。这就是为什么猎头基本只谈钱——他们没空去和客户讨论人生的意义。</p><p>一</p><p>我曾花了很长的时间去思考人生的意义，最终发现其实人生本来没有意义，意义都是我们赋予它的。</p><p>在创业做人才服务后，我开始和很多的程序员聊天，开始去了解他们的现状和他们对于自己职业的RoadMap。我发现技术人员的职业生涯形态并不是千变万化的，绝大多数都大同小异，可以用四个象限和两条主线概括清楚。虽然我无法代替你去定义人生的意义，但是我可以和大家分享下各种职业规划下的人生都是什么样子的。当然，这些想法只是我总结出来的东西，未必正确、更不权威大体是一些自以为是的最佳实践。如果你觉得有用，就把它分享给更多的程序员；如果你觉得无趣，就无视掉吧，毕竟我也只能从自己的视角来讨论这个事情。</p><p>二</p><p>写《穷爸爸富爸爸》的那个胖子——罗伯特清崎，从现金流向将人类分到了四个象限，从而总结出来了这么一张图。</p><p><img src alt></p><p>你也许已经看过，但这次我会从程序员的角度来进行解读。</p><p>E象限</p><p>E象限是雇员象限，绝大多数程序员都在这个象限里边。这里是风险最小的地方，只要你准时上下班别一个SQL把公司的数据库Drop掉，基本都能每月领到应得的银子。这里本应该是程序员们的天堂，因为比起改变世界，他们更多的只是很单纯的喜欢写代码。但现实很残酷，北上广的房价高不可攀。你可以不在乎房子，你女朋友能不在乎吗？你女朋友不在乎，她妈能不在乎吗？再考虑到将来小孩上学之类，只要你还打算留下来，房子其实还是必需品。</p><p>在E象限要低风险的搞定房子，只有一个攻略：靠股票和期权。找一家上市公司，或者即将要上市的公司，在里边成为核心员工，再待上几年，就能拿到一定数量的股票或期权。如果运气好，变卖掉这些东西，可以有百万级的收益。前几年这些钱还可以买房子，现在大概只能交首付了。</p><p>S象限</p><p>E象限的整体薪资是有天花板的，很多公司总监的月薪也就3万到5万，扣掉税和每月花销，其实攒不了太多钱。所以有一部分人就选择了S象限——自由职业者和小企业主的领域。S象限的魅力在于你的收益不再完全由你的劳动来获得，你可以开始雇人了。比方说，你可以开一个外包公司，给微博的粉丝服务平台做应用。面向企业的业务一般难在拿到单子，而利润是很高的，一个项目上百万完全不算大，之前有人开玩笑说这些公司一年一个单子就够了、两个单子就赚了。</p><p>在S象限要活得舒服还是有技巧的：如果做外包，一定要有一个不错的客户渠道；依赖于大平台的项目最好能花点钱成为平台的合作伙伴；建站也是Web程序员们做得多的方向，现在可以顺便把移动APP也给做了，很多简单需求用HTML5打个包就能卖几万块钱。</p><p>如果你人脉不好，好吧，程序员人脉好的其实很少，那么就只能用免费+收费模式了。首先把你要做的业务中标准化的部分开发成产品（如CMS）在网络上免费传播，而其中需要定制的部分就可以收费了。开源和免费的Web产品很多，但同质化严重，很少有细分市场的产品，用心定位的话，养活一个小公司绰绰有余的。</p><p>S象限还有一种很悠闲的活法，那就是逃离北上广、回归大自然。去一个风景优美空气清新的二三线城市，雇三五个人（当然就你自己也行）开一个小工作室，给美国人写iOS和Android应用。既没有房价的压力，还能发着人民币挣美金，貌似成都高新区还免税。</p><p>B象限</p><p>按罗伯特他亲戚的定义，B象限本来是大企业主的，那种员工超过500人的。不过在互联网领域这个定义不靠谱，我更乐意把它看成是上市公司和为了上市的创业公司的象限。</p><p>同样是开公司，B象限的玩法和S象限不同，它是以规模化为前提的。天使、种子、VC、上市和出售是这个象限的关键词。</p><p>很少有技术人员适合独立创业，不是说你能力不够，而是很多东西你都没接触过，需要补很多课。之前创业成本比较高，现在有了微博和微信这些开放平台、有了App Store和Google Play这些开放市场，技术人员创业也开始有了一点的优势：自己做个小产品，不停的快速失败，直到成功。说得更直白一点就是你找业余时间开发一个商业应用，放到市场上去卖试试，让客户骂试试。等你经过了共享软件的洗礼，你基本上就知道做生意是怎么一回事了。</p><p>上帝其实挺公平的，他还为程序员们准备了另外一条低风险的捷径——上市公司或者快要上市公司的CTO。在这里要和大家强调一点，同样是CTO职位，初创团队的CTO和相对成熟公司的CTO差别是非常大的。</p><p>A轮（不一定精确，但大致如此）以前的公司，主要在寻找商业模式，会频繁的变更需求，对开发速度要求更高，这时候CTO只要能敏捷的开发产品就OK；A轮以后的公司，着力于规模化，会有大量的推广，可能在某些时间点遭遇高并发，同时技术人员、设备会迅速增加，这时候CTO需要考虑业务的高可用、还要能处理好团队、资源的管理工作。如果原来的CTO没有大型互联网公司的背景，往往很难做好这些事情，所以一般会考虑从大公司去挖一个。</p><p>如果你的规划足够好，是可以从小公司到大公司再即将上市的公司，加薪升职迎娶白富美出任CTO成为人生赢家的，这个等下我们还会具体讨论。</p><p>I象限</p><p>这个土豪和高富帅的象限我还没有待过，所以不多讲。大体是钱多得没处花的人通过投资来保证资产增值的地方。所谓的财务自由（就是一直不干活，钱也够你花），就是通过进入这个象限来实现的。投资未必都是技术活，直接银行存个定期也算是投资，如果你钱够多的话，也能财务自由。对了，投行的投资经理是E象限的，他们其实是雇员。</p><p>三</p><p>当你在上边四个象限里选好了想要的人生区间后，就要设计一个可行的RoadMap来实现它。但既然你都读到这里了，大概既没有一个I象限的亲爹、也没有一个I象限的干爹，所以唯一可以推动你前进的，只能是自身的成长。</p><p>技术人员的成长路径主要就分两条，技术线和管理线。总体来讲，选技术线的同学要选好技术方向；而选管理线的同学要把握好节奏。</p><p>技术线</p><p>这里的技术线是纯技术路线，是专家方向，做到最后title应该是首席科学家、首席架构师或者首席技术顾问之类。如果你对某个方向的技术非常感兴趣，又不喜欢做项目、团队管理工作，那么技术线就是不错的选择。</p><p>选技术线的同学一定要选对技术方向，因为你会在自己选择的这个细分市场里投入三年、五年、甚至十年的时间。</p><p>和大家讲讲我自己的经历。我是2002年开始学习PHP的，当时ASP非常流行，而我只是一个计算机系的学生，并不具备对行业趋势的判断能力，只是因为ASP太受欢迎，以至于图书馆的书都被借完了，我只好借了一本放在旁边的PHP。</p><p>于是在大学时我用PHP写了很多开源项目：留言板、相册、CMS；靠这些东西得到了一家建站公司的兼职工作，除了把学费挣回来以外，还轻松进入新浪实习。到新浪刚过了几个月，受雅虎影响，新浪也全面转向了PHP——而我正好是我们组最懂PHP的。你可以想象接下来我是多么如鱼得水，我和我的小伙伴们用PHP写完一个人才项目后，又用PHP重写了PV近亿的手机新浪网发布系统，一切都风调雨顺有惊无险，以至于后来去另一家公司面试时，面试官问我经历过最失败的项目时，我完全答不出来。</p><p>十年时间过去了，PHP依然如日中天，用我十年前学习的PHP技能，依然可以在一流互联网公司找到一份不错的工作，而ASP——现在谁还知道ASP是什么？</p><p>好了，我无意来仇恨，其实我只是想说同样是一门语言，它的投入产出比是非常不同的。选择技术方向时一定要谨慎。</p><p>那么，怎么选择技术方向呢？我给两个建议。</p><p>学会观察技术潮流</p><p>有一本老外写的书里边讲，如果你要知道什么语言流行，就去看看技术Guru们都在用什么。这话固然不错，但知其然不知其所以然并不是件好事。</p><p>从根源上讲，一个技术是否流行，和人们使用技术的方式密切相关。PHP能大规模流行，并不是因为它的语法好看，而是因为人们使用技术的方式从单机转向了网络，而PHP正好是所有语言里边最专注于Web的。苹果手机大规模流行后，Objective-C 的使用量开始极速上升。在很多程序员眼里OC的语法完全是异端，但这丝毫没有影响他们用异端语言大把挣钱。</p><p>仔细观察下周围，现在人类（是的，普通人类而不是其他程序员）是怎么使用技术的？很多人晚上回家已经不开电脑了，他们用电视盒看电视，用平板玩游戏，用手机吐槽。而这些设备很多都是Android系统，那么你觉得Android程序员会便宜吗？由于有了多个设备，个人的数据需要在多个设备之间进行同步、分散到各处的数据也需要统一管理，所以云计算尤其是云存储的需求会凸现出来。</p><p>知道了多屏合一以及APP流行的背景，你还会觉得现在投入PHP会是一个好选择吗？我们来分析下。PHP最大的优势在于它的胶水特性——简单快速的把HTML和业务数据粘在一起然后显示出来。如果只有浏览器，那么PHP还可以通过响应式设计的方式来兼容移动设备。但是当我们有了手机APP的时候，服务器就必然需要API了。换句话说，多屏合一其实是要求数据和显示分离的——这不是PHP最擅长的，单纯写API接口的话，无论是NodeJS还是Go都更具优势。当然，作为PHP的铁杆粉丝，我要说明，PHP也有很多强化API性能的项目，比如Yar，O+。这些东西让PHP在全平台时代获得了新的竞争资本，具体的大家可以去看看鸟哥在今年InfoQ大会上的PPT。</p><p>投资新兴市场和细分市场</p><p>这是第二个建议。如果把选择一门技术当做一个投资的话，新兴市场和细分市场是特别值得留意的。</p><p>新兴市场对程序员来说，就是一种新的语言、一个新的平台、一套新的框架。新兴市场因为刚刚兴起，所以几乎所有人都在同一个起跑线，特别适合后进者。我认识从一个2011年开始学习iOS开发的同学，他能力中等，但现在已经算是很资深的iOS工程师了，月薪超过2万；而如果他那时选择去学习PHP，那他现在只能算个初级程序员。</p><p>并非只有一个平台的兴起才有机会，很多框架技术也会带来机会。比如说Cocos2d Javascript版。以前开发游戏需要学习OC或者Java，而Cocos2d Javascript版本的出现，让你可以用纯JS同时开发一套运行在浏览器、iOS和Android平台上的游戏——不用改一行代码，由于是把JS解析后直接扔给OpenGL运行，在手机上性能也很不错。这对JS工程师来讲，就是一个全新的、可以进入游戏行业的机会。</p><p>如果你只能进入一个成熟市场，那么记得给自己确立一个细分的定位。前几天国内知名的漏洞报告平台乌云招聘PHP开发工程师，职位薪资不是很高，但是我觉得是一个很不错的机会。乌云平台每天被攻击一百多次， 在乌云工作几个月以后，你就能写出来可能是国内最安全的PHP代码，如果再适时的分享下你在乌云工作的经验教训，一个专注于安全的PHP专家就跃然纸上了。这就是细分市场，比你懂安全的没你懂PHP、比你懂PHP的没你懂安全。</p><p>技术线属于那些赖得住寂寞，还得了房贷，喜欢风险最低化的同学。在自身技术实力不错，专攻的技术方向还未衰落的情况下，踏踏实实熬个五到十年，还是可以有车有房的。如果中间遇到公司上市、出售，那么时间可能更短。</p><p>管理线</p><p>用玩游戏来打比方的话，技术线比较单一，在同一个地方不停的打怪就好了；而管理线则有相对复杂的剧情。技术管理虽然有技术两个字，但更多的是和人相关的管理工作，所以在这条线上，职业逻辑也更不正常（在HR看来可能是更正常）一些——title和资历很重要。</p><p>一个只在小公司上过班的PHP程序员，不管他能力有多好，是不可能直接成为一家500人规模还有半年就上市的企业的CTO的。即使CEO非常相信你的能力，他也需要拿出让投资人和团队其他人信服的证据，很显然一个大型互联网公司的技术总监职位更容易服众。所以别去相信那些没开过公司没当过高管或者就是别有居心的人说的，title很重要，它标记了你做过什么样的事、有怎么样的成绩。虽然它只能证明你的过去，但我们其实都是从别人的过去去判读一个人的将来的。</p><p>不想当CTO的程序员不是好项目经理，所以庸俗的讲，管理线其实就是一个不断升级自己的title，直到CTO的游戏，它有点像某些排序算法的动画。当然，随着title越来越高，管理的人和资源就越多，对沟通能力、管理能力的要求也越高。</p><p>在稍微扁平一点的互联网公司，职位分布大概是这样的：工程师 - 技术主管/技术经理/项目经理 -总监 - CTO。和技术线不同，管理线每一次升级除了能力，还需要机遇的。因为越是高级的管理职位就越少，如果你遇到一位年富力强又对公司衷心耿耿的直接上级，那这条线基本就被堵住了。</p><p>好在我们生活的这个年代换公司比换衣裳还容易，所以我们可以通过跳槽来调节。除了可以跳到相同水平但是发展更好的公司外，也可以去稍微低一级的公司，这样你的title（还有薪资）就可以先调上来，等这家公司发展起来，你的价值就增加了。</p><p>跳槽的时间间隔要把握好，一般两到三年为宜；不要太频繁，否则会让人对你的稳定性产生怀疑。每一次跳槽要设定好自己想要得到的空间、资源、薪资和title。对去创业公司的同学多说一句，虽然我不想承认，但的确99%的创业公司都会失败的，不过公司的失败未必是你的失败，你只要确保在每一家公司都能得到成长，就可以踩着河里的竹竿逆流而上。</p><p>写到这里连我自己都觉得有些势利了，但大部分公司和员工本身就是赤裸裸的利用关系，你不替自己打算是没人帮你的，老实也未必能有好结果。当年有个和我一起入职的同学，因为是应届，所以月薪只有3k，她一直勤勤恳恳的工作了四年，期望能靠自己的努力得到认可，但最后薪水也只有7k，远低于行业平均水平。后来终于想开了，跳槽去了竞争对手那边，直接13k+。公司的人才政策很多时候取决于高管，即使你的直接主管想帮你，也未必能帮上忙。比如之前，我们部门一个技术的同学结婚后经济压力上来了，想找份报酬更高的工作，我们好说歹说愿意留下，但想调调薪资，但公司死活不乐意，宁愿花着同样的钱去新招一个……</p><p>嗯，吐槽就到这里吧，总之，用多家公司作为自己职业生涯的调节杠杆，就像用并行进程处理高并发一样，是非常有意义的。你未必要真的跳来跳去，但多个选择总不是坏事。</p><p>至于要怎么去选择公司，尤其是小公司，你只需要注意两件事：公司的业务方向靠谱不？公司的老板对员工好不好？前者关系到公司能不能挣钱，后者关系到公司挣的钱有不有你的份。</p><p>四</p><p>就写到这里吧，虽然不全面，但如果能在某些点上引发你的思考，那就不枉我打这么多字了。如果你有什么要和我讨论，或者有什么要和大家分享，可以发邮件到 <a href="mailto:easychen@gmail.com" target="_blank" rel="noopener">easychen@gmail.com</a> ，我会找时间整理出来的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡说八道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派GIPO入门(一)：LED灯</title>
      <link href="/2017/04/10/20170410-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E5%85%A5%E9%97%A8/"/>
      <url>/2017/04/10/20170410-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="所需硬件"><a href="#所需硬件" class="headerlink" title="所需硬件"></a>所需硬件</h1><ul><li>树莓派3代B型（40 GIPO引脚）</li><li>杜邦线（公对母）</li><li>面包板</li><li>发光二极管(LED小灯)</li></ul><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><a id="more"></a><h2 id="什么是GIPO"><a href="#什么是GIPO" class="headerlink" title="什么是GIPO"></a>什么是GIPO</h2><p>GPIO是General Purpose Input Output （通用输入/输出）的缩写，一般译为总线扩展器，人们利用工业标准I2C、SMBus或SPI接口简化了I/O口的扩展。当微控制器或芯片组没有足够的I/O端口，或当系统需要采用远端串行通信或控制时，GPIO产品能够提供额外的控制和监视功能。<br>目前你只需要知道GIPO可以提供电流让你的元器件通电。它的各引脚信息如下：<br><img src="http://upload-images.jianshu.io/upload_images/4377539-4d20cd9d7c61da6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GIPO编号图"></p><h2 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h2><p>一排为相连<br><a href="http://www.i-element.org/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%8C%85%E6%9D%BF/" target="_blank" rel="noopener">如何使用面包板</a><br><a href="http://www.guokr.com/post/718305/" target="_blank" rel="noopener">果壳网-如何使用面包板</a><br><img src="https://cdn.sparkfun.com/r/600-600/assets/3/d/f/a/9/518c0b34ce395fea62000002.jpg" alt="面包板内部图"></p><h2 id="发光二极管"><a href="#发光二极管" class="headerlink" title="发光二极管"></a>发光二极管</h2><p>长的一脚为正极，短的一脚为负极</p><p>呼吸灯代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> RPi.GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">RPi.GPIO.setmode(RPi.GPIO.BCM)</span><br><span class="line">RPi.GPIO.setup(<span class="number">14</span>, RPi.GPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 PWM 实例，需要两个参数，第一个是GPIO端口号，这里我们用14号</span></span><br><span class="line"><span class="comment"># 第二个是频率（Hz），频率越高LED看上去越不会闪烁，相应对CPU要求就越高，设置合适的值就可以</span></span><br><span class="line">pwm = RPi.GPIO.PWM(<span class="number">14</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用 PWM，参数是占空比（可以理解为电流大小），范围：0.0 &lt;= 占空比 &gt;= 100.0</span></span><br><span class="line">pwm.start(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># 电流从小到大，LED由暗到亮</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">1</span>):</span><br><span class="line"><span class="comment"># 更改占空比（电流大小），</span></span><br><span class="line">pwm.ChangeDutyCycle(i)</span><br><span class="line">time.sleep(<span class="number">.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再让电流从大到小，LED由亮变暗</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">pwm.ChangeDutyCycle(i)</span><br><span class="line">time.sleep(<span class="number">.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一段是一个小技巧。这个程序如果不强制停止会不停地执行下去。</span></span><br><span class="line"><span class="comment"># 而Ctrl+C强制终端程序的话，GPIO口又没有机会清理。</span></span><br><span class="line"><span class="comment"># 加上一个try except 可以捕捉到Ctrl+C强制中断的动作，</span></span><br><span class="line"><span class="comment"># 试图强制中断时，程序不会马上停止而是会先跳到这里来做一些你想做完的事情，比如清理GPIO口。</span></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用 PWM</span></span><br><span class="line">pwm.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理GPIO口</span></span><br><span class="line">RPi.GPIO.cleanup()</span><br></pre></td></tr></table></figure><p>#</p><h2 id="脉宽调制（PWM）"><a href="#脉宽调制（PWM）" class="headerlink" title="脉宽调制（PWM）"></a>脉宽调制（PWM）</h2><p>简单的说，PWM技术就是不停的通断电路并控制通断持续的时间片段长度来控制用电器在单位时间内实际得到的电能。<br>这么说好像还是复杂了，再简单点说，如果你的手足够快，打开电灯开关后马上关闭，如果这个时间间隔足够短，灯丝还没有全部亮起来就暗下去了。你再次打开电灯再关闭，再打开再关闭。。。如果你一直保持相同的频率，那么电灯应该会保持一个固定的亮度不变。理论上，你可以通过调整开灯持续的时间长度和关灯持续的时间长度的比例就能得到不同亮度了。这个比例被称为“占空比”。</p><p>跑马灯效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RPi.GPIO <span class="keyword">as</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">GPIO.setmode(GPIO.BOARD)</span><br><span class="line"> </span><br><span class="line">channels = [<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>] </span><br><span class="line">p = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> channels:</span><br><span class="line">  GPIO.setup(ch, GPIO.OUT)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">  p[i] = GPIO.PWM(channels[i], <span class="number">50</span>) <span class="comment">#频率设为50Hz</span></span><br><span class="line">  p[i].start(<span class="number">0</span>) <span class="comment">#0是占空比</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      <span class="keyword">for</span> dc <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>, <span class="number">1</span>):</span><br><span class="line">        p[ch].ChangeDutyCycle(dc) <span class="comment">#更改占空比</span></span><br><span class="line">        time.sleep(<span class="number">0.005</span>)</span><br><span class="line">      <span class="keyword">for</span> dc <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        p[ch].ChangeDutyCycle(dc)</span><br><span class="line">        time.sleep(<span class="number">0.005</span>)</span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    gpio.cleanup()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"All Cleanup!"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> GIPO </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等级保护和分级保护</title>
      <link href="/2017/04/08/20170408-%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4/"/>
      <url>/2017/04/08/20170408-%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>信息安全领域是目前很多政府、企业十分注重的一个领域，而其中等级保护和分级保护又是这个领域经常要遇到的概念，它们是国家衡量一个单位的安全是否可靠的标准。</p><a id="more"></a><blockquote><p>信息安全技术信息系统安全等级保护基本要求 <a href="http://www.360doc.com/document/12/1121/14/6037405_249298826.shtml" target="_blank" rel="noopener">GB/T 22239-2008</a></p></blockquote><h1 id="等级保护"><a href="#等级保护" class="headerlink" title="等级保护"></a>等级保护</h1><h2 id="为什么做等级保护"><a href="#为什么做等级保护" class="headerlink" title="为什么做等级保护"></a>为什么做等级保护</h2><p>保护企业形象、维护信息安全、帮助企业整改</p><h2 id="什么是等级保护"><a href="#什么是等级保护" class="headerlink" title="什么是等级保护"></a>什么是等级保护</h2><p>非涉密系统的安全防护标准，由<strong>公安系统</strong>负责检查监督。</p><h2 id="等级"><a href="#等级" class="headerlink" title="等级"></a>等级</h2><p>一共五级，五级最高</p><ul><li><p>一级<br>简单说是自己玩，无需测评，由用户自己决定该如何保护数据。</p></li><li><p>二级<br>可无测评，具有访问审计能力 — 能创建、维护受保护对象的<strong>访问审计跟踪记录</strong>，记录与系统安全相关事件发生的日期、时间、用户和事件类型等信息，<strong>所有和安全相关的操作都能够被记录下来</strong>，以便当系统发生安全问题时，可以根据审计记录，分析追查事故责任人，使所有的用户对自己行为的合法性负责。</p></li><li><p>三级<br>市级以上，必须测评。除具有第二级系统审计保护级的所有功能外，还它要求对访问者和访问对象实施<strong>强制访问控制</strong>，并能够进行记录，以便事后的监督、审计</p></li><li><p>四级</p><p><strong>结构化</strong>，将安全保护机制划分为关键部分和非关键部分，对关键部分强制性地直接控制访问者对访问对象的存取，使之具有相当的抗渗透能力。本级的安全保护机制能够使信息系统实施一种系统化的安全保护。</p></li><li><p>五级</p><p>访问验证保护级这一个级别除了具备前四级的所有功能外还特别增设了<strong>访问验证功能</strong>，负责仲裁访问者对访问对象的所有访问活动，仲裁访问者能否访问某些对象从而对访问对象实行专控，保护信息不能被非授权获取。</p></li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>三分建设、七分管理。</p><p>按系统分 ：</p><ul><li><p>技术要求</p><ul><li>物理安全</li><li>网络安全</li><li>主机安全</li><li>应用安全</li><li>数据安全</li></ul></li><li><p>管理要求</p><ul><li><p>安全管理制度</p></li><li><p>安全管理机构</p></li><li><p>人员管理</p></li><li><p>系统建设管理</p></li><li><p>运维的管理</p></li></ul></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>对用户来说</li></ul><ol><li>划清责任。★</li><li>保证一定的安全基线，整体安全防护效果不降低。</li><li>保护用户投资。</li><li>根据被保护目标的安全需求，指导用户进行安全建设。</li></ol><h2 id="测评流程"><a href="#测评流程" class="headerlink" title="测评流程"></a>测评流程</h2><p>定级/备案 –&gt; 招标 –&gt; 配合测评机构整理资料</p><h2 id="测评项权重"><a href="#测评项权重" class="headerlink" title="测评项权重"></a>测评项权重</h2><p>风险评估–基本符合</p><h1 id="分级保护"><a href="#分级保护" class="headerlink" title="分级保护"></a>分级保护</h1><h2 id="什么是分级保护"><a href="#什么是分级保护" class="headerlink" title="什么是分级保护"></a>什么是分级保护</h2><p>涉密系统的安全防护标准，由<strong>保密局</strong>检查监督。</p><h2 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h2><ul><li>秘密（对应等级保护三级）</li><li>机密（对应等级保护四级）</li><li>绝密（对应等级保护五级）</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.chinacybersafety.com/201703218766.html" target="_blank" rel="noopener">如何理解信息安全等级保护与分级保护</a> </p><p><a href="http://zhaoshilei.blog.51cto.com/6455149/1896681" target="_blank" rel="noopener">CSDN-等级保护和分级保护</a></p><p><a href="http://www.itsec.gov.cn/webportal/download/chenxiaohua.pdf" target="_blank" rel="noopener">信息安全等级保护与分级认证 - 中国信息安全测评中心</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 等级保护 </tag>
            
            <tag> 分级保护 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派系统安装配置</title>
      <link href="/2017/04/05/20170405-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
      <url>/2017/04/05/20170405-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是智能安防监控报警系统的<strong>树莓派系统安装配置</strong>部分。</p><blockquote><p>目录：<a href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">RaspberryPi+openHAB打造智能安防监控报警系统</a></p></blockquote><h1 id="镜像选择"><a href="#镜像选择" class="headerlink" title="镜像选择"></a>镜像选择</h1><p>树莓派可选操作系统种类多样，包括官方最新支持的RASPBIAN JESSIE WITH PIXEL、Debian系列Ubuntu MATE和Ubuntn CORE以及Windows 10 IOT CORE等，考虑到兼容性需求，笔者选择的的是由官方指定的RASPBIAN JESSIE WITH PIXEL，其对树莓派支持最好。</p><a id="more"></a><p>首先到<a href="https://www.raspberrypi.org/" target="_blank" rel="noopener">官方网站</a>打开下载页后，选择Raspbian –“RASPBIAN JESSIE WITH PIXEL”下载最新版ZIP包。将zip文件解压缩后会得到一个.img镜像文件，此文件即为树莓派安装镜像。</p><p>自此，镜像准备就绪。</p><h1 id="镜像烧写"><a href="#镜像烧写" class="headerlink" title="镜像烧写"></a>镜像烧写</h1><p>树莓派开发板与其他开发板不同，没有配置内置FLASH，但它支持 可自行扩展的SD卡启动，所以我们需要将下载的相应镜像先烧写在对应的SD卡上，插入对应插槽即可启动系统。笔者选用的SD卡为SanDisk 64G Class4 高速卡，使用Win32DiskImager将下载好的镜像写入SD卡然后插上加电就行。</p><p>这个网上教程有，不想赘述。</p><p><a href="https://www.raspberrypi.org/learning/hardware-guide/" target="_blank" rel="noopener">官方安装教程</a></p><h1 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h1><p>安装好系统后首先要能连接登录树莓派，对于Linux系统来说，首选必然是通过SSH，SSH已经足够使用了。SSH指的就是Secure Shell，这是Linux系统的一个功能可以直接从主机电脑上快速打开一个树莓派的终端会话。树莓派最新系统(20170405)默认是不开启ssh服务的，<strong>官方给的解决办法是在刚安装好系统的SD卡目录中新建一个ssh.text文件，开机时即可开启ssh服务，实现登录操作</strong>。</p><p>另外，为方便无屏开发者，树莓派最新官方系统还自带VNC-server，VNC（Virtual Network Connection）是一种可视化网络连接的标准，通过VNC就可以很方便远程访问和操作树莓派的图形界面。</p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>由于树莓派新装操作系统，网络无任何配置，但开机网卡自启，可将树莓派用网线连接到带DHCP地址分配功能的家用路由器的LAN口，可自动获取到IP地址，然后电脑同样连接该路由器，通过管理界面查看树莓派获取到的IP地址，而后通过VNC View或ssh登录到树莓派即可对树莓派进行网络配置。笔者电脑环境为Windows 8.1 x64版本，选择通过xshell的提供ssh服务登录树莓派配置网络。</p><p>现如三代树莓派自带无线网卡模块与蓝牙功能，为达到便携性，笔者毫不犹豫选择了主用无线网络进行通信。登录系统后，在终端输入nano /etc/network/interfaces进入编辑界面即可编辑无线网卡连接配置，配置代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">  ssid="WiFi-name1"</span><br><span class="line">  psk="password1"</span><br><span class="line">  priority=1</span><br><span class="line">&#125;</span><br><span class="line">network=&#123;</span><br><span class="line">  ssid="WiFi-name2"</span><br><span class="line">  psk="password2"</span><br><span class="line">  priority=5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>树莓派内置一个名为<strong>“Raspi-Config”</strong>的配置工具，类似于PC的BIOS设置，用于调节系统各参数配置。</p><p>首先需最大化SD卡空间，因为默认树莓派只使用操作系统需要的部分空间，需开启剩余所有空间，防止后来环境安装配置导致存储空间不足。</p><p>而后，开启I2C接口、piCamera接口都是通过Raspi-Config直接勾选即可。但I2C需要使用还需安装相关工具集I2C-tools。</p><p>本文完。</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vSphere入门</title>
      <link href="/2017/03/23/20170323-vSphere%E5%85%A5%E9%97%A8/"/>
      <url>/2017/03/23/20170323-vSphere%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考官方文档 <a href="http://pubs.vmware.com/vsphere-51/index.jsp#com.vmware.vsphere.vcenterhost.doc/GUID-302A4F73-CA2D-49DC-8727-81052727A763.html" target="_blank" rel="noopener">vSphere 5.1</a>、 <a href="http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.vsphere.install.doc/GUID-78933728-7F02-43AF-ABD8-0BDCE10418A6.html" target="_blank" rel="noopener">vSphere 6.0</a>、<a href="http://pubs.vmware.com/vsphere-65/index.jsp#com.vmware.vsphere.install.doc/GUID-78933728-7F02-43AF-ABD8-0BDCE10418A6.html" target="_blank" rel="noopener">vSphere 6.5</a></p></blockquote><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>vSphere是VMware旗下产品，主要是虚拟化技术，可将数据中心转换为简化的云计算基础架构，使IT组织能够提供灵活可靠的IT服务。</p><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><ul><li><p>计算机服务器<br>  裸机上运行ESXi的x86服务器，ESXi软件为虚拟机提供资源，并运行虚拟机。</p><blockquote><p><strong>注</strong>：x86是采用复杂指令架构处理器的计算机（如Intel、AMD），特点是程序各条指令顺序执行，控制简单，但利用率低；</p></blockquote><blockquote><p>相比采用精简指令架构处理器的PowerPC（如苹果电脑），只要求硬件执行有限且常用的那部分指令，大部分复杂的操作则使用传输的编译技术，主要用于中高档服务器。</p></blockquote></li><li>存储网络和阵列<br>  用于实现存储资源整合，主要技术有：光纤通道SAN阵列、iSCSI SAN阵列和NAS阵列等 </li><li>IP网络<br>  每台计算机服务器可有多个物理网络适配器，为整个数据中心提供高带宽和可靠网络连接</li><li>vCenter Server<br>  vCenter Server 为数据中心提供一个单一控制点。它提供基本的数据中心服务，如访问控制、性能监控和配置功能。它将各台计算服务器中的资源统一在一起，使这些资源在整个数据中心中的虚拟机之间共享。其原理是：根据系统管理员设置的策略，管理虚拟机到计算服务器的分配，以及资源到给定计算服务器内虚拟机的分配。<br>  在 vCenter Server 无法访问（例如，网络断开）的情况下（这种情况极少出现），计算服务器仍能继续工作。服务器可单独管理，并根据上次设置的资源分配继续运行分配给它们的虚拟机。在 vCenter Server 的连接恢复后，它就能重新管理整个数据中心。</li><li><p>管理客户端<br>  VMware vSphere 为数据中心管理和虚拟机访问提供多种界面。这些界面包括 VMware vSphere Client (vSphere Client)、vSphere Web Client（用于通过 Web 浏览器访问）或 vSphere Command-Line Interface (vSphere CLI)。</p><p><img src="http://pubs.vmware.com/vsphere-51/topic/com.vmware.vsphere.vcenterhost.doc/GUID-35CAADED-7217-4186-80B4-DC9E5B3DBCFB-high.png" alt="物理拓扑"></p></li></ul><p>从 vSphere 6.0 开始，运行的 vCenter Server 和 vCenter Server 组件的所有必备服务都在 VMware Platform Services Controller 中进行捆绑。可以部署具有嵌入式或外部 Platform Services Controller 的 vCenter Server，但是必须始终先安装或部署 Platform Services Controller，然后再安装或部署 vCenter Server。</p><h2 id="ESXi主机最高配置（vSphere-6-0）"><a href="#ESXi主机最高配置（vSphere-6-0）" class="headerlink" title="ESXi主机最高配置（vSphere 6.0）"></a>ESXi主机最高配置（vSphere 6.0）</h2><p>参考：<a href="https://docs.vmware.com/cn/VMware-vSphere/6.0/com.vmware.vsphere.configmax.doc/GUID-962CDBD6-577D-4B3A-B50E-E6BF9A0B3CB8.html" target="_blank" rel="noopener">VMware vSphere最高配置</a></p><ul><li><p>计算最高配置</p><p>| 项目            | 最大值  |<br>| :———— | :–: |<br>| 每个主机的逻辑 CPU   | 480  |<br>| 每个主机的 NUMA 节点 |  16  |</p></li><li><p>内存最高配置</p><p>| 项目      | 最大值  |<br>| ——- | :–: |<br>| 每个主机的内存 | 6 TB |</p></li><li><p>存储最高配置</p><p>| 虚拟磁盘      | 最大值  |<br>| ——— | :–: |<br>| 每个主机的虚拟磁盘 | 2048 |</p></li><li><p>网络最高配置</p><p>| 项目                              |                   最大值                    |<br>| ——————————- | :————————————–: |<br>| 物理网卡                            |                                          |<br>| e1000e 1 GB 以太网端口 (Intel PCI-e) |                    24                    |<br>| igb 1 GB 以太网端口 (Intel)          |                    16                    |<br>| tg3 1 GB 以太网端口 (Broadcom)       | 16（已启用 NetQueue）32（已禁用 NetQueue）vSphere 6.0 中默认已启用 NetQueue。 |</p></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>安装ESXi</li></ol><ul><li>交互式安装</li><li>脚本安装或升级</li><li>使用vSphere Auto Deploy安装</li></ul><hr><p><strong>重要</strong><br>在vSphere 6.0 中，Auto Deploy是与vCenter Server一同安装的。</p><hr><ol start="2"><li><p>配置ESXi引导和网络设置、直接控制台和其他设置。</p></li><li><p>（可选）设置用于远程日志记录的syslog服务器</p></li><li><p>在Windows虚拟机或物理服务器上安装vCenter Server，或部署Center Server Appliance。</p></li><li><p>从vSphere Web Client连接到vCenter Server，并配置相关参数。</p></li></ol><h2 id="安全证书"><a href="#安全证书" class="headerlink" title="安全证书"></a>安全证书</h2><p>ESXi主机和vCenter Server通过SSL安全地进行通信</p><h1 id="Virtual-SAN"><a href="#Virtual-SAN" class="headerlink" title="Virtual SAN"></a>Virtual SAN</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>使用软件定义的方法为虚拟机创建共享存储。<br>可配置vSAN以将其用作混合集群或全闪存群集。</p><ul><li>混合群集中，闪存设备用于缓存层，磁盘用于存储容量层</li><li>全闪存群集中，闪存设备同时用作缓存和容量设备。<h2 id="相关术语和定义"><a href="#相关术语和定义" class="headerlink" title="相关术语和定义"></a>相关术语和定义</h2><strong>磁盘组</strong><br>为vSAN群集提供性能和容量的主机和物理设备组上的物理存储容量单元。<br>每个磁盘组必须具有一个闪存缓存设备和一或多个容量设备。<br>用于缓存的设备不能在磁盘组之间共享或其他目的。<br><strong>所用容量</strong><br>指一个或多个虚拟机随时使用的物理容量。<br><strong>基于对象的存储</strong><br>vSAN以对象（数据和元数据分布于群集的逻辑卷，如一个VMDK、每个快照都是对象）形式存储并管理数据。<br><strong>对象和组件</strong><br>每个对象由一组组件组成，由虚拟机存储策略中正在使用的功能决定。<br>例如，允许的故障数策略配置为 1 时，Virtual SAN 确保将保护组件（如对象的副本和见证）放置在 Virtual SAN 群集中不同的主机上，其中每个副本即是一个对象组件。此外，在相同策略中，如果每个对象的磁盘带数配置为 2 个或更多，Virtual SAN 还可以跨多个容量设备条带化对象，每个条带视为指定对象的一个组件。必要时，Virtual SAN 可以将大对象分成多个组件。<br>Virtual SAN 数据存储包含以下对象类型：</li><li>虚拟机主页命名空间<br>所有虚拟机配置文件均存储在虚拟机主目录中，例如 .vmx、日志文件、vmdk、快照增量描述文件等。</li><li>VMDK<br>虚拟机磁盘或 .vmdk 文件，用于存储虚拟机硬盘驱动器内容。</li><li>虚拟机交换对象<br>打开虚拟机电源时创建。</li><li>快照增量 VMDK<br>生成虚拟机快照时创建。</li><li>内存对象<br>创建或挂起虚拟机时，选择快照内存选项时创建。</li><li>虚拟机合规性状态：“合规”和“不合规”<br>虚拟机中一个或多个对象未满足分配的存储策略要求时，虚拟机被视为不合规。例如，其中一个镜像副本无法访问时，状态可能会变得不合规。如果虚拟机与存储策略中定义的要求相符，虚拟机的状态则为合规。在虚拟磁盘页面的物理磁盘放置位置选项卡中，可确定虚拟机对象的合规性状态。</li><li><p>组件状态：“已降级”和“不存在”状态<br><strong>已降级</strong><br>永久组件故障<br><strong>不存在</strong><br>临时组件故障</p></li><li><p>对象状态：“正常”和“不正常”<br><strong>正常</strong><br>全镜像和超过50%的对象组件可用<br><strong>不正常</strong><br>镜像副本不可以或少于50%对象组件可用<br><strong>证明</strong><br>仅包含元数据的组件<br><strong>基于存储策略的管理(SPBM)</strong></p></li></ul><p><strong>Ruby v Sphere 控制台(RVC)</strong></p><p><strong>vSAN Observer</strong></p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算技术初步</title>
      <link href="/2017/03/22/20170322-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/03/22/20170322-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>云计算说白了就是将硬件资源整合再在软件层面重新进行分配，一般是三大资源—计算资源、网络资源、存储资源。<br><a id="more"></a></p><h2 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h2><ul><li>资源整合运营者</li><li>资源使用者</li><li>终端客户<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2></li><li>资源池弹性可扩张</li><li>按需提供资源服务</li><li>虚拟化</li><li>网络化资源接入</li><li>高可靠和安全性<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按资源封装层次分"><a href="#按资源封装层次分" class="headerlink" title="按资源封装层次分"></a>按资源封装层次分</h3></li><li>基础设施即服务（Infrastructure as a Service，IaaS）<br> 如：Amazon EC2、IBM Blue Cloud、Sun Grid<br>   主要是虚拟化技术</li><li>平台即服务（Platform as a Service，PaaS）<br> 如：IBM IT Factory、Google APPEngine、Force.com    </li><li>软件即服务（Software as a Service，SaaS）<br> 如：Google APPS、SoftWare+Services</li></ul><h4 id="四层模型："><a href="#四层模型：" class="headerlink" title="四层模型："></a>四层模型：</h4><p>   应  用  层 — SaaS<br>   平  台  层 — PaaS<br>  基础设施层 — IaaS<br>   虚拟化层 — 硬件即服务</p><h3 id="按技术路线分："><a href="#按技术路线分：" class="headerlink" title="按技术路线分："></a>按技术路线分：</h3><ul><li>资源整合技术<br> 大都集群架构，将分散的计算和存储资源整合输出<br> 核心：分布式计算、存储<br> 应用：MPI(并行计算技术)、Hadoop(Apache的分布式计算系统)、HPCC(高性能计算集群)、Storm(基于拓扑的的流数据实时计算平台)</li><li>资源切分技术<br> 虚拟化系统，对单个服务器资源的弹性切分，从而有效利用服务器资源<br> 主要：桌面云<br> 应用：KVM、VMware<h2 id="云计算技术主要内容"><a href="#云计算技术主要内容" class="headerlink" title="云计算技术主要内容"></a>云计算技术主要内容</h2></li><li>分布式计算技术</li><li>虚拟化技术</li><li>网络技术</li><li>服务器技术</li><li>数据中心技术</li><li>云计算平台技术</li><li><p>存储技术</p><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><p>现代计算机系统分为几个层次（自下而上）：</p><p>裸机（底层硬件）– 操作系统 — 操作系统提供应用程序编程接口 — 运行在操作系统上各种应用程序</p><p>虚拟化就是要在不同层次间建立虚拟化层，向上提供与真实层次相同或相近功能<br>要明确 对象、过程、结果</p></li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><ul><li>指令集架构级虚拟化<br> Bochs、VLIW</li><li>硬件抽象层虚拟化<br> VMWare、Virtual PC、Xen、KVM</li><li>操作系统层虚拟化<br> Virtual Sever、Zone、Virtuozzo</li><li>编程语言层虚拟化<br> JVM、CLR</li><li>库函数虚拟化<br> Wine<h3 id="系统虚拟化"><a href="#系统虚拟化" class="headerlink" title="系统虚拟化"></a>系统虚拟化</h3>就是在一台计算机系统上虚拟多台计算机系统<h4 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h4>将系统虚拟化应用到服务器上<br>所需技术：CPU、内存、IO虚拟化<h4 id="桌面虚拟化"><a href="#桌面虚拟化" class="headerlink" title="桌面虚拟化"></a>桌面虚拟化</h4>使桌面与其使用的终端设备相分离<br>主要技术：VDI、SBC<h4 id="网络虚拟化"><a href="#网络虚拟化" class="headerlink" title="网络虚拟化"></a>网络虚拟化</h4>虚拟专用网、虚拟局域网<h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3>就是一组独立的计算机（节点）的集合体，除了作为单一计算资源供用户使用外还可以协同工作，供并行任务使用</li><li>并行计算集群Beowulf</li><li>集群文件系统HDFS、GFS、Lustre<h1 id="数据中心能耗"><a href="#数据中心能耗" class="headerlink" title="数据中心能耗"></a>数据中心能耗</h1>数据中心是管理和维护的中心，能耗是衡量一个数据中心管理维护是否合理的重要的标准。常用的有PUE、DCIE、能耗比等。<h2 id="PUE"><a href="#PUE" class="headerlink" title="PUE"></a>PUE</h2>Power Usage Effectiveness<br>PUE = 数据中心整体能耗/IT设备能耗<br>最理想的值是1，Google全年平均1.12，百度M1云计算中心1.35<br>例如：<br>  数据中心A有100个机柜，每个机柜5台2U/18刀的刀片服务器，运行总功率500kW，IT设备功率250kW，则该数据中心PUE=500/250=2；<br>  数据中心B有200个机柜，每个机柜有6台机架式2U/4刀的机架式服务器，运行功率700kW，IT设备功率300kW，该数据中心PUE=700/300=2.33；<br>  总结：A好。<h2 id="DCIE"><a href="#DCIE" class="headerlink" title="DCIE"></a>DCIE</h2>Data Center Infrastructure Effectiveness<br>DCIE = IT设备能耗/数据中心整体能耗/IT设备能耗<br>其实就是PUE倒数<h2 id="能耗比"><a href="#能耗比" class="headerlink" title="能耗比"></a>能耗比</h2>IT设备能耗比 = IT设备每秒数据处理流量/IT设备能耗</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于目标具象化</title>
      <link href="/2017/02/28/20170228-%E5%85%B3%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%85%B7%E8%B1%A1%E5%8C%96/"/>
      <url>/2017/02/28/20170228-%E5%85%B3%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%85%B7%E8%B1%A1%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>给迷茫的自己。</p><p>去年决定考研。忙着复习，几个月没有更博。</p><p>最近成绩出来了，估摸着没机会复试了，思考再三，不能上理想学校那还是出去报复社会吧。迈入社会的第一步，当然是写简历。回想大学四年，活生生成了一个万金油。。。感觉自己会网络、会敲代码、写过数据库增删改查。。。但女怕嫁错郎，男怕入错行，真到要选择一种职业，还真有些茫然。</p><p>偶然看到阿奶的一篇文章，方法论很是受用。</p><a id="more"></a><h2 id="程度"><a href="#程度" class="headerlink" title="程度"></a>程度</h2><p>问自己几个问题：</p><ul><li>想过什么样的生活</li><li>拥有多高的收入</li><li>希望什么时候达到/达到目标需要几年</li><li>要进入什么行业</li><li>做什么样的工作</li><li>是否要创业</li><li>什么时候创业 </li></ul><p>心中对这些问题都应该有自己的答案。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>目标是什么：想做的每一件事</p></li><li><p>去了解商业及社会情况，对它们能有一般的认识</p><p>如有几大基本职能、实际商业社会它们都是做什么产品、属于什么行业、公司构成以及职能的设计。</p></li><li><p>做简历</p><p>学会包装，不说假大空，要有实际事例支撑。</p></li><li><p>找实习试水</p></li><li><p>不断努力达到目标</p></li></ol><h2 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h2><p><strong>安全工程师</strong></p><ul><li>熟悉常见攻击方法</li><li>懂至少一种脚本语言</li><li>懂Web渗透测试</li><li>相关证书：CISP、CISSP</li></ul><p><strong>Android开发工程师</strong></p><ul><li>熟练掌握数据结构、算法</li><li>Java/Android编程、项目经验</li><li>多线程并发、通信机制</li><li>Android框架原理、基本组件</li></ul><p><strong>系统运维工程师</strong></p><ul><li>熟悉Linux、计算机网络等</li><li>Linux下C/C++、golang或python、shell等脚本语言</li><li>前端知识储备、JavaScript及其常用框架</li><li>Web服务、nginx、squid、lighttpd</li><li>awk、grep、strace、tcpdump网络诊断、定位、网络异常等</li><li>github用户==。</li></ul><p><strong>DBA</strong></p><ul><li>数据库相关设计及优化。。。</li></ul><p><strong>Web工程师</strong>(全栈方向)</p><ul><li>HTML、CSS、JS</li><li>各种框架</li><li>Node.js</li></ul><p>这个其实是我比较向往的(全栈)，无论哪一块出了问题可自己动手解决，或至少有大体思路。</p><h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><p>就我个人而言，大学这四年，前两年基本以学生会活动为主，从大一只是参加到大二开始自己组织活动，带人，所学到的大多为非专业技能。然后大三开始反思前两年的学习状况，极度膨胀，发现自己只是伪大神开始接触专业技能。Linux、网络安全、C++、Python、SQL、Oracle等，很杂很杂，但全都停留在皮毛，甚至皮毛都不算。拿了几个可有可无的奖，开始兴奋，觉得自己前途无量，后来被老师一句这种比赛简直小打小闹而无地自容，对自我认知较差。这也导致我后来考研抱着侥幸冲北大，考下来发现一年看似努力，实际分数就是个笑话呵。</p><p>总之现在还在投简历，几年时光所学我已经尽可能完美的呈现在上面，不过自己现在还没明确的职业规划，我很担忧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能安防监控报警系统---硬件设备选择</title>
      <link href="/2017/02/11/20170211-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9/"/>
      <url>/2017/02/11/20170211-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是智能安防监控报警系统的设备选择部分。</p><blockquote><p>目录：<a href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">RaspberryPi+OpenHab打造智能安防监控报警系统</a></p></blockquote><h1 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h1><p>总花费 ￥500以内。</p><a id="more"></a><h2 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h2><p>必须最新的，目前为三代B型，带wifi和蓝牙。我买的套餐，国产，含32G的SanDisk内存卡，包装盒真的是惊艳到我了。</p><p><img src="http://olvboulzy.bkt.clouddn.com/RPI3.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="树莓派包装盒"></p><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><ul><li><p>烟雾传感器</p><p>MQ-2，输出模拟信号，需要模数转换器</p></li><li><p>温湿度传感器</p><p>DHT11，数字型。</p></li><li><p>蜂鸣器</p><p>有源蜂鸣器</p><p>参考资料：<a href="http://blog.csdn.net/sdtvyyb_007/article/details/50708913" target="_blank" rel="noopener">Python与硬件学习笔记：蜂鸣器</a></p></li><li><p>人体红外传感器</p><p>HC-SR501</p></li><li><p>摄像头</p><p>RPI-Camera，500万像素吧。</p><p><img src="https://gd3.alicdn.com/imgextra/i3/1754311986/TB2fqTIn80kpuFjSsppXXcGTXXa_!!1754311986.jpg" alt></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>模数转换器</p><p>由于烟雾传感器MQ-2输出模拟信号，需借助模数转换器，选型为：PCF8591模块</p></li><li><p>面包板</p><p>不想焊接电路，自己还不太懂，而且感觉费事，先用面包板方便插拔实验</p></li><li><p>杜邦线</p><p>有面包板当然得有杜邦线连接。暂需公对母、母对母两种</p></li><li><p>LED二极管</p><p>传说开发板入门从使二极管发光开始，这个还是需要的，至于要不要电阻，反正我是没用上。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次Java面试经历</title>
      <link href="/2016/06/30/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20160630-%E4%B8%80%E6%AC%A1Java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
      <url>/2016/06/30/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20160630-%E4%B8%80%E6%AC%A1Java%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>看到一篇文章说过</p><blockquote><p>公司和员工之间的关系大概就是嫖客和妓女间的关系。</p><p>想要获得更多的嫖资？提高硬件，提高技术。</p><p>所谓：嫖客无情，婊子无义。</p></blockquote><p>恩。</p><h2 id="开头说"><a href="#开头说" class="headerlink" title="开头说"></a>开头说</h2><p>昨天去了面试一家公司的Java软件开发，发现自己真的是菜的可以。。。一共两个环节，去了先笔试然后面试，面试内容会根据笔试情况来定，像我笔试做的差，面试基本不会涉及技术问题，大部分在聊岗前培训。</p><p>个人感觉待遇略坑，也说明自己水平确实很差，去面试前准备也不够充分。</p><a id="more"></a><p>现在我把笔试的题列出来就当是学习吧。</p><p>一共分为五个部分：单选、多选、判断、简答、算法</p><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><p>1．Java是从（ ）语言改进重新设计。<br>  A．Ada B．C++ C．Pasacal D．BASIC                         <strong>答案：B</strong>     </p><p>2．下列语句哪一个正确（ ）<br>  A． Java程序经编译后会产生machine code<br>  B． Java程序经编译后会产生byte code<br>  C． Java程序经编译后会产生DLL<br>  D． 以上都不正确                                            <strong>答案：B</strong>     </p><p>3．下列说法正确的有（ ）<br>  A． class中的constructor不可省略<br>  B． constructor必须与class同名，但方法不能与class同名<br>  C． constructor在一个对象被new时执行<br>  D． 一个class只能定义一个constructor<br>                                                          <strong>答案：C</strong>     </p><p>4．提供Java存取数据库能力的包是（ ）<br>  A．java.sql B．java.awt C．java.lang D．java.swing                 <strong>答案：A</strong>     </p><p>5．下列运算符合法的是（ ）<br>A．&amp;&amp; B．&lt;&gt; C．if D．:=                                      <strong>答案：A</strong>     </p><p>6．执行如下程序代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span>;c=<span class="number">0</span>;   <span class="keyword">do</span>&#123; </span><br><span class="line">  --c;   a=a-<span class="number">1</span>; </span><br><span class="line">  &#125;<span class="keyword">while</span>(a&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>  后，C的值是（ ）<br>  A．0    B．1    C．-1    D．死循环                          <strong>答案：C</strong>     </p><p>7．下列哪一种叙述是正确的（ ）<br>  A． abstract修饰符可修饰字段、方法和类<br>  B． 抽象方法的body部分必须用一对大括号{ }包住<br>  C． 声明抽象方法，大括号可有可无<br>  D． 声明抽象方法不可写出大括号                              <strong>答案：D</strong>     </p><p>8．下列语句正确的是（ ）<br>  A． 形式参数可被视为local variable<br>  B． 形式参数可被字段修饰符修饰<br>  C． 形式参数为方法被调用时，真正被传递的参数<br>  D． 形式参数不可以是对象                                      <strong>答案：A</strong>     </p><p>9．下列哪种说法是正确的（ ）<br>  A． 实例方法可直接调用超类的实例方法<br>  B． 实例方法可直接调用超类的类方法<br>  C． 实例方法可直接调用其他类的实例方法<br>  D． 实例方法可直接调用本类的类方法                          <strong>答案：D</strong>     </p><h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><p>  1．Java程序的种类有（ ）<br>  A．类（Class） B．Applet C．Application D．Servlet       <strong>答案：BCD</strong> </p><p>2．下列说法正确的有（ ）<br>  A． 环境变量可在编译source code时指定<br>  B． 在编译程序时，所能指定的环境变量不包括class path<br>  C． javac一次可同时编译数个Java源文件<br>  D． javac.exe能指定编译结果要置于哪个目录（directory）         <strong>答案：BCD</strong>     </p><p>3．下列标识符不合法的有（ ）<br>  A．new B．$Usdollars C．1234 D．car.taxi                  <strong>答案：ACD</strong>     </p><p>4．下列说法错误的有（ ）<br>  A． 数组是一种对象<br>  B． 数组属于一种原生类<br>  C． int number=[]={31,23,33,43,35,63}<br>  D． 数组的大小可以任意改变                                  <strong>答案：BCD</strong>     </p><p>5．不能用来修饰interface的有（ ）<br>  A．private B．public C．protected D．static              <strong>答案：ACD</strong>     </p><p>6．下列正确的有（ ）<br>  A． call by value不会改变实际参数的数值<br>  B． call by reference能改变实际参数的参考地址<br>  C． call by reference不能改变实际参数的参考地址<br>  D． call by reference能改变实际参数的内容                  <strong>答案：ACD</strong>     </p><p>7．下列说法错误的有（ ）<br>  A． 在类方法中可用this来调用本类的类方法<br>  B． 在类方法中调用本类的类方法时可直接调用<br>  C． 在类方法中只能调用本类中的类方法<br>  D． 在类方法中绝对不能调用实例方法                          <strong>答案：ACD</strong>     </p><p>8．下列说法错误的有（ ）<br>  A． Java面向对象语言容许单独的过程与函数存在<br>  B． Java面向对象语言容许单独的方法存在<br>  C． Java语言中的方法属于类中的成员（member）<br>  D． Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同  <strong>答案：ABC</strong>     </p><p>9．下列说法错误的有（ ）<br>  A． 能被java.exe成功运行的java class文件必须有main()方法<br>  B． J2SDK就是Java API<br>  C． Appletviewer.exe可利用jar选项运行.jar文件<br>  D． 能被Appletviewer成功运行的java class文件必须有main()方法  <strong>答案：BCD</strong></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>1．Unicode是用16位来表示一个字的。（ ）                          <strong>答案：正确</strong>     </p><p>2．原生类中的数据类型均可任意转换。（ ）                          <strong>答案：错误</strong></p><h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><p>1、在java中如果声明一个类为final，表示什么意思？ </p><p><em>答：final是最终的意思，final可用于定义变量、方法和类但含义不同，声明为final的类不能被继承。</em></p><p>2、父类的构造方法是否可以被子类覆盖（重写），说明重载与重写的区别？ </p><p><em>答：父类的构造方法不可以被子类覆盖，因为父类和子类的类名是不可能一样的。</em></p><p>3、如果有两个类A、B（注意不是接口），你想同时使用这两个类的功能，那么你会如何编写这个C类呢？ </p><p><em>答：因为类A、B不是接口，所以是不可以直接继承的，但可以将A、B类定义成父子类，那么C类就能实现A、B类的功能了。假如A为B的父类，B为C的父类，此时C就能实现A、B的功能。</em></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol><li>抽奖算法：制定一二三四等奖概率P1、P2、P3、P4，要求实现输出概率统计也是P1、P2、P3、P4。</li><li>关于HTTP请求返回URL类型…具体记不得了</li></ol><h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>其实这家公司的题大部分都是借用华为Java面试题，百度一下就有。最后两个算法可能是和公司实际项目相关联。</p><p>嗯，我水平太差，做不出来，以后如果有能力我会回来改的。。。</p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面筋 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门开发(五)---系统认识Android</title>
      <link href="/2016/04/04/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160404-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%BA%94)-%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%86Android/"/>
      <url>/2016/04/04/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160404-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%BA%94)-%E7%B3%BB%E7%BB%9F%E8%AE%A4%E8%AF%86Android/</url>
      
        <content type="html"><![CDATA[<p>补了好多Java基础知识，终于可以开始碰Android，我主要参考郭霖的<a href="http://www.ituring.com.cn/book/1841" target="_blank" rel="noopener">《第二行代码》</a>来写的读书笔记。毕竟他的<a href="http://www.ituring.com.cn/book/1473" target="_blank" rel="noopener">《第一行代码》</a>被热推，不过由于Android更新太快，里面很多东西都过时，刚好作者十分勤奋，2016年底推出《第二行代码》，迅速学起来。</p><ul><li>工具 <a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio 中文站</a> </li></ul><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><ol><li>Linux内核层<br>为各种硬件提供底层驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、WiFi驱动、电源管理等；</li><li>系统运行库层<br>特性支持，如SQLite(嵌入式关系型数据库)库提供数据库支持，OpenGL|ES库提供3D绘图支持，Webkit库提供浏览器内核支持<br>核心库，可用Java编写Android应用<br>Dalvik/ART虚拟机</li><li>应用框架层<br>应用程序可用API</li><li><p>应用层<br>应用程序就是这层…</p><p><img src="http://images.cnitblog.com/blog/473657/201301/18203746-970e2cbe223e4c1c9ca129e7a2feb6c6.jpg" alt="Android的系统架构"></p></li></ol><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><ol><li>活动（Activity）<br>应用程序门面，看得到的东西</li><li>服务（Service）<br>后台运行</li><li>广播接收器（Broadcast Receiver）<br>顾名思义</li><li>内容提供器（Content Provider）<br>程序共享数据</li></ol><h1 id="Android项目结构"><a href="#Android项目结构" class="headerlink" title="Android项目结构"></a>Android项目结构</h1><p><strong>Project模式</strong></p><ol><li>.gradle和.idea<br>存放Android Studio自动生成文件</li><li>app<br>项目代码、资源</li><li>build<br>编译自动生成文件</li><li>gradle<br>包含gradle wrapper配置文件</li><li>gitgnore<br>用于版本控制</li><li>build.gradle<br>全局gradle构建脚本</li><li>gradle.properties<br>gradle配置文件，影响gradle编译脚本</li><li>gradlew和gradlew.bat<br>用于命令行执行gradle命令</li><li>HellWorld.iml<br>IntelliJ IDEA项目(Android Studio基于该项目开放)自动生成</li><li>local.properties<br>本机Android SDK路径</li><li>setting.gradle<br>用于指定项目中所有引入模块</li></ol><p><strong>app目录详解</strong></p><ol><li>build<br>编译自动生成</li><li>libs<br>第三方jar包存放处</li><li>androidTest<br>自动化测试用</li><li>java<br>放置所以Java代码</li><li>res<br>项目使用到的资源（如图片、布局、字符串等）都存放在这</li><li>AndroidManifest.xml<br>配置文件，程序定义四大组件需要在这注册，还可以添加程序声明</li><li>test<br>Unit Test测试用例</li><li>.gitignore<br>版本控制</li><li>app.iml<br>自动生成</li><li>build.gradle<br>app模块的gradle构建脚本</li><li>proguard-rules.pro<br>指定项目代码混淆规则，防止破解</li></ol><p><strong>res目录详解</strong></p><ul><li>所有drawable开头的文件夹都是存放图片的</li><li>所有mipmap开头的文件夹都是存放应用图标的（为更好兼容各种设备，mipmap开头文件夹会有很多）</li><li>所有values开头的文件夹都是存放字符串、样式、颜色等配置</li><li>layout文件夹存放布局文件</li></ul><h1 id="日志工具使用"><a href="#日志工具使用" class="headerlink" title="日志工具使用"></a>日志工具使用</h1><p>日志工具对开发提供极大帮助，Android的日志工具类是Log（android.util.Log）,提供5个方法来打印日志：</p><ul><li>Log.v()<br> 打印意义最小的日志信息—verbose</li><li>Log.d()<br> 打印调试信息—debug</li><li>Log.i()<br> 打印比较重要数据，可帮助分析用户行为—info</li><li>Log.w()<br> 打印警告，可能有潜在风险—warn</li><li>Log.e()<br> 打印错误—error</li></ul><p><strong>过滤器</strong><br>Google分析工具—Firebase<br> 当程序打印出成百上千行日志的时候会迫切需要过滤器。</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门开发(四)-Java类集框架</title>
      <link href="/2016/04/01/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160401-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E5%9B%9B)-Java%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/04/01/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160401-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E5%9B%9B)-Java%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>这节略难，很多不太理解，先记下来。<br><a id="more"></a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>一组类和接口</li><li>位于java.util包当中</li><li>主要用户存储和管理对象</li><li>主要分为三大类：集合、列表和映射</li><li>集合set<pre><code>集合中的对象**不按特定的方式排序**，并且**没有重复对象**</code></pre><ul><li>列表list<br>集合中对象按照索引位置<strong>排序</strong>，可以<strong>有重复对象</strong></li><li>映射map<br>集合中每个元素包含一个键对象和一个值对象，键不可重复，但键值可以—键值对</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表的用法</span></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();<span class="comment">//数组长度可扩展</span></span><br><span class="line"><span class="comment">//ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">// arrayList中存放数据类型为String --- 泛型机制</span></span><br><span class="line">arrayList.add(<span class="string">"a"</span>);</span><br><span class="line">arrayList.add(<span class="string">"b"</span>);</span><br><span class="line">arrayList.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = arrayList.size();<span class="comment">//取其长度</span></span><br><span class="line">String s = arrayList.get(<span class="number">1</span>);<span class="comment">//取出第一个数据</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">String s = arrayList.get(<span class="number">1</span>);<span class="comment">//下标越界异常</span></span><br><span class="line">arrayList.remove(<span class="number">1</span>);<span class="comment">//删除1号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>类集框架分为三个层次，最顶层的是Collection接口和Iterator接口，第二层是Set接口和它的实现类HashSet</p><table><thead><tr><th style="text-align:center">接口方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">boolean add(Object o)</td><td style="text-align:center">向集合中加入一个对象</td></tr><tr><td style="text-align:center">void clear()</td><td style="text-align:center">删除集合当中的所有对象</td></tr><tr><td style="text-align:center">boolean isEmpty()</td><td style="text-align:center">判断集合是否为空</td></tr><tr><td style="text-align:center">remove(Object o)</td><td style="text-align:center">从集合中删除一个对象的引用</td></tr><tr><td style="text-align:center">int size()</td><td style="text-align:center">返回集合中元素的数目</td></tr></tbody></table><ul><li>Set和HashSet使用方法<br>Set和HashSet继承了Collection接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//Set&lt;String&gt; set = hashSet; //向上转型</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"a"</span>); <span class="comment">//添加元素</span></span><br><span class="line">set.add(<span class="string">"b"</span>);</span><br><span class="line">set.add(<span class="string">"c"</span>);</span><br><span class="line">set.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = set.size(); <span class="comment">//统计长度，如有重复元素会忽略</span></span><br><span class="line">System.out.println(<span class="string">"clear之前set对象的长度是："</span>+ i );</span><br><span class="line">set.clear();</span><br><span class="line"><span class="keyword">int</span> j = set.size(); <span class="comment">//clear后长度变成0</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Iterator迭代器</li></ul><h1 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h1><ul><li><p>put()方法</p></li><li><p>get()方法</p></li></ul><h1 id="equals函数"><a href="#equals函数" class="headerlink" title="equals函数"></a>equals函数</h1><p>包含在object类下，object类是所有类的父类，故所有类都继承equals方法。</p><p><strong>双等号操作符与equals方法比较</strong></p><ul><li>“==”操作符<br>判断两个引用（栈内存中）是否指向堆内存中同一个地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">User u1 = <span class="keyword">new</span> User();</span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">User u3 = u1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = u1 == u2;</span><br><span class="line"><span class="keyword">boolean</span> b2 = u1 == u3;</span><br><span class="line"></span><br><span class="line">System.out.print(b1);<span class="comment">//false</span></span><br><span class="line">System.out.print(b2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>equals<br>equals比较两个对象<strong>内容</strong>是否相等<br>条件：<ol><li>对象类型相同（可以使用instanceof操作符进行比较）；</li><li>两个对象的成员变量值完全相同。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> = obj)&#123; <span class="comment">//this是调用equals的对象，为User类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = obj <span class="keyword">instanceof</span> User; <span class="comment">//判断obj是否为User类型</span></span><br><span class="line"><span class="keyword">if</span>(b)&#123;</span><br><span class="line">User u = (User)obj;<span class="comment">//向下转型为User类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.age == u.age &amp;&amp; <span class="keyword">this</span>.name.equals(u.name))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">User u1 = <span class="keyword">new</span> User();</span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">User u3 = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = u1.equals(u2);<span class="comment">//比较u1、u2</span></span><br><span class="line">System.out.print(b1);</span><br><span class="line"><span class="comment">/* Object类关于equals源代码</span></span><br><span class="line"><span class="comment">public boolean equals(Object obj)&#123;</span></span><br><span class="line"><span class="comment">return (this == obj);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">u1.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">u1.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">u2.name = <span class="string">"lisi"</span>;</span><br><span class="line">u2.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">u3.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">u2.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">System.out.print(u1.equals(u2)); <span class="comment">//false</span></span><br><span class="line">System.out.print(u1.equals(u3)); <span class="comment">//true</span></span><br><span class="line">System.out.print(u1.equals(u3)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门开发(三)---Java常用工具类</title>
      <link href="/2016/03/13/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160313-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%B8%89)-Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2016/03/13/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160313-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%B8%89)-Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讨论Java常用工具类。</p><a id="more"></a><h1 id="包与权限问题"><a href="#包与权限问题" class="headerlink" title="包与权限问题"></a>包与权限问题</h1><ul><li>软件包概念<br>—把类放在不同文件夹中，即为Java类提供了命名空间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：</strong></p><ul><li>编译方法：javac -d . xxx.java<br>-d参数是根据包名生成文件夹 . 表当前目录</li><li>一个类的全名应该是“包名” + “.” + “类名”<br>执行方法：java 包名.类名</li><li><p>包名的命名规范（习惯）：</p><ol><li>要求所有字母小写</li><li>包名一般是域名反写</li></ol></li><li><p>访问权限</p></li><li>public：公共权限</li><li><p>声明为public权限后，类名必须和文件名相同</p><ul><li>不同包中一个类要访问另外一个类时，该类及该类成员变量或成员函数必须为public权限</li></ul></li><li><p>private：私有权限</p></li><li><p>只能修饰变量和函数、内部类</p><ul><li>只能在当前类使用</li></ul></li><li><p>default：包级别访问权限</p></li><li><p>默认访问权限</p><ul><li>同一个包中可访问</li></ul></li><li><p>protected：受保护权限</p></li><li><p>只能修饰变量和函数</p><ul><li>允许跨包继承使用，即必须是子类才能使用<h2 id="权限排序"><a href="#权限排序" class="headerlink" title="权限排序"></a>权限排序</h2>public &gt; protected &gt; default &gt; private</li></ul></li><li><p>导入类import</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名</span><br></pre></td></tr></table></figure></li></ul><p>如果子类和父类不在同一个包中，子类可以继承到父类中的default权限的成员变量和成员函数，但是由于权限不足，无法使用</p><h1 id="接口相关"><a href="#接口相关" class="headerlink" title="接口相关"></a>接口相关</h1><ul><li><p>使用interface定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;<span class="comment">//接口定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//抽象方法且权限为public</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口当中的方法都是抽象方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USBPhone</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;<span class="comment">//implements是对USB接口的实现（类似继承）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="comment">//覆写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">"读"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"写"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接口当中的方法都是public权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      USBPhone usbphone = <span class="keyword">new</span> USBPhone();</span><br><span class="line">      USB usb = usbphone; <span class="comment">//向上转型为USB引用</span></span><br><span class="line"></span><br><span class="line">      usb.read();<span class="comment">//调用read方法</span></span><br><span class="line">      usb.write();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个类可以实现多个接口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">USB</span>,<span class="title">WiFi</span></span>&#123; <span class="comment">//实现多个接口用逗号隔开即可</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个接口可以继承多个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123; <span class="comment">//C类继承了A、B两个接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口应用</li></ul><p>（22、29集）</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>中断正常指令流的事件，程序运行时出处而非编译时出处。</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>Throwable –  Exception    – RuntimeException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 。。。</span><br><span class="line">--  Error</span><br></pre></td></tr></table></figure><ul><li>查开发文档<br>checkException //需要对异常进行处理，不然无法编译通过<br>uncheckException </li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//异常处理</span><br></pre></td></tr></table></figure><p>}catch(Exception e){</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><p>}finally{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//异常出口，IO流需要用</span><br></pre></td></tr></table></figure><p>}</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><ul><li>throw</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"年龄不能为负数"</span>);<span class="comment">//运行时异常</span></span><br><span class="line"><span class="comment">//Exception e = new Exception("");//属于checkException必须try...catch或声明throws</span></span><br><span class="line"><span class="keyword">throw</span> e; <span class="comment">//抛出异常，如无try..catch则程序阻止</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>throws</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> Exception</span>&#123; <span class="comment">//调用setAge时处理异常</span></span><br><span class="line"><span class="keyword">if</span>(age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">Exception e = <span class="keyword">new</span> Exception(<span class="string">""</span>);<span class="comment">//属于checkException必须try...catch或声明throws</span></span><br><span class="line"><span class="keyword">throw</span> e; <span class="comment">//抛出异常，如无try..catch则程序阻止</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">user.setAge(-<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h1><h2 id="IO操作的目标"><a href="#IO操作的目标" class="headerlink" title="IO操作的目标"></a>IO操作的目标</h2><p>从源中读取数据以及将数据写入到数据目的地</p><h2 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h2><ul><li>输入/输出</li><li>字节/字符</li><li><p>节点/处理</p></li><li><p>字节流核心类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InpuStreamOutputStream抽象类</span><br><span class="line">int read(byte[]b,int off,int len)</span><br><span class="line">总多少数据比特形式数组   开头    长度</span><br><span class="line">void write(byte[]b,int off,int len)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStreamFileOutputStream</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//导入类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//声明输入流的引用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"这里写文件路径/xxx.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];<span class="comment">//声明一个大小为100的比特型数组</span></span><br><span class="line">fis.read(buffer,<span class="number">0</span>,buffer.length);<span class="comment">//调用read()将输入流存入数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;buffer.length;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"buffer[i]"</span>);<span class="comment">//打印该数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String s = new String(buffer);//将字节还原成字符串</span></span><br><span class="line"><span class="comment">// s = s.trim();//调用String对象的trim方法，去掉这个字符串首尾空格和空字符</span></span><br><span class="line"><span class="comment">//System.out.println(s);</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取文件和写入文件的方法"><a href="#读取文件和写入文件的方法" class="headerlink" title="读取文件和写入文件的方法"></a>读取文件和写入文件的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//导入类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//声明输入流的引用</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;<span class="comment">//声明输出流的引用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"这里写输入文件路径/xxx.txt"</span>);</span><br><span class="line"></span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"这里写输出文件路径/xxx.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];<span class="comment">//声明一个大小为100的比特型数组</span></span><br><span class="line"><span class="keyword">int</span> temp = fis.read(buffer,<span class="number">0</span>,buffer.length);<span class="comment">//调用read()将输入流存入数组</span></span><br><span class="line"><span class="comment">//read()方法返回值是一共读取多少数据存入temp中</span></span><br><span class="line">fos.write(buffer,<span class="number">0</span>,temp);<span class="comment">//buffer就像一个桶，做中间传递用</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大文件读写方法"><a href="#大文件读写方法" class="headerlink" title="大文件读写方法"></a>大文件读写方法</h2><p>循环读取，每次读一部分。写入类似<br>当read()方法读完会返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//导入类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//声明输入流的引用</span></span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;<span class="comment">//声明输出流的引用</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"这里写输入文件路径/xxx.txt"</span>);</span><br><span class="line"></span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"这里写输出文件路径/xxx.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//声明一个大小为1024的比特型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//借用循环写入</span></span><br><span class="line"><span class="keyword">int</span> temp = fis.read(buffer,<span class="number">0</span>,buffer.length);<span class="comment">//调用read()将输入流存入数组</span></span><br><span class="line"><span class="keyword">if</span> (temp == -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">fos.write(buffer,<span class="number">0</span>,temp);<span class="comment">//buffer就像一个桶，做中间传递用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis.close();<span class="comment">//调用close()方法在读入写入完后关闭流</span></span><br><span class="line">fos.close();<span class="comment">//且由于close()方法也会抛出异常，需要捕获</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流使用方法"><a href="#字符流使用方法" class="headerlink" title="字符流使用方法"></a>字符流使用方法</h2><ul><li>读写文件时，以字符为基础<br>字节输入流：Reader（类似InputStream是抽象类） &lt;– FileReader （类似FileInputStream）<br>int read(char [] c,int off,int len);<br>字节输出流：Writer  &lt;– FileWriter<br>void write(char [] c,int off,int len);</li></ul><h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>读取一行数据<br>声明：public String readLine() throws IOException<br>生成BufferedReader对象的方法<br>BufferedReader in = new BufferedReader(newFileReader(“foo.in”));</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fileReader = <span class="keyword">new</span> FileReader(<span class="string">"文件路径"</span>);</span><br><span class="line">bifferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line"><span class="comment">//String line = bufferedReader.readLine();//只读取一行</span></span><br><span class="line"><span class="comment">//System.out.println(line);</span></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//读取所有行</span></span><br><span class="line">line = bufferedReader.readLine();</span><br><span class="line"><span class="keyword">if</span>(line == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">bifferedReader.close();</span><br><span class="line">fileReader.close();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="“装饰者”设计模式"><a href="#“装饰者”设计模式" class="headerlink" title="“装饰者”设计模式"></a>“装饰者”设计模式</h1><p>设计模式这部分目前还未理解，暂留。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;<span class="comment">//B作为内部类可以使用A的成员变量和成员函数</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funB</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = i + j;<span class="comment">//i是外部类的成员变量A.this.i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后会生成A.class和A$B.class两个文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();<span class="comment">//生成外部类对象</span></span><br><span class="line"></span><br><span class="line">A.B b = <span class="keyword">new</span> A().new B();<span class="comment">//生成内部类对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>interface A{</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething();</span><br></pre></td></tr></table></figure><p>}</p><p>class B{    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void fun(A a)&#123;//需要A类型对象作为参数</span><br><span class="line">System.out.println(&quot;B类的fun函数&quot;);</span><br><span class="line">a.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>class AImpl implements A{    //实现doSomething()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething()&#123;</span><br><span class="line">System.out.println(&quot;doSomething&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>如要调用B类的fun()方法时，首先应该生成AImpl对象，然后向上转型为A类型，再作为参数传进fun()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">AImpl al = <span class="keyword">new</span> AImpl();</span><br><span class="line">A a = al; <span class="comment">//向上转型</span></span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.fun(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： B类的fun函数</span><br><span class="line">doSomething</span><br><span class="line"></span><br><span class="line">若使用匿名内部类</span><br><span class="line">​```java</span><br><span class="line">​```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.fun(<span class="keyword">new</span> A()&#123;<span class="comment">//对比完整A的实现类，几乎相同，只是没有名字</span></span><br><span class="line"><span class="comment">//即内部类覆写doSomething()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"匿名内部类"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>多进程：<br>  操作系统同时运行多个任务<br>多线程：<br>  同一应用程序中多个顺序流同时执行</p><h2 id="多线程程序运行方法"><a href="#多线程程序运行方法" class="headerlink" title="多线程程序运行方法"></a>多线程程序运行方法</h2><h3 id="定义线程方法"><a href="#定义线程方法" class="headerlink" title="定义线程方法"></a>定义线程方法</h3><ol><li>定义一个线程类，它继承Thread并重写其中的方法run(),run()称为线程体<br>注：由于Java只支持单继承，用这种方法定义的类不能再继承其他类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"FirstThread--&gt;"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//生成线程类对象</span></span><br><span class="line">FirstThread ft= <span class="keyword">new</span> FirstThread();</span><br><span class="line"><span class="comment">//启动线程，不是使用run()</span></span><br><span class="line">ft.start();<span class="comment">//从Thread继承而来的方法,开启一个线程去执行</span></span><br><span class="line"><span class="comment">//若这里使用ft.run();则非使用多线程交替</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"main--&gt;"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"Runnable --&gt;"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//生成一个Runnable接口实现类的对象</span></span><br><span class="line">RunnableImpl ri = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"><span class="comment">//生成一个Thread对象，并将Runnable接口实现类的对象作为参数传递给该Thread对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ri);</span><br><span class="line"><span class="comment">//通知Thread对象，执行start方法</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比方法1，多使用方法2</p><h2 id="线程简单控制方法"><a href="#线程简单控制方法" class="headerlink" title="线程简单控制方法"></a>线程简单控制方法</h2><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Thread.sleep();</span><br><span class="line">- Thread.yield();//自动让出CPU</span><br></pre></td></tr></table></figure><h3 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- getPriority();</span><br><span class="line">- setPriority();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"Runnable --&gt;"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//生成一个Runnable接口实现类的对象</span></span><br><span class="line">RunnableImpl ri = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line"><span class="comment">//生成一个Thread对象，并将Runnable接口实现类的对象作为参数传递给该Thread对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ri);</span><br><span class="line">t.setPriority(Thread.MAX_PRIORITY);<span class="comment">//设置为最大优先级10，最小优先级1MIN_PRIORITY</span></span><br><span class="line"><span class="comment">//通知Thread对象，执行start方法</span></span><br><span class="line">t.start();</span><br><span class="line">System.out.println(t.getPriority());<span class="comment">//获取线程优先级</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程共用同一份数据"><a href="#多线程共用同一份数据" class="headerlink" title="多线程共用同一份数据"></a>多线程共用同一份数据</h2><p>需要使用到同步代码块，否则数据会出现错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">impements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//同步代码块，this相当于互斥量</span></span><br><span class="line">System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">i--;</span><br><span class="line">Thread.yield();</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">bread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门开发(二)---Java面向对象</title>
      <link href="/2016/03/12/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160312-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%BA%8C)-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2016/03/12/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160312-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%BA%8C)-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><strong>终极目标</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- 消除重复代码</span><br></pre></td></tr></table></figure><h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><ol><li><p>掌握语法</p></li><li><p>训练思维方式<br>2.1 先确定谁来做，再考虑怎么做<br>2.2 先考虑整体，再局部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：如以面向对象考虑设计一部电梯</span><br></pre></td></tr></table></figure><ul><li>先有一部电梯<ul><li>考虑电梯有哪些行为：上、下、停、开门、关门等<ul><li>电梯属性：载重多少，长宽高</li></ul></li></ul></li></ul><p>★ 2.3 先抽象，后具体</p><p>多做训练、对比</p></li><li><p>熟悉设计原则<br>开放注入原则等</p></li><li><p>掌握设计模式（前人经验总结）</p></li></ol><a id="more"></a><h1 id="创建类、对象及对象方法和引用"><a href="#创建类、对象及对象方法和引用" class="headerlink" title="创建类、对象及对象方法和引用"></a>创建类、对象及对象方法和引用</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">属性; <span class="comment">//成员变量，描述类的状态</span></span><br><span class="line">方法; <span class="comment">//成员方法/函数，描述类的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成对象的方法"><a href="#生成对象的方法" class="headerlink" title="生成对象的方法"></a>生成对象的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><h3 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a>java数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 基本数据类型</span><br><span class="line">- 引用数据类型</span><br></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/generated%20_objec_fun.jpg" alt="生成对象方法"><br>对象名属于引用数据类型<br>堆内存和栈内存的使用：堆（heap）内存存放对象本体，栈（stack）内存存放对象的引用—对象名<br>类和对象的关系：类是抽象概念，对象是具体的个人</p><h3 id="对象的使用方法"><a href="#对象的使用方法" class="headerlink" title="对象的使用方法"></a>对象的使用方法</h3><ul><li>对象.变量</li><li>对象.函数<br>说明：属性都是有主的</li></ul><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即没有名字的对象，一次性的</span><br><span class="line">new Dog().jump();</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同一个类中，返回值相同，函数同名，但参数列表不同</span><br><span class="line">根据传参不同判断是执行哪个函数</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"没有参数的funA()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有一个参数的funA()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.funA();</span><br><span class="line">a.fun(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><p>构造函数不算成员函数</p><ul><li>无返回值的定义</li><li>构造函数名字和类名必须相同</li><li>如未自定义，编译时会自动生成无参且方法体为空的构造函数</li><li>使用new时会调用构造函数</li></ul><h1 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h1><p>this相当于人称代词—“我”，是调用函数的对象</p><h2 id="调用成员变量和成员函数"><a href="#调用成员变量和成员函数" class="headerlink" title="调用成员变量和成员函数"></a>调用成员变量和成员函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"my name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：this.name表示成员变量name而非参数name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">person()&#123;</span><br><span class="line">System.out.println(<span class="string">"无参的构造函数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(String name,<span class="keyword">int</span> age,String address)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"my name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">person()&#123;</span><br><span class="line">System.out.println(<span class="string">"无参的构造函数"</span>);</span><br><span class="line">&#125;</span><br><span class="line">person(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person(String name,<span class="keyword">int</span> age,String address)&#123;</span><br><span class="line"><span class="keyword">this</span>(name,age);</span><br><span class="line"><span class="keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"my name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 对this()构造函数的调用必须是第一条语句！</p><h1 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h1><h2 id="静态成员变量语法特点"><a href="#静态成员变量语法特点" class="headerlink" title="静态成员变量语法特点"></a>静态成员变量语法特点</h2><ol><li>可直接用类名来调用或对象名调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Person.i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>所有对象使用的静态变量都是同一个<br>—静态变量属于类，任何该类生成的对象所使用的静态变量都是同一个<br><img src="http://olvboulzy.bkt.clouddn.com/static_member.jpg" alt="静态成员变量"></li></ol><h2 id="静态函数语法特点"><a href="#静态函数语法特点" class="headerlink" title="静态函数语法特点"></a>静态函数语法特点</h2><p>静态函数不能使用非静态的成员变量<br>静态函数当中不能使用this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代码块语法特点"><a href="#静态代码块语法特点" class="headerlink" title="静态代码块语法特点"></a>静态代码块语法特点</h2><p>没有名字，默认装载类时执行，一般是为静态变量赋初始值,如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="继承（扩展）"><a href="#继承（扩展）" class="headerlink" title="继承（扩展）"></a>继承（扩展）</h1><ul><li>Java只支持单继承</li><li>只继承成员变量和成员函数</li><li>使用继承是为了减少重复代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//Student继承了Person类，即拥有了Person的成员变量和成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="子类实例化"><a href="#子类实例化" class="headerlink" title="子类实例化"></a>子类实例化</h1><p>在子类的构造函数当中，必须调用父类的构造函数。<br>原因：子类继承父类无法继承构造函数，可能产生重复代码，为解决这个问题，要求必须调用super()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  Person()&#123;</span><br><span class="line">      System.out.println(<span class="string">"Person的无参构造函数"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  Student()&#123;</span><br><span class="line">      <span class="keyword">super</span>(); <span class="comment">//调用父类无参构造函数</span></span><br><span class="line">      System.out.println(<span class="string">""</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数覆写（override）"><a href="#函数覆写（override）" class="headerlink" title="函数覆写（override）"></a>函数覆写（override）</h1><p>子类对父类构造函数的重写</p><ol><li>在具有父子关系的两个类中</li><li>父类和子类各有一个函数，这两个函数的定义（返回值类型、函数名和参数列表都相同）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">"Person的无参构造函数"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String address;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"好好吃"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用super调用父类成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---super.父类成员函数名();</span><br></pre></td></tr></table></figure><h1 id="抽象类和抽象函数"><a href="#抽象类和抽象函数" class="headerlink" title="抽象类和抽象函数"></a>抽象类和抽象函数</h1><p>面向对象 -&gt; 先抽象后具体</p><h2 id="抽象函数语法特征"><a href="#抽象函数语法特征" class="headerlink" title="抽象函数语法特征"></a>抽象函数语法特征</h2><p> —只有<strong>函数定义</strong>，没有<strong>函数体</strong>的函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>; <span class="comment">//抽象函数fun()</span></span><br></pre></td></tr></table></figure></p><h2 id="抽象类语法特征"><a href="#抽象类语法特征" class="headerlink" title="抽象类语法特征"></a>抽象类语法特征</h2><p>abstract定义</p><ul><li>抽象类不能生成对象 （原因：如果调用抽象函数无法执行–无函数体）</li><li>一个类中包含抽象函数，该类必须被声明为抽象类</li><li>一个类中没有抽象函数，该类可以被声明为抽象类</li></ul><h2 id="抽象类作用"><a href="#抽象类作用" class="headerlink" title="抽象类作用"></a>抽象类作用</h2><p>就是用来被继承的，子类可以生成对象<br>可以拥有构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//抽象函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123; <span class="comment">//复写Person的抽象函数</span></span><br><span class="line">System.out.println(<span class="string">"筷子吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Chinese(); <span class="comment">//向上转型</span></span><br><span class="line">p.eat(); <span class="comment">//调用eat方法，结果打印出“筷子吃饭”</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要使用抽象类"><a href="#为什么要使用抽象类" class="headerlink" title="为什么要使用抽象类"></a>为什么要使用抽象类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"close"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//不声明为抽象类，方法体为空，要求覆写</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HPPrinter</span> <span class="keyword">extends</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line"><span class="comment">//如果忘记覆写print，程序编译不会报错，但结果不对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"close"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>; <span class="comment">//抽象函数，如子类不覆写该方法将会报错，避免语义错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编程希望语法和语义的错误能达到统一。</p></blockquote><h1 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h1><p><strong>对象转型是多态性的体现</strong></p><ol><li>向上转型</li></ol><p>将子类的对象赋值给父类的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student;</span><br><span class="line">Person p = s;</span><br></pre></td></tr></table></figure></p><p>一个引用能够调用哪些成员（变量和函数），取决于这个引用的类型。<br>一个引用调用的是哪一个方法，取决于这个引用所指向的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我的名字是："</span> + name + <span class="string">"，我的年龄是："</span> + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">String address;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我在学习"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">introduce</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.introduce();</span><br><span class="line">System.out.println(<span class="string">"我的家在："</span> + address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">//s对象向上转型为Person</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">"张三"</span>; <span class="comment">//调用person的成员  </span></span><br><span class="line">p.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">p.introduce(); <span class="comment">//调用的是Student的成员函数</span></span><br><span class="line">p.study();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>向下转型</li></ol><p>将父类的对象赋值给子类的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s1;<span class="comment">//先向上转型</span></span><br><span class="line">Student s2 = (Student)p; <span class="comment">//再向下强制转型</span></span><br></pre></td></tr></table></figure></p><hr><p><strong>注：</strong></p><p>对象转型十分重要，需要在未来慢慢体会。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android入门开发(一)---Java基础语法</title>
      <link href="/2016/03/11/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160311-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%B8%80)-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2016/03/11/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20160311-Android%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91(%E4%B8%80)-Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>由于毕设自己挖坑要做硬件又要做APP，逼得我捡起Java，在此将学习笔记贴来作为整理记忆。<br>该笔记大致分为：</p><ol><li>Java基础语法</li><li>Java面向对象</li><li>Java常用工具类</li></ol><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>说明：</p><ul><li>Java字符使用Unicode字符集，原ASCII字符集是7位二进制，Unicode使用统一二进制0xFFFFFF</li><li>byte &lt; short &lt; int &lt; long &lt; float &lt; double<br><img src="http://olvboulzy.bkt.clouddn.com/data_type.jpg" alt="变量类型"></li></ul><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>说明：应以<strong>字母</strong>、<strong>美元符号</strong>、<strong>下划线</strong>开头，且<strong>对大小写敏感</strong>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> $age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> _age = <span class="number">40</span>;</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>说明：<br>A&amp;B 和 A&amp;&amp;B 区别，当A为false时，不管B不运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span> ;</span><br><span class="line"><span class="keyword">boolean</span> e = i &gt; <span class="number">6</span> &amp;&amp; i++ &gt; <span class="number">7</span>;</span><br><span class="line">System.out.println(e);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 e=false i=5</p><h1 id="程序运行流程"><a href="#程序运行流程" class="headerlink" title="程序运行流程"></a>程序运行流程</h1><ol><li>顺序结构</li><li>分支结构<br>if…else…<br>switch…case…</li><li>循环结构<br>for<br>while</li></ol><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数据类型分为基本数据类型和引用数据类型<br>数组和对象属于引用数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"><span class="comment">//数组的静态定义法</span></span><br><span class="line"><span class="keyword">int</span> arr [] = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//数组的动态声明法</span></span><br><span class="line"><span class="keyword">int</span> arr [] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//元素类型为int型默认是0，boolean型默认为false，char型默认为空字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的定义方法</span></span><br><span class="line"><span class="keyword">int</span> arr [][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr[i].length;j++)&#123;<span class="comment">//防止出现数组越界异常</span></span><br><span class="line">System.out.println(arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态定义</span></span><br><span class="line"><span class="keyword">int</span> arr [][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组一旦声明，长度即确定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装ArchLinux遇到的各种问题</title>
      <link href="/2016/02/10/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/20160210-%E5%AE%89%E8%A3%85ArchLinux%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2016/02/10/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/20160210-%E5%AE%89%E8%A3%85ArchLinux%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="http://olvboulzy.bkt.clouddn.com/ArchLinuxproblems1.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt></p><h2 id="废话一下"><a href="#废话一下" class="headerlink" title="废话一下"></a>废话一下</h2><p>不知为何，踏入计算机领域以来最兴奋的就是装系统了==。传说会装ArchLinux的才是真的会装系统，怀着好奇心开始了Arch的安装。。。不得不说确实麻烦点，但好在有那么多具有奉献精神的程序员们，Arch拥有丰富的wiki指南，遇到问题去wiki看看一般都有答案了。这里我仅记录下自己在安装过程遇到的问题和我的解决办法，防止忘记，OK</p><a id="more"></a><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><ul><li><a href="http://bbs.archlinuxcn.org/viewtopic.php?id=1037" target="_blank" rel="noopener">中文wiki</a></li></ul><h3 id="用U盘刻录后开机无法进入安装"><a href="#用U盘刻录后开机无法进入安装" class="headerlink" title="用U盘刻录后开机无法进入安装"></a>用U盘刻录后开机无法进入安装</h3><p>官方下载的镜像肯定没问题，我曾尝试用原来刻windows用的软碟通，刻录是完成了可就是进不去U盘，引导文件也有，无语</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>使用USBWrite再次写入即可安装。忘记对比和软碟通做的有什么区别，哪位如果尝试的话希望留言</p><h3 id="引导GRUB双系统无法完成"><a href="#引导GRUB双系统无法完成" class="headerlink" title="引导GRUB双系统无法完成"></a>引导GRUB双系统无法完成</h3><p>UEFI模式下 Linux会在ESP（启动分区）加入vmlinuz等，是Linux启动的微内核…，开始我以为这东西没用，就全删了，结果蛋疼折腾一晚上。。。。<br>每次在grub-install写入grub.cfg时报错<br>情况1：”Failed to connect to lvmetad: No such file or directory.  Falling back to internal scanning. “</p><h4 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pacman -S device-mapper linux lvm2</span><br></pre></td></tr></table></figure><p>重新安装相关启动内核，参考<a href="https://bbs.archlinux.org/viewtopic.php?id=159415" target="_blank" rel="noopener">wiki</a></p><h3 id="写grub-cfg"><a href="#写grub-cfg" class="headerlink" title="写grub.cfg"></a>写grub.cfg</h3><p>参考<a href="https://wiki.archlinux.org/index.php/GRUB_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E5.85.B6.E4.BB.96.E7.B3.BB.E7.BB.9F.E4.B8.8D.E8.83.BD.E8.87.AA.E5.8A.A8.E.8F.91.E7.8E.B0Arch_Linux" target="_blank" rel="noopener">wiki</a><br>这个折腾了我比较久，因为我是Win8.1和Arch双系统，Arch最大特点就是可定制化，说白了就是基本都要自己干，以前装Ubuntu的时候，双系统可以自动引导，Arch就。。。恩，要有耐心<br>手动创建过程如下：（如果grub-install一直报错建议手动添加，还能增加理解）<br>基本的GRUB配置文件使用如下选项:<br>(hdX,Y) 是X磁盘的Y分区,分区从1开始计数,磁盘从0开始计数.<br>set default=N设定用户选择超时时间过后的默认启动项<br>set timeout=M设定用户选择超时时间(秒).<br>menuentry “title” {entry options}设置一个名为title的启动项<br>set root=(hdX,Y)设定启动分区(kernel和GRUB模组所在磁盘),/boot没被要求独占一个分区,有可能就是root分区下的一个文件夹<br>示例配置如下:</p><p>/boot/grub/grub.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Config file for GRUB - The GNU GRand Unified Bootloader&#10;# /boot/grub/grub.cfg&#10;&#10;# DEVICE NAME CONVERSIONS&#10;#&#10;#  Linux           Grub&#10;# ————————-&#10;#  /dev/fd0        (fd0)&#10;#  /dev/sda        (hd0)&#10;#  /dev/sdb2       (hd1,2)&#10;#  /dev/sda3       (hd0,3)&#10;#&#10;&#10;# Timeout for menu&#10;set timeout=5&#10;&#10;# Set default boot entry as Entry 0&#10;set default=0&#10;&#10;# (0) Arch Linux&#10;menuentry &#34;Arch Linux&#34; &#123;&#10;  set root=(hd0,1)&#10;  linux /vmlinuz-linux root=/dev/sda3 ro&#10;  initrd /initramfs-linux.img&#10;&#125;&#10;&#10;## (1) Windows&#10;#menuentry &#34;Windows&#34; &#123;&#10;#  set root=(hd0,3)&#10;#  chainloader +1&#10;#&#125;</span><br></pre></td></tr></table></figure><h3 id="解决字体问题"><a href="#解决字体问题" class="headerlink" title="解决字体问题"></a>解决字体问题</h3><p>网页中文字体模糊 安装什么泉字体即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaourt -S</span><br></pre></td></tr></table></figure></p><p>WPS缺少字体symbol等，下载Ubuntu的字体包.deb，然后解压出来找到字体文件cp -r到/usr/share/fonts/下即可</p><h3 id="主题问题"><a href="#主题问题" class="headerlink" title="主题问题"></a>主题问题</h3><p>gonme的主题可以去gonme-look.org下载，然后cp -r 到 /usr/share/themes/下然后快捷键 alt+F2输入r再回车即可通过gonme-tools更换</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>发现软件管理器的一个安装脚本PK。。。老是报错，也是醉了</p><h3 id="gonme-shell-extension"><a href="#gonme-shell-extension" class="headerlink" title="gonme shell extension"></a>gonme shell extension</h3><p>插件用火狐浏览器可以直接装，两个字 方便！！</p><h3 id="联网问题"><a href="#联网问题" class="headerlink" title="联网问题"></a>联网问题</h3><p>设置Networkmanager时需注意它和wifi-menu之间配置会冲突，容易引起开机时wifi无法连接问题，只能取其一将其中一个开机启动禁用即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> xxx.service...</span><br></pre></td></tr></table></figure></p><h3 id="字体显示问题"><a href="#字体显示问题" class="headerlink" title="字体显示问题"></a>字体显示问题</h3><p>好像是我更新的时候挂了，就像这样<img src="http://img.blog.csdn.net/20170309143059043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDM2MTM1Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><h4 id="解决办法：-2"><a href="#解决办法：-2" class="headerlink" title="解决办法："></a>解决办法：</h4><p>一般字体出问题无法显示都可以用这个方法—-恢复到未打补丁的包<br>To restore the unpatched packages, reinstall the originals:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --asdeps freetype2 libxft cairo fontconfig</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git本地服务器搭建</title>
      <link href="/2015/09/04/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20150904-git%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2015/09/04/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20150904-git%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>最近在参加RoboCup，因为考虑到团队代码不能公开，为了方便管理，今天特地学了下<strong>git</strong>的本地服务器搭建和使用，这个林纳斯开发的用着还是非常好，记录一下。</p><a id="more"></a><h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>我的客户端和服务器端都是Ubuntu14.04 LTS</p><h1 id="需要工具"><a href="#需要工具" class="headerlink" title="需要工具"></a>需要工具</h1><ul><li>git</li><li>ssh</li></ul><p>这里说明一下，git一般是要自己安装的，Ubuntu使用sudo apt-get install git即可。而ssh一般自带，通过ssh -V(v大写)可以查看，服务器端需安装Server端，sudo apt-get install openssh-server 。<br>检查是否开启ssh：ps -e|grep ssh，如显示sshd则表示服务器开启，修改配置在/etc/ssh/sshd_config中。修改后需重启服务 sudo service ssh restart。</p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="保证客户端主机可以连上服务器端主机"><a href="#保证客户端主机可以连上服务器端主机" class="headerlink" title="保证客户端主机可以连上服务器端主机"></a>保证客户端主机可以连上服务器端主机</h2><p>在客户端机上使用如下命令</p><p><code>ssh &lt;服务器端用户名&gt;@&lt;服务器端IP地址&gt;</code></p><p>确定能登录后ctrl+D注销</p><h2 id="配置服务器端git项目"><a href="#配置服务器端git项目" class="headerlink" title="配置服务器端git项目"></a>配置服务器端git项目</h2><p>在你需要建立git仓库管理的文件下<code>sudo git init --bare sample.git</code>，其中sample.git为你的项目，名字任意，服务器上的Git仓库通常都以.git结尾</p><h2 id="客户端上传本地git项目"><a href="#客户端上传本地git项目" class="headerlink" title="客户端上传本地git项目"></a>客户端上传本地git项目</h2><p>git remote add &lt;取个服务器名字&gt; &lt;服务器用户名&gt;@&lt;服务器IP地址&gt;:&lt;服务器端刚才配置的.git文件夹位置&gt;</p><p>git push &lt;刚才取的服务器名字&gt;</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一般情况下，一个项目四个人左右在局域网内维护这样就可以了，人多了有权限管理权限，我目前还没涉及。</p><p>不过如果闲每次push都要输入密码麻烦的话，可以使用ssh的公钥即可免密码输入的麻烦，实现如下：</p><p>1.服务器、客户端生成公钥：ssh-keygen，一路回车，默认生成的公钥在/home/&lt;你的用户名&gt;/.ssh/id_rsa.pub,将客户端的这个文件拷到服务器端主机，将其中内容复制到服务器端的公钥里即可。</p><h1 id="参考的学习网站"><a href="#参考的学习网站" class="headerlink" title="参考的学习网站"></a>参考的学习网站</h1><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">廖雪峰的git教程，我一天看完就会了，你说好不好。</a></p><p><a href="http://www.cnblogs.com/trying/archive/2012/06/28/2863758.html" target="_blank" rel="noopener">这里面介绍了一个项目各个职位的人对git的使用，不错。</a></p><p><a href="http://blog.jobbole.com/60505/" target="_blank" rel="noopener">如果你遇到权限，可以参考这里。</a></p><p><a href="http://blog.jobbole.com/53573/" target="_blank" rel="noopener">说15分钟学会使用git服务器搭建，反正我是没十五分钟没会。</a></p><p><a href="http://www.linuxidc.com/Linux/2009-06/20421.htm" target="_blank" rel="noopener">讲Server的配置比较详细，有ssh_config还有Gitosis的配置。</a></p><p><a href="http://blog.chinaunix.net/uid-16979052-id-3491746.html" target="_blank" rel="noopener">这有关于修改hosts的，就不用输入IP地址了，也有学习的地方。</a></p><blockquote><p>本文转自我的<a href="http://blog.csdn.net/u014361352/article/details/48212041" target="_blank" rel="noopener">CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Excel的几点运用</title>
      <link href="/2015/06/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20150626-%E5%85%B3%E4%BA%8EExcel%E7%9A%84%E5%87%A0%E7%82%B9%E8%BF%90%E7%94%A8/"/>
      <url>/2015/06/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/20150626-%E5%85%B3%E4%BA%8EExcel%E7%9A%84%E5%87%A0%E7%82%B9%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前感觉Office的办公软件使用起来都比较简单，毕竟图形化界面，不会的我一个个从工具栏里找总可以找到，今天同学发了份题目来，发现居然完全无从下手，钻研一晚上总算是搞定了，赶紧分享出来免得忘记。</p><p>分别是<strong>规划求解</strong>和<strong>数据透视工具</strong>。</p><a id="more"></a><blockquote><p>说明：以下分析都是我自己的理解，如有不对的地方欢迎大家及时指出，以免误导他人。</p></blockquote><h1 id="规划求解"><a href="#规划求解" class="headerlink" title="规划求解"></a>规划求解</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>使用规划求解设计获利最大的生产方案</strong><br>某企业需要生产A、B两种产品，其中每生产一件A产品需要x原料3kg、y原料4kg、z原料4kg，B产品需要x原料2kg、y原料11 kg、z原料6kg。已知每天各种原料的使用限额为x原料120kg、y原料400kg、z原料240kg。根据预测，每销售一件A产品可获利1.6万元，B产品可获利1.3万元。那么如何安排生产计划才能在有限的原料供应下获得最大的利润呢？</p><p>要求：应用Excel的规划工具求解，首先需要将其模型化，分别确定决策变量，设置约束条件和目标。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先要明白什么是规划求解，为什么要用到它。</p><p>Google了下，说了一堆没看懂，后来想找题来看看，发现规划求解归根结底就是求方程最优解，比如什么最小运输成本呀，找个一个组合使差额最小等等，利用工具快速求解。</p><p>回到问题。</p><p>要求模型化，<strong>决策变量就是你用数学方法解题的xy之类的未知数</strong>，这里我选择的是A、B每日的生产的个数，假设分别为a、b；然后<strong>设置约束条件，就是列的方程组</strong>，这里是每日各原料的使用限额；最后<strong>目标当然就是最优解</strong>，这里是最大利润。</p><p>具体操作。</p><p>本人使用的是office2013版本，“规划求解”这个选项如果按我之前讲的在工具栏里找，死活也没有，因为从07版本后微软好像觉得这功能少用就放得很隐蔽了，2013版本的要从<strong>文件-&gt;选项-&gt;加载中心-&gt;Excel加载项-&gt;转到里选上规划求解，然后在工具栏的右侧就能找到这个功能</strong>，07、10版本类似。</p><p>然后当然就是建表了。这个可以随意，只要你自己能明白哪个代表什么意思就行。</p><p>我的是：<br><img src="http://img.blog.csdn.net/20150626094937002" alt="建表"></p><p>相关的功能我都注明了，因为<strong>规划求解要求目标必须是函数</strong>，所以得先为目标设置函数。</p><p>这里先假设从左上角向右分别为ABCDEF，向下为1234567。那么依题意有<em>目标=C6\</em>C7+D6<em>D7即总利润=1.6</em>A日产量+1.3<em>B日产量</em>。这里需要借助SUMPRODUCT这个函数，即<br><img src="http://img.blog.csdn.net/20150626095933714" alt="SUMPRODUCT"></p><p>这个函数可以求几个数乘积的和。Array中各元素对应相乘再相加，如图中是M20<em>M21+N20</em>N21，所以每个Array中元素个数必须相同。</p><p>然后考虑到约束条件中还需使用到函数，即A日产量<em>A每件需x的量+B日产量</em>B每件需x量&lt;=x的每日限额，而规划求解中约束条件只能指定单元格（个人不知道如何在约束条件插入函数，所以如果有方法望告知），所以我先将函数放入单元格这样就可以使用约束条件。如第一张图中蓝色部分，函数还是SUMPRODUCT，三个函数（如第一个：fx=A日产量<em>A每件需x的量+B日产量</em>B每件需x量）放入对应单元格即可。</p><p>最后就是最关键的使用规划求解了。工具栏-&gt;数据-&gt;规划求解<br><img src="http://img.blog.csdn.net/20150626101133341" alt="规划求解"></p><p>设置目标：“目标” 到 “最大值”<br>通过更改可变单元格：决策变量<br>约束条件：决策变量=int整数<br>决策变量&gt;=0<br>约束条件&lt;=每日限额</p><p>其余默认点击求解即可。</p><p><img src="http://img.blog.csdn.net/20150626101654746" alt="求解结果"></p><p>可以看出，规划求解可以很方便的求出最优解。</p><h1 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>创建数据透视表<br>根据当前生源情况信息创建数据透视表，统计不同地区的不同分数段的男生和女生的人数，分数段的划分：将成绩由最低分到最高分之间以50分为间隔划分成若干分数段。要求不显示汇总信息。</p><p><img src="http://img.blog.csdn.net/20150626102030296" alt="数据透视表"></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>依然要知道什么数据透视表，为什么要用它。</p><p>透视嘛，就是可以通过这张表能很容易看出原表的特性。在这是能看出每个省不同性别在不同分数段的人数情况。十分方便的一个功能！</p><p>具体实现。</p><p>先<strong>选定原表所有数据（注意是所有数据，包含表头的学院名称等等）</strong>，然后在工具栏-&gt;插入-&gt;数据透视表创建</p><p><img src="http://img.blog.csdn.net/20150626102814825" alt="创建"></p><p>选择一个表或区域，刚才选中的就是，如果没有可以重新选中，然后下面有个选择放置数据透视表位置，我是放在现有工作表，这个随意。之后确定即可。</p><p>而后就可以根据要求选择你需要的数据进行分析。</p><p><img src="http://img.blog.csdn.net/20150626103227114" alt="分析"></p><p>这里因为需要对入学成绩进行区间划分，所以先在列中添加入学成绩，再选择列成绩某一单元右键-&gt;创建组。</p><p><img src="http://img.blog.csdn.net/20150626103712209" alt="创建组"></p><p>然后选择区间（步长）即可。</p><p><img src="http://img.blog.csdn.net/20150626103809108" alt="组合"></p><p><em>这里有必要说明一下，可能有些人用的是WPS，我之前也是用这个，后来选择创建组后并没有步长这个选项，不知道为什么，就放弃了这个软件。Microsoft Office的霸主地位不可撼动啊==。</em></p><p>之后汇总这个不要的话可以从字段设置里删除，包括布局是表格形式还是大纲形式。这里根据题目给出的图表，就是需要对地区使用表格形式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总得来说数据透视表比规划求解简单些，多捣鼓会应该就会了，各种功能大家可以试试，如果错了就Ctrl+z呗，对吧。学习这种东西还是需要自己多动手实践，不会的多百度百度（虽然之前看一篇文章说百度这种东西让人们越来越不会思考-.-，不过我觉得这最多也不过是为了快速学习的一点缺陷罢了），不然就自己多尝试摸索。</p><blockquote><p>本文转自我的<a href="http://blog.csdn.net/u014361352/article/details/46647513" target="_blank" rel="noopener">CSDN</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下C程序</title>
      <link href="/2015/04/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20150405-Linux%E4%B8%8BC%E7%A8%8B%E5%BA%8F/"/>
      <url>/2015/04/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/20150405-Linux%E4%B8%8BC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux下C语音使用的是gcc编译，学习全手动编译对理解编程过程十分有好处。</p><a id="more"></a><h1 id="使用初步"><a href="#使用初步" class="headerlink" title="使用初步"></a>使用初步</h1><ul><li>创建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim a.c    //创建一个a.c文件</span><br></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc a.c</span><br></pre></td></tr></table></figure><ul><li>查看编译后文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls    //新产生了一个a.out的编译文件（可执行的文件颜色是不一样的）</span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.c     //执行当前目录下的a.c文件</span><br></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_1.png" alt="img"></p><p><strong>说明：</strong> <em>gcc max.c hello.c  同时编译两个源文件-o main.out 表示输出文件名为main.out(默认为a.out)</em></p><h1 id="多个源文件分而治之"><a href="#多个源文件分而治之" class="headerlink" title="多个源文件分而治之"></a>多个源文件分而治之</h1><p>用include 包含源文件max.c</p><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_2.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="img"></p><h2 id="头文件与函数定义分离"><a href="#头文件与函数定义分离" class="headerlink" title="头文件与函数定义分离"></a>头文件与函数定义分离</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c max.c -o max.o</span><br></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_3.png" alt="img"></p><p>max.o不可执行，只有是有main()函数入口的才可执行，而max.o只是编译后形成的一个类似与01代码的机器码而已<br>编译时要将人写的英文程序编译成机器码是消耗CPU性能的，如果编译内容较多，耗时就会比较长，而如果将一些不常改动的函数提前编译成机器码即“.o”文件，则可以大量节约编译所需时间。</p><p>但是分离后不知道静态库文件（max.o）的类型还有参数，这时可以模仿系统#include “max.h”,创建max.h,而在max.h文件中只声明函数类型，参数类型等信息，即可告诉别人该函数该如何使用。</p><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_4.png" alt="img"></p><p>在编译时依然需要加上max.o等文件以前编译，否则会出现无法找到该函数的错误</p><h1 id="Makefile的编写"><a href="#Makefile的编写" class="headerlink" title="Makefile的编写"></a>Makefile的编写</h1><h2 id="创建Makefile"><a href="#创建Makefile" class="headerlink" title="创建Makefile"></a>创建Makefile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi makefile</span><br></pre></td></tr></table></figure><h2 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h2><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_5.png" alt="img"></p><p>递归编译，#表注释，gcc命令前必须用Tab键，不能用空格，不然会报错</p><p>使用make命令执行，若修改后再次执行，则之前执行过生成的文件不会再被执行。</p><p><img src="http://olvboulzy.bkt.clouddn.com/linuxc_6.png?imageView2/0/q/75|watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="img"></p><blockquote><p>参考慕课网学习教程:<a href="http://www.imooc.com/learn/248" target="_blank" rel="noopener">Linux C语言编程基本原理与实践</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
