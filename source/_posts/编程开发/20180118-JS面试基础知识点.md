---
title: JS笔试基础知识点
date: 2018-01-18 20:20:00
tags: [JavaScript,面筋]
categories: 编程开发
permalink:
comments: true
---

听公开课讲得一些JS笔试中容易出现的知识点。

与其说是知识点，不如说是---“那些年走过的JS大坑”

一般关于JS的笔试会走两极端----要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）

<!--more-->



# 字面量相关

定义：计算机能识别类型的数据。

## 特殊字面量

顾名思义，计算机识别不了的---NaN，指的不是一个正常的数。

## 常见考察点

- 正数/0=正无穷Infinity
- 0/0=NaN
- parseInt(“string”); 将字符串转为整数的数字类型，条件：纯数字字符串或数字开头字符串，其他为NaN
- 数据类型参与数值运算：
  - ”数据类型---数字、字符串、undefined、布尔、null”；
  - ”数学运算--- + - * / %”。
  - 非数字参与数学运算会把非数字转换（**隐式转换**）为数字再参与运算。除null、false转换为0，数字字符串转为数字，其余包括undefined为NaN

# 各种运算符

## 比较运算符（关系运算符）

- `==` 相等  `===`全等于，即除判断值是否相等，还要判断数据类型，如`1`和`true`。`!=` 不相等（与`==`相反）
- 比较运算的结果就是布尔值，`true`/`false`
- 其他数据参与比较运算时，也会隐式转换为数字参与运算
- `NaN`参与的话，无论与谁都是不等于`false`
- `IsNaN()`方法，判断一个数是否能转为`NaN`，能`true`，否`false`，能转的有：非数字字符串、`undefined`


## 等式

上面说到了比较运算符 `==` 和`===`，下面总结一下与等式(包括`==`, `===`, `!=`, 和 `!==`)相关的东西。

首先说下`==`和`===`的区别，`==`只检查**值(value)**是否相同，而`===`不仅比较**值(value)**还要检查**数据类型(type)**是否相同，所以`==`又叫做**松等于(loose-equality)** ，`===`又叫做**严格等于(strict-equality)**。

> **注1：**在比较时，若比较两端非`number`类型，则会自动转换为`number`类型再进行比较。
>
> **注2：**如果比较两个非原始值，比如对象`object`（包括函数`function`和数组`array`）。因为这些值实际上是通过引用保存的，所以`==`和`===`比较都只是检查引用是否匹配，而不是基本值。

例子一：

```javascript
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

例子二：

```javascript
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

这时候就有一个问题，什么时候使用`==`，什么时候使用`===`呢？有如下几个基本规则：

- 如果比较两端值的类型是`boolean`类型，`true/false`，则尽量使用`===`，而不用`==`；
- 如果比较两端的值是些特别的值(`0`, `""`, or `[]` -- empty array)，则尽量使用`===`，而不用`==`；
- 其他都用`==`吧


## 不等式

有等式当然就有不等式，有`<`, `>`, `<=`, 和 `>=`四种不等式。一般用于比较`number`类型，但在JavaScript中`string`值也能被比较。

> **注：**这里没有严格不等式。

例子一：

```javascript
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

例子二：

```javascript
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

例子二中 b值的类型是`string`，在参与不等式比较时，会强制转换为`NaN`，而`NaN`和谁都不相等，包括和它自己。


## 赋值运算符 +=

- 必须有变量参与运算
- 特殊：++递加- -递减，变量出现一次叫做使用一次。可为a++或++a



## 逻辑运算符 && 、||、!

- 规律：逻辑与和逻辑或，答案都与第一个操作数a能够判读为true/false有关，如判断为假的有---null、undefined、0、NaN、” ” 空字符串；判断为真---非0非NaN数字、非空字符串
- 与运算&&：a&&b，如果a为true，则结果就是b；如果a为false，则为false
- 逻辑或||：a||b，如果a为true，结果就是true；如果a为false，则结果为b
- 逻辑非：


## Truthy & Falsy

总结一下一些奇葩的`boolean`类型，一般性的布尔值没什么好说的。特别提下一些会被判断为truthy和falsy。

一些特别的"falsy"如下：

- `""` (empty string)
- `0`，`-0`，`NaN` (invalid number)
- `null`,`undefined`
- `false`

一些特别的“truthy”如下:

- `"hello"`
- `42`
- `true`
- `[ ]`, `[ 1, "2", 3 ]` (arrays)
- `{ }`, `{ a: 42 }` (objects)
- `function foo() { .. }` (functions)




## 三元运算符--- ? : 

或作为条件分支语句

​         Boolean_expression? true_value : false_value;



# 变量、作用域

- JS中无{}块作用域，只有函数结构function封住一个作用域。
- 局部变量/全局变量。不同作用域中如都定义了同一个名字的变量，有一个查找作用域链---从内到外(如本层(层指的是function)有直接使用，如无依次向外层查找)
- 如变量未定义直接使用会提示引用错误，但可先使用再定义变量，但会导致变量声明提升问题undefined---JS解释器解释代码时，会将所有变量定义的过程提升到作用域代码最前面，相当于先定义了，但未赋值，默认undefined。



# 闭包

这个必考。。。

## 说明

- 函数就是闭包。
- 函数是一种对象型数据，对象型数据创建时有一个数据原型，如果将一个对象型数据赋值给变量，则变量中存的不是原型，而是指针/地址
- 如果将一个变量赋值给另一个变量，相当于将地址复制一份给另一个变量
- 每一个通过function定义的函数都是一个新的闭包

## 示例

示例一：

```javascript
function fo(){
  var i = 0;
  return function(n){
    console.log(n+ i++);
  }
}
var f = fo();
f(20);
fo()(20);
fo()(10);
f(10);
```

结果：

```javascript
20   //n=20,i=0,n+i=20,i++后得1，输出20
20	 //创建新闭包，结果同上
10	 //同理
11	 //由于前f(20);影响，i为1，第二次执行f();则为11，I、i++后得3
```

示例二：

```javascript
var arr1 = [4,5,6,7];
var arr2 = arr1;
arr2[0] = 8;
arr1.push(arr1.shift());
console.log(arr1);
console.log(arr2);
```

说明：

- 数组也是对象型数据，存储给变量时，给的是指向数据原型的地址。
- shift();
- push();

结果：

```javascript
[5.6,7,8]	//arr2[0]=8;    #[8,5,6,7]
[5,6,7,8]	//arr1.push(arr1.shift());	#[5,6,7,8]
```



# 参考

- [You-Dont-Know-JS:: Up & Going](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md)



待续。