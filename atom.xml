<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lvbin&#39;s Blog</title>
  
  <subtitle>甲丐内美吕</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://binlv.top/"/>
  <updated>2018-03-31T08:31:10.114Z</updated>
  <id>http://binlv.top/</id>
  
  <author>
    <name>吕滨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【翻译】MDN：transform-function</title>
    <link href="http://binlv.top/2018/03/21/20180321-MDN%EF%BC%9Atransform-function/"/>
    <id>http://binlv.top/2018/03/21/20180321-MDN：transform-function/</id>
    <published>2018-03-21T05:50:33.000Z</published>
    <updated>2018-03-31T08:31:10.114Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function" target="_blank" rel="external">MDN : transform-function</a></p><p><strong>transform-function</strong>用于对元素的显示做变换。通常，这种变换可以由矩阵表示，并且可以使用每个点上的矩阵乘法来确定所得到的图像。</p><p>以下为3D图像关于各种转换函数的定义。</p><a id="more"></a><h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective()"></a>perspective()</h3><p> <code>perspective()</code> 这个CSS函数定义了 z=0平面与用户之间的距离，以便给三维定位元素一定透视度。当每个3D元素的z&gt;0时会显得比较大，而在z&lt;0时会显得比较小。其影响的程度由这个属性的值来决定。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">perspective</span>(<span class="selector-tag">l</span>)</div></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>l</p><p>该参数是一个 <code>length</code>， 给定从用户（显示屏）到z = 0平面的距离。 它用于将透视转换(3D)应用于元素。 如果它是0或负值，则不应用3D变换。</p></li></ul><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-rotate_19.5.png" alt="rotate()"> <code>rotate()</code> 这个CSS 函数 定义一个旋转属性，将元素在不变形的情况下旋转到不动点周围( <code>transform-origin</code>属性指定) 。 移动量由指定角度定义；如果为正值，则运动将为顺时针，如果为负值，则为逆时针 。 180°的旋转称为点反射 (<em>point reflection</em>)。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">rotate</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 <code>angle</code>， 代表旋转的角度。正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotate3d"><a href="#rotate3d" class="headerlink" title="rotate3d()"></a>rotate3d()</h3><p> <code>rotate3d()</code> 这个CSS 函数定义一个3D旋转功能，该旋转使元素能够绕固定轴移动而不变形。 其中移动量由指定角度定义；如果为正值，则运动将为顺时针，如果为负值，则为逆时针。</p><p>在三维空间中，旋转有三个自由度，各表示某条旋转轴。 旋转轴由[x，y，z]向量定义，且过原点（由 <code>transform-origin</code> CSS属性定义）。 如果向量没有标准化，即它的三个坐标的平方之和不是1，它将在内部被标准化。 不可标准化的向量，如空向量[0,0,0]，将导致旋转不被应用，但不会影响整个CSS属性。</p><p>注意：相对于平面上的旋转，三维旋转的组成通常不是可交换位置顺序的，这意味着旋转的应用顺序是至关重要的。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">rotate3d</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>, <span class="selector-tag">z</span>, <span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>x</em></p><p>该参数为”<code>number</code>“ 类型值， 描述旋转轴向量的x坐标 。</p></li><li><p><em>y</em></p><p>该参数为 “<code>number</code>“ 类型值，描述旋转轴向量的y坐标。</p></li><li><p><em>z</em></p><p>该参数为 “<code>number</code>“ 类型值，描述旋转轴向量的z坐标。</p></li><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度 。 正角度表示顺时针旋转，负角度表示逆时针旋转 。</p></li></ul><h3 id="rotateX"><a href="#rotateX" class="headerlink" title="rotateX()"></a>rotateX()</h3><p> <code>rotateX()</code> 这个CSS 函数定义了将元素在横坐标上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。.</p><p><code>rotateX(a)</code>是 <code>rotate3D(1, 0, 0, a)</code>的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">rotateX</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“， 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotateY"><a href="#rotateY" class="headerlink" title="rotateY()"></a>rotateY()</h3><p> <code>rotateY()</code> 这个CSS 函数定义了将元素在纵坐标上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。</p><p><code>rotateY(a)</code> 是 <code>rotate3D(0, 1, 0, a)</code> 的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">rotateY</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="rotateZ"><a href="#rotateZ" class="headerlink" title="rotateZ()"></a>rotateZ()</h3><p> <code>rotateZ()</code>这个CSS 函数定义了将元素在z轴上旋转而不使其变形的方法。 其运动的程度由指定的角度来定义；如果是正的，则为顺时针旋转，如果是负的，则是逆时针旋转。</p><p>旋转所经过的原点，由 <code>transform-origin</code> CSS属性定义。</p><p><code>rotateZ(a)</code>是 <code>rotate3D(0, 0, 1, a)</code> 的简写形式。</p><p>注意： 与平面上的旋转相反，3D旋转的组成通常也是不可交换顺序的；这意味着旋转的应用顺序至关重要。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">rotateZ</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为 “<code>angle</code>“ 代表旋转的角度， 正角表示顺时针旋转，负角表示逆时针旋转。</p></li></ul><h3 id="scale"><a href="#scale" class="headerlink" title="scale()"></a><code>scale()</code></h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scale_2_2.png" alt="scale()"></p><p>The <code>scale()</code> CSS 函数可改变元素的大小。 它可以增大或减小元素的大小，并且缩放量由矢量定义，并且它可以使在一个方向上比另一个方向更多。</p><p>这种变换的特点是矢量的坐标可定义在每个不同方向上各子完成一定比例缩放。如果矢量的两个坐标相等，则缩放是均匀的或各向同性的，并且元素的形状被保留。在这种情况下，缩放函数定义了一个同调变换。</p><p>当超出 <code>[-1, 1]</code>范围外时，缩放将在坐标方向上放大元素；当在该范围内时，它在该方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。</p><p>注意： <code>scale()</code> 函数仅在欧几里德平面(2D)中应用转换。要在空间中进行缩放，必须使用 <code>scale3D()</code> 函数。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scale</span>(<span class="selector-tag">sx</span>) 或</div><div class="line"><span class="selector-tag">scale</span>(<span class="selector-tag">sx</span>, <span class="selector-tag">sy</span>)</div></pre></td></tr></table></figure><h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>sx</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的横坐标。</p></li><li><p><strong>sy</strong></p><p>该参数为 “<code>number</code>“ 类型值，代表缩放矢量的纵坐标 。 如果不存在，则其默认值为 <strong>sx</strong>，从而导致保持元素形状进行均匀缩放。</p></li></ul><h3 id="scale3d"><a href="#scale3d" class="headerlink" title="scale3d()"></a><code>scale3d()</code></h3><p> <code>scale3d()</code> CSS 函数可改变元素的大小。由于缩放的量由矢量定义，因此可以改变不同方向的尺寸。</p><p>这种变换的特点是矢量的坐标定义在每个方向上完成多少缩放。如果矢量的三个坐标都相等，则缩放是均匀的或各向同性的，并且保持元素形状。在这种情况下，这个缩放函数就是定义了一个同调变换。</p><p>当超出[-1，1]的范围之外时，缩放比例将在坐标方向上放大元素；当在[-1，1]范围内时，它在当前方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scale3d</span>(<span class="selector-tag">sx</span>, <span class="selector-tag">sy</span>, <span class="selector-tag">sz</span>)</div></pre></td></tr></table></figure><h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>sx</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的横坐标。</p></li><li><p><em>sy</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的纵坐标。</p></li><li><p><em>sz</em></p><p>该参数为 “<code>number</code>“ 类型值， 代表缩放矢量的z轴坐标。</p></li></ul><h3 id="scaleX"><a href="#scaleX" class="headerlink" title="scaleX()"></a>scaleX()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scaleX_2.png" alt="scaleX()"> <code>scaleX()</code> 这个CSS函数是用一个常数因子来修改每个单元点的横坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度也不守恒。</p><p><code>scaleX(sx)</code> 是 <code>scale(sx, 1)</code> 和 <code>scale3d(sx, 1, 1)</code> 的简写形式。</p><p><code>scaleX(-1)</code> 表示通过原点的垂直轴定义轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scaleX</span>(<span class="selector-tag">s</span>)</div></pre></td></tr></table></figure><h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值， 表示在元素的每个点的横坐标上应用的缩放因子。</p></li></ul><h3 id="scaleY"><a href="#scaleY" class="headerlink" title="scaleY()"></a>scaleY()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-scaleY_2.png" alt="scaleY()"></p><p> <code>scaleY()</code> 这个 CSS函数用一个常数因子修改每个元素点的纵坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度不守恒。</p><p><code>scaleY(sy)</code> 是 <code>scale(1, sy)</code> 和 <code>scale3d(1, sy, 1)</code> 的简写形式。</p><p><code>scaleY(-1)</code> 定义了通过原点的水平轴的轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scaleY</span>(<span class="selector-tag">s</span>)</div></pre></td></tr></table></figure><h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值，表示在元素的每个点的纵坐标上应用的缩放因子。</p></li></ul><h3 id="scaleZ"><a href="#scaleZ" class="headerlink" title="scaleZ()"></a>scaleZ()</h3><p> <code>scaleZ()</code> 这个CSS函数是用一个常数因子来修改每个单元点的z轴坐标，在比例因子是1的情况下该函数是恒等变换。 缩放不是各向同性的，元素的角度也不守恒。</p><p><code>scaleZ(sz)</code> 是 <code>scale3d(1, 1, sz)</code> 的简写形式。</p><p><code>scaleZ(-1)</code> 定义了通过原点的z轴的轴对称（由 <code>transform-origin</code> 属性指定）。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">scaleZ</span>(<span class="selector-tag">s</span>)</div></pre></td></tr></table></figure><h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>s</em></p><p>该参数为 “<code>number</code>“ 类型值，表示在元素的每个点的z轴坐标上应用的缩放因子。</p></li></ul><h3 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h3><p> <code>skew()</code> 这个CSS函数是一种用于拉伸，或者说是平移，该函数会使得在每个方向上扭曲元素上的每个点以一定角度。这是通过将每个坐标增加一个与指定角度成比例的值和到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">skew</span>(<span class="selector-tag">ax</span>)       或</div><div class="line"><span class="selector-tag">skew</span>(<span class="selector-tag">ax</span>, <span class="selector-tag">ay</span>)</div></pre></td></tr></table></figure><h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>ax</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿着横坐标扭曲元素的角度 。</p></li><li><p><em>ay</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿纵坐标扭曲元素的角度 。</p></li></ul><h3 id="skewX"><a href="#skewX" class="headerlink" title="skewX()"></a>skewX()</h3><p> <code>skewX()</code> 这个CSS函数是用于水平拉伸，它将元素的每个点在水平方向上扭曲一定角度。这是通过将横坐标增加一个与指定角度成比例的值以及到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">skewX</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为一个角度 “<code>angle</code>“ ， 表示用于沿着横坐标扭曲元素的角度。</p></li></ul><h3 id="skewY"><a href="#skewY" class="headerlink" title="skewY()"></a>skewY()</h3><p> <code>skewY()</code> 这个CSS函数是用于垂直拉伸，它将元素的每个点在垂直方向上扭曲一定角度。这是通过将纵坐标增加一个与指定角度成比例的值以及到原点的距离来完成的。离原点越远，拉伸的值就越大。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">skewY</span>(<span class="selector-tag">a</span>)</div></pre></td></tr></table></figure><h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>a</em></p><p>该参数为一个角度 “<code>angle</code>“ ，表示用于沿着纵坐标扭曲元素的角度。</p></li></ul><h3 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translate_2.png" alt="translate()"> <code>translate()</code> 这个CSS 函数用于移动元素在平面上的位置。这种变换的特点是矢量的坐标定义了它在每个方向上的移动量。</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">translate</span>(<span class="selector-tag">tx</span>)       或</div><div class="line"><span class="selector-tag">translate</span>(<span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>)</div></pre></td></tr></table></figure><h4 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>tx</em></p><p>该参数为 “<code>length</code>“ ，表示要移动矢量的横坐标。</p></li><li><p><em>ty</em></p><p>该参数为 “<code>length</code>“ ，表示要移动矢量的纵坐标。 如果不写，则默认与 <strong>tx </strong>值相等，例如 :  <code>translate(2)</code> 表示 <code>translate(2, 2)</code>。</p></li></ul><h3 id="translate3d"><a href="#translate3d" class="headerlink" title="translate3d()"></a>translate3d()</h3><p> <code>translate3d()</code> 这个CSS 函数用于移动元素在3D空间中的位置。 这种变换的特点是三维矢量的坐标定义了它在每个方向上的移动量。</p><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">translate3d</span>(<span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>, <span class="selector-tag">tz</span>)</div></pre></td></tr></table></figure><h4 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>tx</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的横坐标。</p></li><li><p><em>ty</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的纵坐标。</p></li><li><p><em>tz</em></p><p>该参数为 “<code>length</code>“ 代表移动矢量的z轴坐标。 该值不能使用百分比 “<code>percentage</code>“ ；如果使用会被认为是无效属性。</p></li></ul><h3 id="translateX"><a href="#translateX" class="headerlink" title="translateX()"></a><code>translateX()</code></h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translateX_2.png" alt="translateX()"> <code>translateX()</code> 这个CSS 函数用于在平面上水平移动元素。 这个转换的特点是 “<code>length</code>“ 定义了它的水平移动量。</p><p><code>translateX(tx)</code> 是 <code>translate(tx, 0)</code>的简写形式。</p><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">translateX</span>(<span class="selector-tag">t</span>)</div></pre></td></tr></table></figure><h4 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数为 “<code>length</code>“ ，代表移动矢量的横坐标。</p></li></ul><h3 id="translateY"><a href="#translateY" class="headerlink" title="translateY()"></a>translateY()</h3><p><img src="http://olvboulzy.bkt.clouddn.com/20180321-transform-functions-translateY_2.png" alt="translateY()"> <code>translateY()</code> 这个CSS 函数用于在平面上垂直移动元素。 这个转换的特点是通过 “<code>length</code>“ 定义了它的垂直移动量。</p><p><code>translateY(ty)</code> 是 <code>translate(0, ty)</code>的简写形式。</p><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">translateY</span>(<span class="selector-tag">t</span>)</div></pre></td></tr></table></figure><h4 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数为 “<code>length</code>“ 代表移动矢量的横坐标。该参数不能使用百分比 “<code>percentage</code>“ ；如果使用百分比形式，会被认为是无效参数。</p></li></ul><h3 id="translateZ"><a href="#translateZ" class="headerlink" title="translateZ()"></a>translateZ()</h3><p> <code>translateZ()</code> 这个CSS 函数用于3D空间的z轴方向移动元素， 这个转换的特点是通过 “<code>length</code>“ 定义了它的z轴方向移动量。</p><p><code>translateZ(tz)</code> 是 <code>translate3d(0, 0, tz)</code>的简写形式。</p><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">translateZ</span>(<span class="selector-tag">t</span>)</div></pre></td></tr></table></figure><h4 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h4><ul><li><p><em>t</em></p><p>该参数是 “<code>length</code>“ ，代表移动矢量的z轴坐标。</p></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN : transform-function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transform-function&lt;/strong&gt;用于对元素的显示做变换。通常，这种变换可以由矩阵表示，并且可以使用每个点上的矩阵乘法来确定所得到的图像。&lt;/p&gt;
&lt;p&gt;以下为3D图像关于各种转换函数的定义。&lt;/p&gt;
    
    </summary>
    
      <category term="外文翻译" scheme="http://binlv.top/categories/%E5%A4%96%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="CSS" scheme="http://binlv.top/tags/CSS/"/>
    
      <category term="transform" scheme="http://binlv.top/tags/transform/"/>
    
  </entry>
  
  <entry>
    <title>从onmouseover和onmouseenter说起</title>
    <link href="http://binlv.top/2018/03/13/20180313-%E4%BB%8Eonmouseover%E5%92%8Conmouseenter%E8%AF%B4%E8%B5%B7/"/>
    <id>http://binlv.top/2018/03/13/20180313-从onmouseover和onmouseenter说起/</id>
    <published>2018-03-13T10:26:45.000Z</published>
    <updated>2018-03-31T08:29:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>初学JS时，<code>onmouseover</code> 和 <code>onmouseenter</code> 触发几乎一样，但在使用 <code>onmouseover</code> 和 <code>onmouseout</code> 时，发现如果在父级元素上定义事件，鼠标移动到其子元素上也会触发该事件，如下图所示，我在父div上设置<code>mouseover</code>，希望实现鼠标移入div时，其子元素p能显示，然后鼠标移走时，p再消失，类似某宝商品简介效果：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseoverBug.gif?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="onmouseover使用时的一个Bug"></p><p>可以发现当鼠标从div盒子下方移入时，子盒子p会出现鬼畜现象。。。而使用 <code>onmouseenter</code> 和 <code>mouseleave</code> 时不会出现此种现象。</p><p>另外，还有如下神奇的事件：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseenter.gif" alt=""></p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-onmouseover.gif" alt=""></p><a id="more"></a><p>三个div盒子的层级关系为 红div (box1)&gt; 黄div2(box2) &gt; 绿div3 (box3)，当鼠标移入绿div时，使用 <code>mouseover</code>出现的是 box3 box2 box1 ，而使用 <code>mouseenter</code> 时出现的是box1 box2 box3。</p><p>上图的实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</div><div class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">    &lt;style type="text/</span>css<span class="string">"&gt;</span></div><div class="line"><span class="string">          *&#123;</span></div><div class="line"><span class="string">            margin:0;</span></div><div class="line"><span class="string">            padding: 0;</span></div><div class="line"><span class="string">          &#125;</span></div><div class="line"><span class="string">          #box1&#123;</span></div><div class="line"><span class="string">             position:relative;</span></div><div class="line"><span class="string">             width:600px;</span></div><div class="line"><span class="string">             height: 600px;</span></div><div class="line"><span class="string">             background:red;</span></div><div class="line"><span class="string">          &#125;</span></div><div class="line"><span class="string">          #box2&#123;</span></div><div class="line"><span class="string">             position: absolute;</span></div><div class="line"><span class="string">             width:300px;</span></div><div class="line"><span class="string">             height: 300px;</span></div><div class="line"><span class="string">             background:yellow;</span></div><div class="line"><span class="string">          &#125;</span></div><div class="line"><span class="string">          #box3&#123;</span></div><div class="line"><span class="string">             position:absolute;</span></div><div class="line"><span class="string">             width:150px;</span></div><div class="line"><span class="string">             height: 150px;</span></div><div class="line"><span class="string">             background:green;</span></div><div class="line"><span class="string">          &#125;</span></div><div class="line"><span class="string">    &lt;/style&gt;</span></div><div class="line"><span class="string">&lt;/head&gt;</span></div><div class="line"><span class="string">&lt;body&gt;</span></div><div class="line"><span class="string">    &lt;div id="</span>box1<span class="string">"&gt;</span></div><div class="line"><span class="string">         &lt;div id=box2&gt;</span></div><div class="line"><span class="string">                &lt;div id=box3&gt;&lt;/div&gt;</span></div><div class="line"><span class="string">         &lt;/div&gt;</span></div><div class="line"><span class="string">    &lt;/div&gt;</span></div><div class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></div><div class="line"><span class="string">         //获取元素</span></div><div class="line"><span class="string">         var box1 = document.getElementById("</span>box1<span class="string">");</span></div><div class="line"><span class="string">         var box2 = document.getElementById("</span>box2<span class="string">");</span></div><div class="line"><span class="string">         var box3 = document.getElementById("</span>box3<span class="string">");</span></div><div class="line"><span class="string">         box1.onmouseover = function  () &#123;</span></div><div class="line"><span class="string">           console.log("</span>box1<span class="string">");</span></div><div class="line"><span class="string">         &#125;</span></div><div class="line"><span class="string">         box2.onmouseover= function  () &#123;</span></div><div class="line"><span class="string">           console.log("</span>box2<span class="string">");</span></div><div class="line"><span class="string">         &#125;</span></div><div class="line"><span class="string">         box3.onmouseover= function  () &#123;</span></div><div class="line"><span class="string">           console.log("</span>box3<span class="string">");</span></div><div class="line"><span class="string">         &#125;</span></div><div class="line"><span class="string">    &lt;/script&gt;</span></div><div class="line"><span class="string">&lt;/body&gt;</span></div><div class="line"><span class="string">&lt;/html&gt;</span></div></pre></td></tr></table></figure><blockquote><p>注：jQuery中的<code>mouseover</code>和<code>mouseout</code>也有类似现象。</p></blockquote><p>究其原因为 <strong>事件冒泡（event bubbling）</strong>。</p><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>JavaScript与HTML之间的交互是通过 <strong>事件</strong> 实现的。</p><blockquote><p>事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间</p></blockquote><p>而 事件流 就是页面接收事件的顺序。早期 IE 和 Netscape开发团队 提出了两种不同的（几乎相反） 事件流 概念 。IE的事件流是事件冒泡流，而 Netscape 的事件流是事件捕获流。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180313-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="DOM事件流"></p><p>开始时，<code>onmouseenter</code>为IE 独有，其他浏览器并不支持，后来各浏览器才陆续支持该事件。 </p><blockquote><p>Firefox started supporting <code>onmouseenter</code> in version 10 (January 2012) and Chrome started supported it in version 30 (October 2013) </p></blockquote><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>每个元素都有其对应事件处理函数，未定义时事件处理函数一般为 <code>null</code> 。事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p>当某元素达到触发条件时，事件处理函数会从该元素的事件处理函数一直执行到最外层 (根) 的事件处理函数后才算结束（<strong>从内到外</strong>–现象类似冒泡）。</p><blockquote><p>引用 MDN 上 关于 <code>mouseenter</code> 和 <code>mouseover</code> 的说明：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20180312-MDN%E5%85%B3%E4%BA%8Emouseenter%E8%A7%A3%E9%87%8A.png" alt="MDN上关于mouserenter和mouseover的解释"></p></blockquote><p>值得注意的是，事件都属于异步语句，因此与内外层级定义事件处理函数顺序无关，但同一元素定义多个同一事件的事件处理函数，后者会覆盖前者。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获刚好与事件冒泡思想相反，事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。当某元素达到触发条件时，事件处理函数会从最外层 (根) 的事件处理函数一直执行到该元素的事件处理函数后才算结束（<strong>从外到内</strong>–现象类似捕获）。</p><h2 id="DOM-0级-和-DOM-2级"><a href="#DOM-0级-和-DOM-2级" class="headerlink" title="DOM 0级 和 DOM 2级"></a>DOM 0级 和 DOM 2级</h2><h3 id="DOM-0级"><a href="#DOM-0级" class="headerlink" title="DOM 0级"></a>DOM 0级</h3><p>一般以on开头的事件以及jQuery中类似的那些事件都属于DOM 0级的事件，这些事件只有冒泡而无捕获，除<code>onmouerenter</code> 和 <code>onmouseleave</code> 外。</p><h3 id="DOM-2级"><a href="#DOM-2级" class="headerlink" title="DOM 2级"></a>DOM 2级</h3><p>DOM 2级事件的定义一般都使用 <code>addEventListen(事件类型，callBack,Boolean)</code> ，其中 <code>Boolean</code> 为 <code>true</code> 时表捕获阶段，<code>false</code>时为冒泡阶段。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过以上知识也就能解释开始案例中的现象：</p><p> <code>mouseover</code> 和 <code>mouseout</code> 在移动到其子元素上也会触发！</p><p>当鼠标首次移入到 <code>div</code> 的下方时触发了<code>div</code> 的<code>mouseover</code> 事件 ，此时<code>p</code>标签重叠在 <code>div</code> 上，此时 鼠标在 <code>p</code>元素上，触发了 <code>div</code> 的<code>mouseover</code> 事件，当 <code>p</code> 元素 离开 ，鼠标回到 <code>div</code> 上，再次触发 <code>div</code> 的 <code>mouseover</code> 事件，如此循环。</p><p>至于第二个例子的现象，我个人觉得是 <code>mouseenter</code> 遵循的是 <strong>事件捕获</strong>，而  <code>mouseover</code> 遵循的是 <strong>事件冒泡</strong>。</p><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学JS时，&lt;code&gt;onmouseover&lt;/code&gt; 和 &lt;code&gt;onmouseenter&lt;/code&gt; 触发几乎一样，但在使用 &lt;code&gt;onmouseover&lt;/code&gt; 和 &lt;code&gt;onmouseout&lt;/code&gt; 时，发现如果在父级元素上定义事件，鼠标移动到其子元素上也会触发该事件，如下图所示，我在父div上设置&lt;code&gt;mouseover&lt;/code&gt;，希望实现鼠标移入div时，其子元素p能显示，然后鼠标移走时，p再消失，类似某宝商品简介效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://olvboulzy.bkt.clouddn.com/20180312-onmouseoverBug.gif?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10&quot; alt=&quot;onmouseover使用时的一个Bug&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以发现当鼠标从div盒子下方移入时，子盒子p会出现鬼畜现象。。。而使用 &lt;code&gt;onmouseenter&lt;/code&gt; 和 &lt;code&gt;mouseleave&lt;/code&gt; 时不会出现此种现象。&lt;/p&gt;
&lt;p&gt;另外，还有如下神奇的事件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://olvboulzy.bkt.clouddn.com/20180312-onmouseenter.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://olvboulzy.bkt.clouddn.com/20180312-onmouseover.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程开发" scheme="http://binlv.top/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://binlv.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于JS中变量、函数声明提升优先级问题的实验</title>
    <link href="http://binlv.top/2018/03/03/20180302-%E5%85%B3%E4%BA%8EJS%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E9%AA%8C/"/>
    <id>http://binlv.top/2018/03/03/20180302-关于JS中变量、函数声明提升优先级问题的实验/</id>
    <published>2018-03-03T13:54:00.000Z</published>
    <updated>2018-03-03T02:30:51.103Z</updated>
    
    <content type="html"><![CDATA[<p>在复习JS-函数时遇到函数声明提升，回想起之前的变量声明的提升，加上JS无重载一说，若出现同名函数，则后者会覆盖前者。想搞清楚既然变量、函数都能提升，那他们之间的优先级是什么，遂做个小实验验证一下。</p><p>其实我是被自己写的一题给绕晕了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); </div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>变量声明会提升至其作用域的<strong>执行顺序最前</strong>；</li><li>优先级：变量 (全局) 声明 &gt; 函数声明</li></ul><p>验证过程如下：</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="变量声明的提升"><a href="#变量声明的提升" class="headerlink" title="变量声明的提升"></a>变量声明的提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;  </div><div class="line"><span class="comment">//结果为控制台打印 undefined</span></div></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a=<span class="number">100</span>;</div></pre></td></tr></table></figure><p>这就是变量声明提升–JS中，变量的声明会在其作用域内的最先运行。</p><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//结果为控制台打印该函数</span></div></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><h3 id="函数表达式声明"><a href="#函数表达式声明" class="headerlink" title="函数表达式声明"></a>函数表达式声明</h3><p>函数声明提升不适用于函数表达式，但在判断优先级时可作为很强的干扰项，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//结果为控制台打印 undefined</span></div></pre></td></tr></table></figure><p>其实这个就是变量声明的提升。。。等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Chrome 63.0.3239.132 (正式版)  （64位）</li></ul><h2 id="变量声明与函数表达式声明"><a href="#变量声明与函数表达式声明" class="headerlink" title="变量声明与函数表达式声明"></a>变量声明与函数表达式声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span> <span class="comment">//变量声明提升</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//后者覆盖前者</span></div></pre></td></tr></table></figure><h2 id="变量声明与函数声明"><a href="#变量声明与函数声明" class="headerlink" title="变量声明与函数声明"></a>变量声明与函数声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//函数声明提升</span></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure><p>代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;<span class="comment">//变量声明提升</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;<span class="comment">//函数声明提升</span></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>这里有个疑问，到底是var a;变量声明提升在前，还是function a 函数声明在前。验证了一下，不管谁在前，运行结果都一样。</p><p>个人开始认为应该是 变量 (全局) 声明在前，函数声明提升在后，后者覆盖前者，所以第一个 <code>console.log(a);</code> 打印函数a。</p><p><strong>验证：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>);</div><div class="line"><span class="comment">//控制台打印出window对象</span></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/20180302-102320.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt=""></p><p>后查阅<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="external">《You Don’t Know JS:Scope &amp; Closures》</a>的第四章关于声明提升的说法是，<code>function</code> 声明 优先于 <code>var</code> 声明，尽管 <code>var</code> 写在前，但 <code>function</code> 声明优先，<code>var</code> 声明被忽略了。</p><p>被忽略了？？</p><p>emmmm…</p><p>这或许是要看JS引擎源码才能知道答案吧…</p><p>所以，</p><p><strong>开头那题的答案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a () &#123;console.log("a")&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;</span></div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="external">MDN关于函数的讲解</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="external">You-Dont Know-JS:Scope &amp; Closures—Chapter 4: Hoisting</a></li><li><a href="https://www.cnblogs.com/oxiaojiano/p/7918967.html" target="_blank" rel="external">cnblogs上一篇关于优先级问题的文章</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在复习JS-函数时遇到函数声明提升，回想起之前的变量声明的提升，加上JS无重载一说，若出现同名函数，则后者会覆盖前者。想搞清楚既然变量、函数都能提升，那他们之间的优先级是什么，遂做个小实验验证一下。&lt;/p&gt;
&lt;p&gt;其实我是被自己写的一题给绕晕了&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;aa&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;变量声明会提升至其作用域的&lt;strong&gt;执行顺序最前&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;优先级：变量 (全局) 声明 &amp;gt; 函数声明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="编程开发" scheme="http://binlv.top/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://binlv.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo同步源文件至GitHub</title>
    <link href="http://binlv.top/2018/02/26/20180226-Hexo%E5%90%8C%E6%AD%A5%E6%BA%90%E6%96%87%E4%BB%B6%E8%87%B3GitHub/"/>
    <id>http://binlv.top/2018/02/26/20180226-Hexo同步源文件至GitHub/</id>
    <published>2018-02-26T09:00:34.000Z</published>
    <updated>2018-02-26T12:05:17.043Z</updated>
    
    <content type="html"><![CDATA[<p>以前用Hexo最大的痛点就是想在其他电脑上写文章然后更新站点很麻烦，或者换系统后发现忘记备份源文件，然后以前写的东西又得通过各种方法找回再重新部署。没办法，静态站点就是这样。</p><p>此时程序员思维就出现了，能不能在我每次写完新文章后自动备份源文件，或者我在<code>hexo d</code>的时候一起把我的<code>.md</code>文件也deploy上去。</p><p>当然，方法各种，这里我直接使用 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a> 这个小插件的功能，相对简单些。</p><a id="more"></a><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>直接一句话搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>当然，作者说如果想使用最新版，可用下面的命令：</p><ul><li>对于npm版本低于4的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm install git+git@github.com:hexojs/hexo-deployer-git.git --save</span></div></pre></td></tr></table></figure><ul><li>对于npm版本低于5的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm install git+ssh://git@github.com:hexojs/hexo-deployer-git.git --save</span></div></pre></td></tr></table></figure><blockquote><p>查看自己npm版本的命令：<code>npm --version</code></p></blockquote><p>其实如果你原先就是将hexo部署在GitHub Pages，那这个插件是已经安装过了，只需要进行相关配置就行。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>修改hexo根目录下的<code>_config.yml</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> _config.yaml</span></div><div class="line">deploy:</div><div class="line">  - type: git</div><div class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</div><div class="line">    branch: master</div><div class="line">  - type: git</div><div class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</div><div class="line">    branch: src</div><div class="line">    extend_dirs: /</div><div class="line">    ignore_hidden: false</div><div class="line">    ignore_pattern:</div><div class="line">        public: .</div></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>第一个master分支是你静态页面所在分支，也就是<code>hexo g</code>后生成的<code>public</code>文件夹中的内容</li><li>第二个src分支就是备份你源文件的，具体参数请参考原作者写的</li></ul><p>如此之后，在每次<code>hexo d</code>后就能将你的源文件备份至<code>src</code>分支，没有更爽。</p><p>当然，安装后每次 deploy 会比原来稍慢点。</p><p>还有，未配置过<code>git user</code>信息的会提示要配置user.mail和user.name：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.email "you@example.com"</div><div class="line">git config --global user.name "Your Name"</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git 的GitHub地址</a> </li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">Hexo官方关于deployment的说明</a></li><li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">知乎上关于换电脑后hexo该怎么更新的回答</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前用Hexo最大的痛点就是想在其他电脑上写文章然后更新站点很麻烦，或者换系统后发现忘记备份源文件，然后以前写的东西又得通过各种方法找回再重新部署。没办法，静态站点就是这样。&lt;/p&gt;
&lt;p&gt;此时程序员思维就出现了，能不能在我每次写完新文章后自动备份源文件，或者我在&lt;code&gt;hexo d&lt;/code&gt;的时候一起把我的&lt;code&gt;.md&lt;/code&gt;文件也deploy上去。&lt;/p&gt;
&lt;p&gt;当然，方法各种，这里我直接使用 &lt;a href=&quot;https://github.com/hexojs/hexo-deployer-git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-deployer-git&lt;/a&gt; 这个小插件的功能，相对简单些。&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://binlv.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="Hexo" scheme="http://binlv.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JS笔试基础知识点</title>
    <link href="http://binlv.top/2018/01/18/20180118-JS%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://binlv.top/2018/01/18/20180118-JS面试基础知识点/</id>
    <published>2018-01-18T12:20:00.000Z</published>
    <updated>2018-01-25T03:07:45.703Z</updated>
    
    <content type="html"><![CDATA[<p>听公开课讲得一些JS笔试中容易出现的知识点。</p><p>与其说是知识点，不如说是—“那些年走过的JS大坑”</p><p>一般关于JS的笔试会走两极端—-要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）</p><a id="more"></a><h1 id="字面量相关"><a href="#字面量相关" class="headerlink" title="字面量相关"></a>字面量相关</h1><p>定义：计算机能识别类型的数据。</p><h2 id="特殊字面量"><a href="#特殊字面量" class="headerlink" title="特殊字面量"></a>特殊字面量</h2><p>顾名思义，计算机识别不了的—NaN，指的不是一个正常的数。</p><h2 id="常见考察点"><a href="#常见考察点" class="headerlink" title="常见考察点"></a>常见考察点</h2><ul><li>正数/0=正无穷Infinity</li><li>0/0=NaN</li><li>parseInt(“string”); 将字符串转为整数的数字类型，条件：纯数字字符串或数字开头字符串，其他为NaN</li><li>数据类型参与数值运算：<ul><li>”数据类型—数字、字符串、undefined、布尔、null”；</li><li>”数学运算— + - * / %”。</li><li>非数字参与数学运算会把非数字转换（<strong>隐式转换</strong>）为数字再参与运算。除null、false转换为0，数字字符串转为数字，其余包括undefined为NaN</li></ul></li></ul><h1 id="各种运算符"><a href="#各种运算符" class="headerlink" title="各种运算符"></a>各种运算符</h1><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><ul><li><code>==</code> 相等  <code>===</code>全等于，即除判断值是否相等，还要判断数据类型，如<code>1</code>和<code>true</code>。<code>!=</code> 不相等（与<code>==</code>相反）</li><li>比较运算的结果就是布尔值，<code>true</code>/<code>false</code></li><li>其他数据参与比较运算时，也会隐式转换为数字参与运算</li><li><code>NaN</code>参与的话，无论与谁都是不等于<code>false</code></li><li><code>IsNaN()</code>方法，判断一个数是否能转为<code>NaN</code>，能<code>true</code>，否<code>false</code>，能转的有：非数字字符串、<code>undefined</code></li></ul><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>上面说到了比较运算符 <code>==</code> 和<code>===</code>，下面总结一下与等式(包括<code>==</code>, <code>===</code>, <code>!=</code>, 和 <code>!==</code>)相关的东西。</p><p>首先说下<code>==</code>和<code>===</code>的区别，<code>==</code>只检查<strong>值(value)</strong>是否相同，而<code>===</code>不仅比较<strong>值(value)</strong>还要检查<strong>数据类型(type)</strong>是否相同，所以<code>==</code>又叫做<strong>松等于(loose-equality)</strong> ，<code>===</code>又叫做<strong>严格等于(strict-equality)</strong>。</p><blockquote><p><strong>注1：</strong>在比较时，若比较两端非<code>number</code>类型，则会自动转换为<code>number</code>类型再进行比较。</p><p><strong>注2：</strong>如果比较两个非原始值，比如对象<code>object</code>（包括函数<code>function</code>和数组<code>array</code>）。因为这些值实际上是通过引用保存的，所以<code>==</code>和<code>===</code>比较都只是检查引用是否匹配，而不是基本值。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"42"</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">42</span>;</div><div class="line"></div><div class="line">a == b;<span class="comment">// true</span></div><div class="line">a === b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> c = <span class="string">"1,2,3"</span>;</div><div class="line"></div><div class="line">a == c;<span class="comment">// true</span></div><div class="line">b == c;<span class="comment">// true</span></div><div class="line">a == b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>这时候就有一个问题，什么时候使用<code>==</code>，什么时候使用<code>===</code>呢？有如下几个基本规则：</p><ul><li>如果比较两端值的类型是<code>boolean</code>类型，<code>true/false</code>，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>如果比较两端的值是些特别的值(<code>0</code>, <code>&quot;&quot;</code>, or <code>[]</code> – empty array)，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>其他都用<code>==</code>吧</li></ul><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><p>有等式当然就有不等式，有<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, 和 <code>&gt;=</code>四种不等式。一般用于比较<code>number</code>类型，但在JavaScript中<code>string</code>值也能被比较。</p><blockquote><p><strong>注：</strong>这里没有严格不等式。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">41</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"42"</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="string">"43"</span>;</div><div class="line"></div><div class="line">a &lt; b;<span class="comment">// true</span></div><div class="line">b &lt; c;<span class="comment">// true</span></div></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"foo"</span>;</div><div class="line"></div><div class="line">a &lt; b;<span class="comment">// false</span></div><div class="line">a &gt; b;<span class="comment">// false</span></div><div class="line">a == b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>例子二中 b值的类型是<code>string</code>，在参与不等式比较时，会强制转换为<code>NaN</code>，而<code>NaN</code>和谁都不相等，包括和它自己。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 +="></a>赋值运算符 +=</h2><ul><li>必须有变量参与运算</li><li>特殊：++递加- -递减，变量出现一次叫做使用一次。可为a++或++a</li></ul><h2 id="逻辑运算符-amp-amp-、-、"><a href="#逻辑运算符-amp-amp-、-、" class="headerlink" title="逻辑运算符 &amp;&amp; 、||、!"></a>逻辑运算符 &amp;&amp; 、||、!</h2><ul><li>规律：逻辑与和逻辑或，答案都与第一个操作数a能够判读为true/false有关，如判断为假的有—null、undefined、0、NaN、” ” 空字符串；判断为真—非0非NaN数字、非空字符串</li><li>与运算&amp;&amp;：a&amp;&amp;b，如果a为true，则结果就是b；如果a为false，则为false</li><li>逻辑或||：a||b，如果a为true，结果就是true；如果a为false，则结果为b</li><li>逻辑非：</li></ul><h2 id="Truthy-amp-Falsy"><a href="#Truthy-amp-Falsy" class="headerlink" title="Truthy &amp; Falsy"></a>Truthy &amp; Falsy</h2><p>总结一下一些奇葩的<code>boolean</code>类型，一般性的布尔值没什么好说的。特别提下一些会被判断为truthy和falsy。</p><p>一些特别的”falsy”如下：</p><ul><li><code>&quot;&quot;</code> (empty string)</li><li><code>0</code>，<code>-0</code>，<code>NaN</code> (invalid number)</li><li><code>null</code>,<code>undefined</code></li><li><code>false</code></li></ul><p>一些特别的“truthy”如下:</p><ul><li><code>&quot;hello&quot;</code></li><li><code>42</code></li><li><code>true</code></li><li><code>[ ]</code>, <code>[ 1, &quot;2&quot;, 3 ]</code> (arrays)</li><li><code>{ }</code>, <code>{ a: 42 }</code> (objects)</li><li><code>function foo() { .. }</code> (functions)</li></ul><h2 id="三元运算符—"><a href="#三元运算符—" class="headerlink" title="三元运算符— ? :"></a>三元运算符— ? :</h2><p>或作为条件分支语句</p><p>​         Boolean_expression? true_value : false_value;</p><h1 id="变量、作用域"><a href="#变量、作用域" class="headerlink" title="变量、作用域"></a>变量、作用域</h1><ul><li>JS中无{}块作用域，只有函数结构function封住一个作用域。</li><li>局部变量/全局变量。不同作用域中如都定义了同一个名字的变量，有一个查找作用域链—从内到外(如本层(层指的是function)有直接使用，如无依次向外层查找)</li><li>如变量未定义直接使用会提示引用错误，但可先使用再定义变量，但会导致变量声明提升问题undefined—JS解释器解释代码时，会将所有变量定义的过程提升到作用域代码最前面，相当于先定义了，但未赋值，默认undefined。</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>这个必考。。。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>函数就是闭包。</li><li>函数是一种对象型数据，对象型数据创建时有一个数据原型，如果将一个对象型数据赋值给变量，则变量中存的不是原型，而是指针/地址</li><li>如果将一个变量赋值给另一个变量，相当于将地址复制一份给另一个变量</li><li>每一个通过function定义的函数都是一个新的闭包</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(n+ i++);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = fo();</div><div class="line">f(<span class="number">20</span>);</div><div class="line">fo()(<span class="number">20</span>);</div><div class="line">fo()(<span class="number">10</span>);</div><div class="line">f(<span class="number">10</span>);</div></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span>   <span class="comment">//n=20,i=0,n+i=20,i++后得1，输出20</span></div><div class="line"><span class="number">20</span> <span class="comment">//创建新闭包，结果同上</span></div><div class="line"><span class="number">10</span> <span class="comment">//同理</span></div><div class="line"><span class="number">11</span> <span class="comment">//由于前f(20);影响，i为1，第二次执行f();则为11，I、i++后得3</span></div></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr1;</div><div class="line">arr2[<span class="number">0</span>] = <span class="number">8</span>;</div><div class="line">arr1.push(arr1.shift());</div><div class="line"><span class="built_in">console</span>.log(arr1);</div><div class="line"><span class="built_in">console</span>.log(arr2);</div></pre></td></tr></table></figure><p>说明：</p><ul><li>数组也是对象型数据，存储给变量时，给的是指向数据原型的地址。</li><li>shift();</li><li>push();</li></ul><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">5.6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr2[0]=8;    #[8,5,6,7]</span></div><div class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr1.push(arr1.shift());#[5,6,7,8]</span></div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md" target="_blank" rel="external">You-Dont-Know-JS:: Up &amp; Going</a></li></ul><p>待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听公开课讲得一些JS笔试中容易出现的知识点。&lt;/p&gt;
&lt;p&gt;与其说是知识点，不如说是—“那些年走过的JS大坑”&lt;/p&gt;
&lt;p&gt;一般关于JS的笔试会走两极端—-要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）&lt;/p&gt;
    
    </summary>
    
      <category term="编程开发" scheme="http://binlv.top/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="面筋" scheme="http://binlv.top/tags/%E9%9D%A2%E7%AD%8B/"/>
    
      <category term="JavaScript" scheme="http://binlv.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>RHEL7.0日志分析记录</title>
    <link href="http://binlv.top/2017/12/20/20171220-RHEL7.0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <id>http://binlv.top/2017/12/20/20171220-RHEL7.0日志分析记录/</id>
    <published>2017-12-20T00:20:00.000Z</published>
    <updated>2017-12-21T06:03:29.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一个客户服务老挂，检查服务器，无法ping通且登录界面黑屏，只能强行重启，尝试检查日志发现默认日志为重启删除，坑。</p><a id="more"></a><p><strong>服务器信息</strong></p><ul><li>Red Hat Enterprise Linux Server release 7.0 (Maipo)</li></ul><h1 id="日志相关回顾"><a href="#日志相关回顾" class="headerlink" title="日志相关回顾"></a>日志相关回顾</h1><p>一般位置：<code>/var/log</code></p><h2 id="常见日志："><a href="#常见日志：" class="headerlink" title="常见日志："></a>常见日志：</h2><ul><li><p>/var/log/boot.log</p><p>顾名思义，系统启动日志，仅保留本次开机</p></li><li><p>/var/log/cron</p><p>所有<code>crontab</code>计划任务日志</p></li><li><p>/var/log/lastlog</p><p>记录系统所有账号最后登录信息</p></li></ul><ul><li><p>/var/log/maillog &amp;  /var/log/mail/*</p><p>往来邮件日志记录</p></li><li><p>/var/log/messages</p><p>系统重要信息基本都在这，为必看日志</p></li><li><p>/var/log/secure</p><p>凡是需要账号密码的日志都在里面</p></li></ul><h2 id="主要进程服务-daemon"><a href="#主要进程服务-daemon" class="headerlink" title="主要进程服务(daemon)"></a>主要进程服务(daemon)</h2><ul><li>systemd-journald.service  7系列版本新增，默认存在内存中，重启即失效，本次日志分析主要用的</li><li>rsyslog.service 记录系统和网络的信息，配置文件<code>/etc/rsyslog.conf</code></li><li>logrotate 用于日志自动化处理的服务，配置文件<code>/etc/logrotate.conf</code></li></ul><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><ul><li>debug </li><li>info</li><li>notice</li><li>warning(warn) </li><li>err(error)  重大错误信息</li><li>crit</li><li>alert</li><li>emerg(panic)</li></ul><blockquote><p>注：在讯息等级之前还有.[=!] 的连结符号，代表的意思是这样的：</p><ul><li>.：代表『比后面还要严重的等级(含该等级)都被记录下来』的意思，例如： mail.info代表只要是mail的资讯，而且该资讯等级严重于info (含info本身)时，就会被记录下来的意思。</li><li>.=：代表所需要的等级就是后面接的等级而已，其他的不要！</li><li>.!：有点反向选择的感觉，代表忽略大于等于这个等级的讯息！亦即是低于这个等级的才会被纪录的意思！</li></ul></blockquote><h1 id="使用journalctl查看日志"><a href="#使用journalctl查看日志" class="headerlink" title="使用journalctl查看日志"></a>使用journalctl查看日志</h1><h2 id="journalctl命令"><a href="#journalctl命令" class="headerlink" title="journalctl命令"></a>journalctl命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl [-nrpf] [--since TIME] [--until TIME] _optional </span></div><div class="line">选项与参数：</div><div class="line">预设会show出全部的<span class="built_in">log</span> 内容，从旧的输出到最新的日志</div><div class="line">-n ：show出最近的几行的意思～找最新的日志相当有用</div><div class="line">-r ：反向输出，从最新的输出到最旧的资料</div><div class="line">-p ：show出后面所接的日志重要性排序！</div><div class="line">-f ：类似tail -f 的功能，持续显示journal 日志的内容(即时监测时相当有帮助！)</div><div class="line">--since --until：设定开始与结束的时间，让在该期间的资料输出而已</div><div class="line">_SYSTEMD_UNIT=unit.service ：只输出unit.service 的日志而已</div><div class="line">_COMM=bash ：只输出与bash 有关的日志</div><div class="line">_PID=pid ：只输出PID 号码的日志</div><div class="line">_UID=uid ：只输出UID 为uid 的日志</div><div class="line">SYSLOG_FACILITY=[0-23] ：使用syslog.h 规范的服务相对序号来呼叫出正确的资料！</div></pre></td></tr></table></figure><p>例子：</p><p>查看特定优先级日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl -p err</span></div></pre></td></tr></table></figure><p>查看特定时间日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl --since "2017-12-17" --until "2017-12-19"</span></div></pre></td></tr></table></figure><p>显示本次启动后日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl -b [-0/-1/-2] #-0表本次启动信息，-1表上次启动</span></div></pre></td></tr></table></figure><h2 id="永久保存记录办法"><a href="#永久保存记录办法" class="headerlink" title="永久保存记录办法"></a>永久保存记录办法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@binlv ~]<span class="comment"># mkdir /var/log/journal</span></div><div class="line">[root@binlv ~]<span class="comment"># chown root:systemd-journal /var/log/journal/</span></div><div class="line">[root@binlv ~]<span class="comment"># chmod 2755 /var/log/journal/</span></div><div class="line">[root@binlv ~]<span class="comment"># killall -USR1 systemd-journald</span></div></pre></td></tr></table></figure><blockquote><p>注：默认情况下，日志大小不能超过所处文件系统的10%，也不可使所处文件系统空间低于15%。在 /etc/systemd/journald.conf 可进行大小容量上的调节；而在 /etc/logrotate.conf 则定义了那些日志文件记录、怎么记录、记录多少。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.linuxidc.com/Linux/2016-01/127729.htm" target="_blank" rel="external">RHEL7.0日志系统</a></li><li><a href="http://linux.vbird.org/linux_basic/0570syslog.php#whatis_syslog_1" target="_blank" rel="external">鸟哥私房菜之syslog</a></li><li><a href="http://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="external">Systemd 日志系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近一个客户服务老挂，检查服务器，无法ping通且登录界面黑屏，只能强行重启，尝试检查日志发现默认日志为重启删除，坑。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="log" scheme="http://binlv.top/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>NBU catalog报错处理办法</title>
    <link href="http://binlv.top/2017/12/08/20171208-NBU%20catalog%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://binlv.top/2017/12/08/20171208-NBU catalog报错处理办法/</id>
    <published>2017-12-08T04:19:12.000Z</published>
    <updated>2017-12-10T14:19:26.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h1><ul><li><p>环境说明：</p><ul><li>NBU 7.7.3 Master Server</li><li>Windows Server 2008R2 x64操作系统</li></ul></li><li><p>NBU Master Server备份catalog一直报错，错误代码2</p><ul><li><p>status详细信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging relational database files <span class="keyword">for</span> catalog backup</div><div class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:30 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</div><div class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</div><div class="line">none of the requested files were backed up  (2)</div></pre></td></tr></table></figure></li></ul></li><li><p>检查系统进程 已运行700+进程，怀疑进程过多导致Master hang死</p></li></ul><a id="more"></a><h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>根据报错信息，定位<code>C:\Program Files\Veritas\NetBackupDB\staging</code>目录，删除该目录文件，重启服务后手动发起catalog备份，成功。</p><p>第二天再发起再次报错，非长久之计。</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>报case，协助工程师收集cab。</p><p>对于Windows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\windows\system32\chcp 437</div><div class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -use_reg_cmd 64 (<span class="keyword">for</span> 64bit)</div></pre></td></tr></table></figure><p>执行nbsu到network service卡住，询问工程师终止命令，执行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -c -use_reg_cmd 64</div></pre></td></tr></table></figure><p>产生LOG 的路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files\Veritas\netbackup\bin\support\output\nbsu (后缀名是cab)</div></pre></td></tr></table></figure><p>后操作如下</p><ol><li><p>Delete the outstanding nbtelemetry.exe processes in task manager, this in turn stopped the nbtelesched.exe processes. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tasklist</div><div class="line">taskkill /im nbtelemetry.exe /f</div></pre></td></tr></table></figure><p>强制结束进程</p></li><li><p>Once these were deleted, went into directory Program files\Veritas\Netbackup\bin<br>Renamed nbtelemetry.exe and nbtelesched.exe to nbtelemetry.exe.old and nbtelesched.exe.old. </p><p>若无法重命名，重启机器再修改</p></li><li><p>Run regedit and go to the following key<br>HKLM(HKEY_LOCAL_MACHINE)\Software\VERITAS\NetBackup\CurrentVersion\Config\TELEMETRY_UPLOAD<br>Changed TELEMETRY_UPLOAD from YES to NO under the registry editor.</p><p>再次发起catalog备份，正常。</p></li></ol><p>观察几天，进程数不超过100，且备份catalog不报错.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="NBU-catalog"><a href="#NBU-catalog" class="headerlink" title="NBU catalog"></a>NBU catalog</h2><p>NetBackup自身有一索引数据库，主要记录每次备份的相关信息。比如从哪个Client备<br>份的，保留多长时间等。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;环境说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NBU 7.7.3 Master Server&lt;/li&gt;
&lt;li&gt;Windows Server 2008R2 x64操作系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NBU Master Server备份catalog一直报错，错误代码2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;status详细信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging relational database files &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; catalog backup&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:24 - Info bpdbm (pid=12608) &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:24 - Info bpdbm (pid=12608) staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:30 - Info bpdbm (pid=12608) &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBAZDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBAZDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;none of the requested files were backed up  (2)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检查系统进程 已运行700+进程，怀疑进程过多导致Master hang死&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Netbackup" scheme="http://binlv.top/tags/Netbackup/"/>
    
  </entry>
  
  <entry>
    <title>Oracle参数文件</title>
    <link href="http://binlv.top/2017/12/05/20171205-Oracle%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6/"/>
    <id>http://binlv.top/2017/12/05/20171205-Oracle参数文件/</id>
    <published>2017-12-05T14:20:00.000Z</published>
    <updated>2017-12-10T14:21:36.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为平时做数据库恢复需检查pfile文件，对这方面空白较多，查了点资料，详细了解一下。</p><a id="more"></a><h1 id="参数文件类型"><a href="#参数文件类型" class="headerlink" title="参数文件类型"></a>参数文件类型</h1><p>pfile –parameter file 文本文件</p><p>spfile –server parameter file  二进制文件</p><p>9i后才有，通过alter system 修改到spfile 下次启动生效</p><h2 id="pfile"><a href="#pfile" class="headerlink" title="pfile"></a>pfile</h2><p>作用：文件记录数据库配置与功能开启或关闭</p><p>数据库启动时需读取参数文件内容，实例启动后就一直在内存中。</p><p>文件位置：通过dbca图形工具建立数据库，有一个模板参数文件pfile</p><p><code>$ORACLE_BASE/admin/&lt;db_unique_name&gt;/pfile/init.ora.&lt;n+&gt;</code></p><p>修改到参数文件达到时候需要关闭数据库然后才有效</p><p>10g后只有spfile <code>$ORACLE_BASE/dbs/spfile$ORACLE_SID.ora</code></p><p>手工建库没有模板参数文件</p><p>##spfile</p><p>通过pfile文件可以定义spfile=’’路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sql&gt; show parameter spfile</div></pre></td></tr></table></figure><p>数据库读取参数文件顺序</p><ol><li><code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code></li><li><code>ORACLE_HOME/dbs/spfile.ora</code></li><li><code>ORACLE_HOME/dbs/init&lt;SID&gt;.ora</code></li></ol><blockquote><p>注：</p><p>若维护的是RAC，不要执行create pfile from spfile;</p><p>因为若spfile文件丢失，启动一个实例，执行create spfile from pfile;后sfile会存放在<code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code>，再启动一个实例后会想修改参数文件会报错，为非共享文件。</p><p>维护ASM存放参数文件也不能使用create pfile命令</p></blockquote><h1 id="修改参数文件"><a href="#修改参数文件" class="headerlink" title="修改参数文件"></a>修改参数文件</h1><h2 id="修改pfile"><a href="#修改pfile" class="headerlink" title="修改pfile"></a>修改pfile</h2><p>pfile一般修改需要重启数据库才能生效</p><p>startup force</p><h2 id="修改spfile"><a href="#修改spfile" class="headerlink" title="修改spfile"></a>修改spfile</h2><p>参数分类：</p><p>系统参数：alter system set 参数=值 scope=memory|spfile|both [sid=’…’];</p><p>会话参数 alter session set 参数=值;</p><p>系统参数的分类：</p><ol><li>动态 alter system set 参数=值; alter system set 参数=值 scope=memory;</li><li>静态 alter system set 参数=值 scope=spfile;</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为平时做数据库恢复需检查pfile文件，对这方面空白较多，查了点资料，详细了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="pfile" scheme="http://binlv.top/tags/pfile/"/>
    
      <category term="spfile" scheme="http://binlv.top/tags/spfile/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Hexo+SSL搭建个人站点</title>
    <link href="http://binlv.top/2017/11/28/20171128-Nginx-Hexo-SSL%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"/>
    <id>http://binlv.top/2017/11/28/20171128-Nginx-Hexo-SSL搭建个人站点/</id>
    <published>2017-11-28T06:09:02.000Z</published>
    <updated>2018-02-25T13:35:53.226Z</updated>
    
    <content type="html"><![CDATA[<p>给闲置VPS增加点用处系列</p><a id="more"></a><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx相关安装配置参照我的<a href="https://binlv.top/2017/11/27/20171127-部署Nginx服务与基本配置/">上一篇关于Nginx配置的文章</a></p><h1 id="Hexo-部署至Nginx"><a href="#Hexo-部署至Nginx" class="headerlink" title="Hexo 部署至Nginx"></a>Hexo 部署至Nginx</h1><p>一般有三种方法</p><ul><li>git设置git hook方式</li><li>rsync同步本地Hexo至VPS</li><li>VPS上部署Hexo，并执行<code>hexo server</code> ，再配置Nginx反向代理，让域名指向 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></li></ul><h2 id="git-hook方式"><a href="#git-hook方式" class="headerlink" title="git hook方式"></a>git hook方式</h2><h3 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h3><p>安装git并创建仓库，设置git hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-get install git -y</div><div class="line">mkdir &lt;git工作目录&gt; &amp;&amp; <span class="built_in">cd</span> &lt;git工作目录&gt;</div><div class="line">git init --bare</div><div class="line">nano &lt;git工作目录&gt;/hook/post-reveive</div></pre></td></tr></table></figure><p>将以下内容修改好放入<code>post-reveive</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">GIT_REPO=/var/www/blog.git  <span class="comment">#git仓库</span></div><div class="line">TMP_GIT_CLONE=/tmp/blog</div><div class="line">PUBLIC_WWW=/var/www/blog <span class="comment">#网站目录</span></div><div class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></div><div class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></div><div class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></div></pre></td></tr></table></figure><p>或使用如下命令放入<code>post-reveive</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/bin/bash -l</span></div><div class="line">git --work-tree=/var/www/blog --git-dir=/var/www/blog.git checkout -f</div></pre></td></tr></table></figure><p>赋予执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive</div></pre></td></tr></table></figure><h3 id="在本机配置"><a href="#在本机配置" class="headerlink" title="在本机配置"></a>在本机配置</h3><p>在博客目录下运行下面命令，安装 git 部署工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>修改博客的配置文件 _config.yml，修改deploy选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy: </div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: 用户名@服务器地址:/var/www/blog.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure><h1 id="开启站点HTTPS"><a href="#开启站点HTTPS" class="headerlink" title="开启站点HTTPS"></a>开启站点HTTPS</h1><p>https需要授权证书，这里使用的是<a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>家的免费证书。</p><p>对了，要开启HTTPS首先你得有个人域名，因为证书是给域名授权的。至于域名申请，万网之类的都行，然后解析指向你的服务器。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install letsencrypt</div></pre></td></tr></table></figure><p>获取证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">letsencrypt certonly</div></pre></td></tr></table></figure><p>根据提示完成获取，中间需要输入你的域名，最后出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- Congratulations! Your certificate and chain have been saved at</div><div class="line">  /etc/letsencrypt/live/&lt;你的域名&gt;/fullchain.pem. Your cert will</div><div class="line">  expire on 2017-09-17. To obtain a new or tweaked version of this</div><div class="line">  certificate <span class="keyword">in</span> the future, simply run certbot-auto again. To</div><div class="line">  non-interactively renew *all* of your certificates, run</div><div class="line">  <span class="string">"certbot-auto renew"</span></div><div class="line">- If you like Certbot, please consider supporting our work by:</div><div class="line"></div><div class="line">  Donating to ISRG / Let<span class="string">'s Encrypt:   https://letsencrypt.org/donate</span></div><div class="line"><span class="string">  Donating to EFF:                    https://eff.org/donate-le</span></div></pre></td></tr></table></figure><p>  就成功了，看提示，所有的证书文件在 <code>/etc/letsencrypt/live/你的域名</code>下，里面有下面几个文件证书文件，引用别人的解释下：</p><blockquote><ul><li><code>privkey.pem</code></li></ul><p>这是私匙，对应 Nginx 的 ssl_certificate_key 选项，或者 Apache2 的 SSLCertificateKeyFile 选项。</p><ul><li><code>cert.pem</code> </li></ul><p>服务器证书，这个只有 Apache2 低于 2.4.8 版本需要，对应 SSLCertificateFile 选项。</p><ul><li><code>chain.pem</code></li></ul><p>除服务器证书之外的所有证书，对于 1.3.7 版以上的 Nginx 对应 ssl_trusted_certificate 选项，对于低于2.4.8 的 Apache2 对应 SSLCertificateChainFile 选项。</p><ul><li><code>fullchain.pem</code></li></ul><p>包括上面的服务器证书和其他证书, Nginx 对应 ssl_certificate 选项，2.4.8 版以上的 Apache2 对应 SSLCertificateFile 选项。</p><p>如果是 Nginx，需要上面的 privkey.pem（对应 ssl_certificate_key 选项）和 fullchain.pem （对应 ssl_certificate 选项），还需要一个 dhparam.pem（对应 ssl_dhparam 选项） 需自己生成：</p><p>openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</p><p>这个文件创建稍微需要一点时间，注意看我的路径，我的是在 /etc/nginx/ssl/ 下，如果没有ssl这个目录就自己建一个，当然你换其他地方也行。</p></blockquote><p>有了这三个文件: <code>privkey.pem</code>、<code>fullchain.pem</code> 、<code>dhparam.pem</code> 就可以配置 Nginx 了。</p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name binlv.top;</div><div class="line">    <span class="comment">#实现访问http的时候自动跳转到https</span></div><div class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">        listen 443 ssl http2;</div><div class="line">    listen [::]:443 ssl http2;</div><div class="line">    server_name binlv.top;</div><div class="line">    </div><div class="line">    <span class="comment">#不输出 Nginx 版本号及其他错误信息</span></div><div class="line">    server_tokens off;</div><div class="line">    </div><div class="line">    <span class="comment"># 开启 HSTS,这么写是为了提交到 https://hstspreload.org/</span></div><div class="line">        add_header Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains"</span> always;</div><div class="line">        <span class="comment"># 启用 XSS 保护，检查到 XSS 攻击时，停止渲染页面。</span></div><div class="line">    add_header X-XSS-Protection <span class="string">"1; mode=block"</span>;</div><div class="line">    </div><div class="line">        ssl_certificate /etc/letsencrypt/live/binlv.top/fullchain.pem;</div><div class="line">        ssl_certificate_key /etc/letsencrypt/live/binlv.top/privkey.pem;</div><div class="line">        ssl_dhparam /etc/nginx/ssl/dhparam.pem;</div><div class="line">        ssl_session_cache shared:SSL:50m;</div><div class="line">        ssl_session_timeout 1d;</div><div class="line">        ssl_session_tickets off;</div><div class="line">        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers <span class="string">'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'</span>;</div><div class="line">        ssl_prefer_server_ciphers on;</div><div class="line">        ssl_stapling on;</div><div class="line">        ssl_stapling_verify on;</div><div class="line">    </div><div class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></div><div class="line">    location / &#123;</div><div class="line">        root /var/www/blog;</div><div class="line">        index index.php index.htm index.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更新配置后要重启一下Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart nginx</div></pre></td></tr></table></figure></p><h2 id="设置证书自动更新"><a href="#设置证书自动更新" class="headerlink" title="设置证书自动更新"></a>设置证书自动更新</h2><p>Let’s Encrypt SSL 免费证书为短期证书，只有 90 天期限，提示到期前可以运行命令 <code>letsencrypt renew</code> 续期</p><p>实现定时更新证书，我们可以用linux自带的定时器crontab<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab -e</div></pre></td></tr></table></figure></p><p>输入：　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　30 2 1 * * /usr/bin/letsencrypt renew &gt;&gt; /var/<span class="built_in">log</span>/letsencrypt/le-renew.log</div><div class="line">　　35 2 1 * * /usr/bin/systemctl reload nginx</div></pre></td></tr></table></figure></p><h2 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h2><p>如果想把授权的域名取消该怎么办呢？因为免费证书如果不定期更新的话几个月就会自动过期，所以删掉本地部署时对应创建的几个文件就行啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -rf /etc/letsencrypt/live/www.example.com/</div><div class="line">rm -rf /etc/letsencrypt/archive/www.example.com/</div><div class="line">rm /etc/letsencrypt/renewal/www.example.com.conf</div></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>很多。。。</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7" target="_blank" rel="external">CentOS 7配置Nginx+SSL，参考</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="external">git hooks 官方文档</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给闲置VPS增加点用处系列&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://binlv.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://binlv.top/tags/Nginx/"/>
    
      <category term="Hexo" scheme="http://binlv.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>部署Nginx服务与基本配置</title>
    <link href="http://binlv.top/2017/11/27/20171127-%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://binlv.top/2017/11/27/20171127-部署Nginx服务与基本配置/</id>
    <published>2017-11-27T03:01:06.000Z</published>
    <updated>2018-01-24T06:38:22.380Z</updated>
    
    <content type="html"><![CDATA[<p>个人站点原部署在<a href="https://github.com/baylin87/baylin87.github.io" target="_blank" rel="external">GitHub</a>，借助其<a href="https://pages.github.com/" target="_blank" rel="external">GitHub-Pages</a>功能实现免费的个人站点部署。后考虑到VPS资源闲置，加上GitHub-Pages貌似不能用<code>https</code>，就想迁移过去玩玩。</p><p>当然，实现方法有很多，我选的是用Nginx + Hexo部署。</p><a id="more"></a><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul><li>操作系统：Ubuntu 16.04.2 LTS (xenial)</li><li>Nginx version : nginx/1.12.2  built with OpenSSL 1.0.2g</li></ul><h1 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h1><p>Nginx安装与配置。</p><h2 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h2><p>Ubuntu 有对应apt安装包，但需配置。</p><p>1.获取Nginx认证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://nginx.org/keys/nginx_signing.key</div></pre></td></tr></table></figure><p>2.将该key添加到apt中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-key add nginx_signing.key</div></pre></td></tr></table></figure><p>3.添加nginx软件源</p><p>For Ubuntu replace codename with Ubuntu distribution codename, and append the following to the end of the <code>etc/apt/sources.list</code>file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://nginx.org/packages/ubuntu/ xenial nginx</div><div class="line">deb-src http://nginx.org/packages/ubuntu/ xenial nginx</div></pre></td></tr></table></figure><p>4.更新源并安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install nginx</div></pre></td></tr></table></figure><p>5.启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start nginx</div></pre></td></tr></table></figure><p>6.默认nginx配置文件路径</p><p><code>/usr/local/nginx/conf</code>,<code>/etc/nginx</code>, or<code>/usr/local/etc/nginx</code></p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name binlv.top;</div><div class="line"><span class="comment">#实现访问http的时候自动跳转到https</span></div><div class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">        listen 443 ssl http2;</div><div class="line">listen [::]:443 ssl http2;</div><div class="line">server_name binlv.top;</div><div class="line"></div><div class="line"><span class="comment">#不输出 Nginx 版本号及其他错误信息</span></div><div class="line">server_tokens off;</div><div class="line"></div><div class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></div><div class="line">    location / &#123;</div><div class="line">        root &lt;--路径--&gt;;</div><div class="line">        index index.php index.htm index.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart nginx</div></pre></td></tr></table></figure><p>使nginx开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> nginx</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://nginx.org/en/docs/" target="_blank" rel="external">Nginx document</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人站点原部署在&lt;a href=&quot;https://github.com/baylin87/baylin87.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;，借助其&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub-Pages&lt;/a&gt;功能实现免费的个人站点部署。后考虑到VPS资源闲置，加上GitHub-Pages貌似不能用&lt;code&gt;https&lt;/code&gt;，就想迁移过去玩玩。&lt;/p&gt;
&lt;p&gt;当然，实现方法有很多，我选的是用Nginx + Hexo部署。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://binlv.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://binlv.top/2017/10/12/20171012-iptables/"/>
    <id>http://binlv.top/2017/10/12/20171012-iptables/</id>
    <published>2017-10-12T02:20:00.000Z</published>
    <updated>2018-01-24T06:39:45.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables完全控制"><a href="#iptables完全控制" class="headerlink" title="iptables完全控制"></a>iptables完全控制</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>搭建一套企业实际使用的防火墙规则</li><li>防攻击</li><li>数据包转发</li><li>实际使用意义</li></ol><a id="more"></a><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>—Linux用于数据包处理，iptables会调用其使用</p><h2 id="Hook-point"><a href="#Hook-point" class="headerlink" title="Hook point"></a>Hook point</h2><p>—数据包在Netfilter中的挂载点</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-01.png" alt="Netfilter与iptables关系"></p><h2 id="iptables规则组成"><a href="#iptables规则组成" class="headerlink" title="iptables规则组成"></a>iptables规则组成</h2><p><strong>4表5链</strong><br>表：filter、nat、mangle、raw<br>链：INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING</p><p><strong>作用：</strong></p><p>mangle:修改数据包，改变包头内容（TTL、TOS、MARK）<br>raw：数据包状态跟踪分析</p><p>filter：访问控制、规则匹配<br>nat：地址转发</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-02.png" alt="数据包在规则表、链匹配流程"></p><h2 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h2><ol><li>访问控制：ACCEPT、DROP、REJECT</li><li>改写数据包：SNAT、DNAT</li><li>信息记录：LOG</li></ol><h2 id="规则组成"><a href="#规则组成" class="headerlink" title="规则组成"></a>规则组成</h2><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-03.png" alt="iptables规则组成"></p><hr><h1 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -I INPUT -p tcp dprot 80 -j ACCEPT</div></pre></td></tr></table></figure><p>待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables完全控制&quot;&gt;&lt;a href=&quot;#iptables完全控制&quot; class=&quot;headerlink&quot; title=&quot;iptables完全控制&quot;&gt;&lt;/a&gt;iptables完全控制&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;搭建一套企业实际使用的防火墙规则&lt;/li&gt;
&lt;li&gt;防攻击&lt;/li&gt;
&lt;li&gt;数据包转发&lt;/li&gt;
&lt;li&gt;实际使用意义&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="iptables" scheme="http://binlv.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>ansible初步</title>
    <link href="http://binlv.top/2017/09/01/20170901-ansible%E5%88%9D%E6%AD%A5/"/>
    <id>http://binlv.top/2017/09/01/20170901-ansible初步/</id>
    <published>2017-09-01T02:19:12.000Z</published>
    <updated>2017-09-23T01:47:52.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><ul><li>了解ansible能做什么</li><li>了解ansible部署环境</li><li>安装ansible管理主机</li></ul><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.ansible.com/" target="_blank" rel="external">ansible官方</a></li><li><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible的github Project</a></li><li><a href="http://ansible-tran.readthedocs.io" target="_blank" rel="external">ansible中文权威指南</a></li></ul><h1 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h1><h2 id="why-ansible"><a href="#why-ansible" class="headerlink" title="why ansible?"></a>why ansible?</h2><p>引用ansible在github上的介绍：</p><blockquote><p>Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications— automate in a language that approaches plain English, using SSH, with no agents to install on remote systems. </p></blockquote><p>简单说就是运维自动化，减少重复部署，使用SSH协议，且无需安装客户端。</p><p>要说缺点嘛，管理主机不能是Windows，Nagios也是==。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><ul><li>Python2.6以上</li><li>Linux/Unix各发行版</li></ul><p>安装过程略。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170901-ansible01.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="python模块"></p><p>本机环境</p><ul><li>Ubuntu 16.04.3 LTS (GNU/Linux 4.10.0-28-generic x86_64)</li><li>Python 2.7.12</li><li>OpenSSH_7.2p2 Ubuntu-4ubuntu2.2, OpenSSL 1.0.2g  1 Mar 2016</li><li>ansible 2.0.0.2</li></ul><h2 id="ansible连接远程主机原理"><a href="#ansible连接远程主机原理" class="headerlink" title="ansible连接远程主机原理"></a>ansible连接远程主机原理</h2><p>默认会在本地的 OpenSSH可用时会尝试用其进行远程通讯.这会启用ControlPersist(一个性能特性,SSH_5.6以上支持),<a href="https://zh.wikipedia.org/zh-hans/Kerberos" target="_blank" rel="external">Kerberos</a>,和在~/.ssh/config中的配置选项如 Jump Host setup.然而,当你使用Linux企业版6作为主控机(红帽企业版及其衍生版如CentOS),其OpenSSH版本可能过于老旧无法支持ControlPersist. 在这些操作系统中,Ansible将会退回并采用 paramiko (由Python实现的高质量OpenSSH库). 如果你希望能够使用像是Kerberized SSH之类的特性,烦请考虑使用Fedora, OS X, 或 Ubuntu 作为你的主控机直到相关平台上有更新版本的OpenSSH可供使用,或者启用Ansible的“accelerated mode”.</p><h2 id="添加受控主机"><a href="#添加受控主机" class="headerlink" title="添加受控主机"></a>添加受控主机</h2><p>将管理主机公钥添加到受控主机的.ssh/authorized_keys文件中。</p><p>最快的方法是使用<code>ssh_copy_id</code>命令。</p><p>添加好测试一下。</p><p>然后编辑<code>/etc/ansible/hosts</code>文件，将受控主机IP地址添加到文件中。</p><p>执行<code>ansible all -m ping</code>，如返回<code>SUCCESS</code>则成功，如其他，则可使用<code>-vvvv</code>参数输出详细log，排错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Purpose&quot;&gt;&lt;a href=&quot;#Purpose&quot; class=&quot;headerlink&quot; title=&quot;Purpose&quot;&gt;&lt;/a&gt;Purpose&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;了解ansible能做什么&lt;/li&gt;
&lt;li&gt;了解ansible部署环境&lt;/li&gt;
&lt;li&gt;安装ansible管理主机&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ansible" scheme="http://binlv.top/tags/ansible/"/>
    
      <category term="自动化运维" scheme="http://binlv.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>docker machine</title>
    <link href="http://binlv.top/2017/08/14/20170814-docker-machine/"/>
    <id>http://binlv.top/2017/08/14/20170814-docker-machine/</id>
    <published>2017-08-14T04:50:30.000Z</published>
    <updated>2017-10-02T05:42:23.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">官方参考文档</a></p><p><a href="https://yq.aliyun.com/articles/110806" target="_blank" rel="external">阿里Docker CE镜像源站</a></p></blockquote><h1 id="What-is-Docker-Machine"><a href="#What-is-Docker-Machine" class="headerlink" title="What is Docker Machine ?"></a>What is Docker Machine ?</h1><p>Docker Machine is <strong>a tool that lets you install Docker Engine on virtual hosts</strong>, and manage the hosts with <code>docker-machine</code> commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.</p><p>当在一台宿主机上安装docker，我们需要如下几个步骤（Ubuntu）</p><ol><li>安装 https CA 证书</li><li>添加 GPG key</li><li>添加 docker apt 源</li><li>安装 docker</li></ol><p>但对于多主机环境，每台都如此则显得重复工作且效率低下，因此有了docker-machine—能在多台主机上批量安装配置docker，主机可以是本地虚拟机、物理机、云主机等，支持环境如下：</p><ol><li>常规 Linux 操作系统</li><li>虚拟化平台 - VirtualBox、VMWare、Hyper-V</li><li>OpenStack</li><li>公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、Digital Ocean 等</li></ol><p>在docker machine中，都称之为Provider，不同Provider对应不同driver来安装配置docker host。</p><a id="more"></a><h1 id="Install-Docker-Machine"><a href="#Install-Docker-Machine" class="headerlink" title="Install Docker Machine"></a>Install Docker Machine</h1><ol><li><p>Install Docker </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure><p>If you would like to use Docker as a non-root user, you should now consider<br>adding your user to the “docker” group with something like:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod -aG docker &lt;your username&gt;</div></pre></td></tr></table></figure><p><strong><a href="https://yq.aliyun.com/articles/29941?spm=5176.100239.blogcont110806.19.d0XnVG" target="_blank" rel="external">配置镜像加速器</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /etc/docker</div><div class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"填入你的阿里云专属加速器地址"</span>]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl restart docker</div></pre></td></tr></table></figure><p>​</p></li><li><p>Download the Docker Machine binary and extract it to your PATH.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.12.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</div><div class="line">chmod +x /tmp/docker-machine &amp;&amp;</div><div class="line">sudo cp /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure><p>​</p></li><li><p>Check the installation by displaying the Machine version:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker-machine version</div><div class="line">docker-machine version 0.12.2, build 9371605</div></pre></td></tr></table></figure><p>​</p></li><li><p>Installing bash completion scripts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scripts=( docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash ); <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;scripts[@]&#125;</span>"</span>; <span class="keyword">do</span> sudo wget https://raw.githubusercontent.com/docker/machine/v0.12.2/contrib/completion/bash/<span class="variable">$&#123;i&#125;</span> -P /etc/bash_completion.d; <span class="keyword">done</span></div></pre></td></tr></table></figure><p>To enable the <code>docker-machine</code> shell prompt, add <code>$(__docker_machine_ps1)</code> to your <code>PS1</code>setting in <code>~/.bashrc</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=<span class="string">'[\u@\h \W$(__docker_machine_ps1)]\$ '</span></div></pre></td></tr></table></figure></li></ol><h1 id="Use-Machine-to-run-Docker-containers"><a href="#Use-Machine-to-run-Docker-containers" class="headerlink" title="Use Machine to run Docker containers"></a>Use Machine to run Docker containers</h1><p>To run a Docker container,you:</p><ul><li>create a new(or start an exiting) Docker virtual machine</li><li>switch your environment to your new VM</li><li>use the docker client to create,load and manage containers</li></ul><h2 id="Machine-drivers—Generic"><a href="#Machine-drivers—Generic" class="headerlink" title="Machine drivers—Generic"></a>Machine drivers—Generic</h2><p>Create machines using an existing VM/Host with SSH.</p><p>This is useful if you are using a provider that Machine does not support directly or if you would like to import an existing host to allow Docker Machine to manage.</p><p>The driver will perform a list of tasks on create:</p><ul><li>If docker is not running on the host, it will be installed automatically.</li><li>It will update the host packages (<code>apt-get update</code>, <code>yum update</code>…).</li><li>It will generate certificates to secure the docker daemon.</li><li>The docker daemon will be restarted, thus all running containers will be stopped.</li><li>The hostname will be changed to fit the machine name.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic --generic-ip-address=192.168.56.104 host1</div></pre></td></tr></table></figure><h3 id="Sudo-privileges"><a href="#Sudo-privileges" class="headerlink" title="Sudo privileges"></a>Sudo privileges</h3><p>The user that is used to SSH into the host can be specified with <code>--generic-ssh-user</code> flag. This user has to have password-less sudo privileges. If it’s not the case, you need to edit the <code>sudoers</code>file and configure the user as a sudoer with <code>NOPASSWD</code>. See <a href="https://help.ubuntu.com/community/Sudoers" target="_blank" rel="external">https://help.ubuntu.com/community/Sudoers</a> .</p><h4 id="ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES"><a href="#ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES" class="headerlink" title="ENVIRONMENT VARIABLES AND DEFAULT VALUES"></a>ENVIRONMENT VARIABLES AND DEFAULT VALUES</h4><table><thead><tr><th>CLI option</th><th>Environment variable</th><th>Default</th></tr></thead><tbody><tr><td><code>--generic-engine-port</code></td><td><code>GENERIC_ENGINE_PORT</code></td><td><code>2376</code></td></tr><tr><td><strong>–generic-ip-address</strong></td><td><code>GENERIC_IP_ADDRESS</code></td><td>-</td></tr><tr><td><code>--generic-ssh-key</code></td><td><code>GENERIC_SSH_KEY</code></td><td>-</td></tr><tr><td><code>--generic-ssh-user</code></td><td><code>GENERIC_SSH_USER</code></td><td><code>root</code></td></tr><tr><td><code>--generic-ssh-port</code></td><td><code>GENERIC_SSH_PORT</code></td><td><code>22</code></td></tr></tbody></table><h2 id="create-过程："><a href="#create-过程：" class="headerlink" title="create 过程："></a>create 过程：</h2><p>① 通过 ssh 登录到远程主机。<br>② 安装 docker。<br>③ 拷贝证书。<br>④ 配置 docker daemon。<br>⑤ 启动 docker。</p><h1 id="Machine-CLI"><a href="#Machine-CLI" class="headerlink" title="Machine CLI"></a>Machine CLI</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line"></div><div class="line">  --debug, -DEnable debug mode</div><div class="line"></div><div class="line">  --storage-path, -s "/home/binlv/.docker/machine"Configures storage path [$MACHINE_STORAGE_PATH]</div><div class="line"></div><div class="line">  --tls-ca-cert CA to verify remotes against [$MACHINE_TLS_CA_CERT]</div><div class="line"></div><div class="line">  --tls-ca-key Private key to generate certificates [$MACHINE_TLS_CA_KEY]</div><div class="line"></div><div class="line">  --tls-client-cert Client cert to use for TLS [$MACHINE_TLS_CLIENT_CERT]</div><div class="line"></div><div class="line">  --tls-client-key Private key used in client TLS auth [$MACHINE_TLS_CLIENT_KEY]</div><div class="line"></div><div class="line">  --github-api-token Token to use for requests to the Github API [$MACHINE_GITHUB_API_TOKEN]</div><div class="line"></div><div class="line">  --native-sshUse the native (Go-based) SSH implementation. [$MACHINE_NATIVE_SSH]</div><div class="line"></div><div class="line">  --bugsnag-api-token BugSnag API token for crash reporting [$MACHINE_BUGSNAG_API_TOKEN]</div><div class="line"></div><div class="line">  --help, -hshow help</div><div class="line"></div><div class="line">  --version, -vprint the version</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Commands:</div><div class="line"></div><div class="line">  activePrint which machine is active</div><div class="line"></div><div class="line">  configPrint the connection config for machine</div><div class="line"></div><div class="line">  createCreate a machine</div><div class="line"></div><div class="line">  envDisplay the commands to set up the environment for the Docker client</div><div class="line"></div><div class="line">  inspectInspect information about a machine</div><div class="line"></div><div class="line">  ipGet the IP address of a machine</div><div class="line"></div><div class="line">  killKill a machine</div><div class="line"></div><div class="line">  lsList machines</div><div class="line"></div><div class="line">  provisionRe-provision existing machines</div><div class="line"></div><div class="line">  regenerate-certsRegenerate TLS Certificates for a machine</div><div class="line"></div><div class="line">  restartRestart a machine</div><div class="line"></div><div class="line">  rmRemove a machine</div><div class="line"></div><div class="line">  sshLog into or run a command on a machine with SSH.</div><div class="line"></div><div class="line">  scpCopy files between machines</div><div class="line"></div><div class="line">  startStart a machine</div><div class="line"></div><div class="line">  statusGet the status of a machine</div><div class="line"></div><div class="line">  stopStop a machine</div><div class="line"></div><div class="line">  upgradeUpgrade a machine to the latest version of Docker</div><div class="line"></div><div class="line">  urlGet the URL of a machine</div><div class="line"></div><div class="line">  versionShow the Docker Machine version or a machine docker version</div><div class="line"></div><div class="line">  helpShows a list of commands or help for one command</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/machine/overview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/110806&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里Docker CE镜像源站&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;What-is-Docker-Machine&quot;&gt;&lt;a href=&quot;#What-is-Docker-Machine&quot; class=&quot;headerlink&quot; title=&quot;What is Docker Machine ?&quot;&gt;&lt;/a&gt;What is Docker Machine ?&lt;/h1&gt;&lt;p&gt;Docker Machine is &lt;strong&gt;a tool that lets you install Docker Engine on virtual hosts&lt;/strong&gt;, and manage the hosts with &lt;code&gt;docker-machine&lt;/code&gt; commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.&lt;/p&gt;
&lt;p&gt;当在一台宿主机上安装docker，我们需要如下几个步骤（Ubuntu）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 https CA 证书&lt;/li&gt;
&lt;li&gt;添加 GPG key&lt;/li&gt;
&lt;li&gt;添加 docker apt 源&lt;/li&gt;
&lt;li&gt;安装 docker&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但对于多主机环境，每台都如此则显得重复工作且效率低下，因此有了docker-machine—能在多台主机上批量安装配置docker，主机可以是本地虚拟机、物理机、云主机等，支持环境如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常规 Linux 操作系统&lt;/li&gt;
&lt;li&gt;虚拟化平台 - VirtualBox、VMWare、Hyper-V&lt;/li&gt;
&lt;li&gt;OpenStack&lt;/li&gt;
&lt;li&gt;公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、Digital Ocean 等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在docker machine中，都称之为Provider，不同Provider对应不同driver来安装配置docker host。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="http://binlv.top/tags/Docker/"/>
    
      <category term="docker-machine" scheme="http://binlv.top/tags/docker-machine/"/>
    
  </entry>
  
  <entry>
    <title>docker单主机网络管理实践</title>
    <link href="http://binlv.top/2017/08/05/20170805-docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    <id>http://binlv.top/2017/08/05/20170805-docker网络管理/</id>
    <published>2017-08-05T02:36:08.000Z</published>
    <updated>2017-09-23T01:43:36.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>容器作为应用，必然需要与外界通信，包括容器之间和外部网络。</p><p>Docker网络从覆盖范围分</p><ul><li>单台主机上的容器网络★</li><li>跨多台主机的容器网络</li></ul><a id="more"></a><h1 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h1><p>容器间通信的三种方式：</p><ul><li>IP</li><li>Docker DNS Server</li><li>joined</li></ul><h2 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h2><p>Docker安装时，默认会在主机上创建三个网络，bridge、host、none。可用<code>docker network ls</code>查看</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>就是只有loopback的网络，无其他任何网卡。容器创建时可以用 <code>--network=none</code>来指定容器使用none网络</p><p>适应场景：一些安全性要求较高且不需联网的应用，如生成随机密码的容器，放在none里防止窃取。</p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>类似于虚拟机中共享主机网络的选项，即使容器共享其所在主机的网络栈，该容器的网络配置和主机完全一样。</p><p>适应场景：如容器对网络传输效率较高要求，则可使用host网络。注意考虑端口冲突。</p><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>类似于虚拟机中的桥接模式，可理解为一个软件交换机。默认情况下，不指定<code>--network</code>参数，创建的容器都会挂到一个叫<code>docker0</code>的Linux bridge上。可以使用命令<code>brctl show</code>查看。</p><p>注：首次使用<code>brctl</code>命令，可能会提示安装。<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-network.png" alt="network"></p><h3 id="自定义容器网络"><a href="#自定义容器网络" class="headerlink" title="自定义容器网络"></a>自定义容器网络</h3><p>user-defined网络</p><p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。bridge与前面类似，overlay 和 macvlan 用于创建跨主机的网络。</p><p><code>docker network create --driver bridge my_net</code></p><p>还可指定网段和网关，增加参数<code>--subnet</code>和<code>--gateway</code></p><p><code>docker network create --driver bridge --subnet 172.22.16.0/24 --gatewat 172.22.16.1 my_net2</code></p><p>要使用相关网络驱动即在创建docker容器时，指定<code>--network==xxx</code>其中xxx为驱动名称，当指定为有<code>--subnet</code>参数的驱动时，该容器可以通<code>ip</code>参数指定静态IP地址</p><p><code>docker run it --network=my_net2 --ip 172.22.16.8 busybox</code></p><h3 id="容器间连通"><a href="#容器间连通" class="headerlink" title="容器间连通"></a>容器间连通</h3><p>增加网卡使用<code>docker network connect</code>实现。</p><p>例如：为  CONTAINER ID为2a256932添加my_net2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network connect my_net2 2a256932</div></pre></td></tr></table></figure><h4 id="Linux路由转发功能"><a href="#Linux路由转发功能" class="headerlink" title="Linux路由转发功能"></a>Linux路由转发功能</h4><p>Linux默认一般不开启路由转发 ip forwarding，查看/etc/sysctl.cfg中的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure><p>‘1’ 说明启用。</p><p>查看防火墙iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iptables-save</div><div class="line"></div><div class="line">-A DOCKER-ISOLATION -i br-5d863e9f78b6 -o docker0 -j DROP</div><div class="line">-A DOCKER-ISOLATION -i docker0 -o br-5d863e9f78b6 -j DROP</div></pre></td></tr></table></figure><p><strong>iptables DROP 掉了网桥 docker0 与 br-5d863e9f78b6 之间双向的流量</strong>。</p><p>从规则的命名 <code>DOCKER-ISOLATION</code> 可知 docker 在设计上就是要隔离不同的 netwrok。</p><h2 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h2><p>当部署应用之前可能无法确定IP，部署之后再指定要访问的IP会比较麻烦。可通过docker自带的DNS解决问题。</p><p>在docker daemon中实现了一个内嵌的DNS Server ，使容器可以直接通过“容器名”通信。容器名为创建运行容器时指定<code>--name</code>参数确定。</p><p>注：docker dns 只能在user-defined网络中使用。</p><h2 id="joined容器"><a href="#joined容器" class="headerlink" title="joined容器"></a>joined容器</h2><p>joined指多个容器共享网络栈，使容器之间可以通过127.0.0.1直接通信。</p><p>当一个容器需要joined另一个容器，则在创建运行使指定<code>--network=container:容器name</code>即可。</p><p>joined 容器非常适合以下场景：</p><ol><li>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</li><li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li></ol><h1 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h1><p>注意：这里外部网络指的是容器网络以外的网络环境，而非特指Internet</p><p>具体过程已docker0 为例：</p><p>当容器要访问外网时，将数据包封装丢给网关，到达docker0，收到后将其交给MASQUERADE处理（将包源地址替换为主机地址发出去，即做了一次网络地址转换（NAT）），然后就和主机访问外网一样了。</p><h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>在主机通过 <code>iptables -t nat -S</code>可查看到一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</div></pre></td></tr></table></figure><p>其含义是：如果网桥 <code>docker0</code> 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。</p><h2 id="抓包过程"><a href="#抓包过程" class="headerlink" title="抓包过程"></a>抓包过程</h2><p>使用tcpdump</p><ol><li>查看主机路由表</li><li>抓取相关网卡上数据包</li><li>结果分析</li></ol><p><code>ip r</code>查看默认路由从enp0s3出去，故监控enp0s3和docker0上的icmp数据包。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-ip%20route.jpg" alt=""></p><h1 id="外部世界访问容器"><a href="#外部世界访问容器" class="headerlink" title="外部世界访问容器"></a>外部世界访问容器</h1><p>docker可将容器对外提供服务的端口映射到主机的某个端口，外网通过该端口访问容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;host ip&gt;:&lt;映射的端口&gt;</div></pre></td></tr></table></figure><p>在容器启动时通过-p参数来映射端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80 httpd</div></pre></td></tr></table></figure><p>默认情况下容器的端口会随机映射到主机的一个端口。</p><p>可通过<code>docker ps</code>和<code>docker port</code>查看映射的端口情况、</p><p>若要指定映射到主机的某个端口，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:80 httpd</div></pre></td></tr></table></figure><p>意思是将容器的80端口映射到主机的8080端口上<strong>（别搞反了）</strong></p><p>每一个映射的端口，host 都会启动一个 <code>docker-proxy</code> 进程来处理访问容器的流量。</p><p>过程如下：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-docker%20port.jpg" alt=""></p><ol><li>docker-proxy 监听 host 的 32773 端口。</li><li>当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</li><li>httpd 容器响应请求并返回结果。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;容器作为应用，必然需要与外界通信，包括容器之间和外部网络。&lt;/p&gt;
&lt;p&gt;Docker网络从覆盖范围分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单台主机上的容器网络★&lt;/li&gt;
&lt;li&gt;跨多台主机的容器网络&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="虚拟化" scheme="http://binlv.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://binlv.top/tags/Docker/"/>
    
      <category term="网络管理" scheme="http://binlv.top/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>说说vSAN</title>
    <link href="http://binlv.top/2017/07/29/20170729-VSAN/"/>
    <id>http://binlv.top/2017/07/29/20170729-VSAN/</id>
    <published>2017-07-29T05:50:00.000Z</published>
    <updated>2017-11-06T02:13:44.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vSAN"><a href="#vSAN" class="headerlink" title="vSAN"></a>vSAN</h1><p>要说vSAN就不得不提下<strong>超融合</strong>的概念，超融合是一个整体解决方案，是将<strong>计算虚拟化</strong>，<strong>软件定义存储</strong>，<strong>软件定义网络</strong>等解决方案集成到一起的一个整体解决方案。</p><a id="more"></a><p><strong>软件定义分布式存储</strong>是超融合(Hyper-Converged)的核心。引用VMware关于vSAN的一句介绍：</p><blockquote><p>VMware vSAN (formerly Virtual SAN), is the industry-leading software powering Hyper-Converged Infrastructure solutions.</p></blockquote><p>即vSAN是VMware对<a href="https://baike.baidu.com/item/%E8%B6%85%E8%9E%8D%E5%90%88%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84" target="_blank" rel="external">超融合架构</a>的一种解决方案。</p><p>而从功能上说，vSAN是基于<strong>对象</strong>的<strong>分布式策略</strong>存储，这里面的关键词有三个：</p><ul><li>对象</li><li>分布式</li><li>策略</li></ul><p>下面，将以这三个关键词展开对与vSAN的介绍。</p><h1 id="存储对象和组件"><a href="#存储对象和组件" class="headerlink" title="存储对象和组件"></a>存储对象和组件</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象指的是一个独立的存储块设备，大小没限制。vSAN的对象是<strong>带有叶子的RAID树</strong> 。在vSAN存储池Datastore 上虚拟机有五种不同类型的对象，每个虚拟机都是由这些对象的部分组合而成。这些对象是：</p><ul><li>VM Home（虚拟机主页）或“名字空间目录”；</li><li>VM swap （交换文件对象），开机时才会创建；</li><li>VMDK（虚拟磁盘），vSAN 5.5时最大2TB，6.0最大62TB；</li><li>Snapshots（快照），也叫增量盘，建立快照的每个对象都有，每个增量磁盘都是一个对象。</li><li>Memory（vmem，虚拟机内存文件），vSAN5.5时，当快照创建时，虚拟机内存以文件形式存放在VM Home里；而在vSAN 6.0时，虚拟机内存在vSANDatastore里实例化为独立的对象。</li></ul><blockquote><p>注：</p><ul><li>除虚拟机磁盘、增量磁盘（快照）和交换对象外，所有虚拟机文件都驻留在 vSAN 上一个称为虚拟机命名空间的区域中。这里的文件可以是.vmx、.log 文件、.vmdk 和快照增量磁盘描述符文件，以及可能位于虚拟机主目录中的所有其他文件。</li></ul><p>—-<a href="http://vsdsrevolution.blog.51cto.com/8674155/1384474/" target="_blank" rel="external">vSAN 第 4 部分 – 了解对象和组件</a></p></blockquote><p>因为由vSAN搭的vSphere虚拟化环境和我们平时玩的VMware Workstation中的虚机略有不同，在vSAN中，虚机是由大量不同的<strong>存储对象</strong>组成的，而非文件。</p><h2 id="组件-含Witness"><a href="#组件-含Witness" class="headerlink" title="组件(含Witness)"></a>组件(含Witness)</h2><p>组件（ Components）是对象的RAID树上的叶子，分布在vSAN集群中的各个主机上。其实，组件是按照两种主要的技术分布的：Striping（条带），即RAID 0；和Mirroring（镜像），即RAID 1。</p><p>注意，RAID的构成和组件的分布取决于最初创建的存储策略。下图是副本为2，条带为2的组件分布情况。每个存储对象都会以 RAID 树的形式部署在vSAN 中，树中的每一片叶子都视为一个组件。</p><p>条带数（也即副本横跨的盘数）</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-VMDKObject.jpeg" alt=""></p><p>vSAN5.5目前支持每台主机最多包含3000个组件，<strong>vSAN 6.0可达9000个组件</strong>。</p><p>容量大于255GB的对象会自动被分为多个组件。我们知道，vSAN6.0现在支持62TB的VMDK。然而，考虑到vSAN集群支持的最大组件数，需要谨慎衡量应用程序]是否真的需要这么大的VMDK。以单个62TBD VMDK为例，假设副本数为2时，按照255GB拆分，需要消耗约500个组件。</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>需要清楚的是，vSAN不是分布式文件系统，<strong>而是分布式对象存储系统。</strong>所谓分布式就是一个业务拆分成多个子业务，部署在不同服务器上，经常对比的一个概念就是集群，集群是同一个业务，部署在多个服务器上。</p><p>搭建vSAN，至少要三台服务器节点（即ESXi主机），两台主机存放副本，剩下一台存放“见证”（也即Witness，当群集中的虚拟机存储对象出现故障的时候，作为必要的仲裁对象）组件，可允许最多一台主机故障。</p><p>需要注意的是，尽管vSAN完全支持3个主机的配置，但如果可行，<strong>建议至少4个主机</strong>。这是因为，只有3个主机的vSAN集群，在发生故障时，有些情况下，vSAN无法在群集中的其他主机上重新构建（Rebuild）组件（Components）来允许另一次故障。同样，在3个主机配置下，vSAN不能在维护模式（Maintenance Mode）期间从主机迁移所有数据。</p><p>而4个主机的vSAN群集可以提供更高的灵活性。vSAN集群最多时可以支持64个主机。每台为vSAN提供存储资源的主机至少有一个SSD，及一个HDD（每个主机满配5个磁盘组，每个磁盘组为1块SSD+7块HDD，SSD作为缓存层，HDD作为持久化层，也称容量层）。每台主机至少6GB内存。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-vSAN.jpg" alt=""></p><p>上种属于混合配置，在混合配置中，缓存算法会尝试最大限度提高读写性能。<strong>缓存的70%为读缓存</strong>，用于存储频繁读取的磁盘块，从而最大限度减少对速度缓慢的磁盘的访问。<strong>缓存的30%为写缓存</strong>，用于执行写入操作，每个IO会先写入缓存层，再批量写入持久化层。如果可行，系统会合并多个写操作，并按顺序写入，从而再次最大限度提高磁盘性能。</p><p>并且在混合配置下，<strong>强烈推荐使用支持直通（Pass-Through）模式的磁盘控制器</strong>。方便扩容，只需简单插入新盘即可。</p><blockquote><p>注：</p><ul><li>Pass Through意味着，此控制器支持把磁盘直接呈现给ESXi主机。监控和管理由vSAN来实现</li><li>RAID 0 指每个磁盘必须配置为RAID 0卷，才能让ESXi主机看到它们。</li></ul></blockquote><p>还有一种为全闪存配置，全闪存配置下，vSAN必须使用万兆网口。</p><h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>VMware通过SPBM (Storage Policy Based Management) 来实现SDS自动化。SPBM 是一种通用的存储策略框架，可跨 Virtual SAN 控制并自动执行<strong>以虚拟机为中心的存储策略</strong>，并通过 Virtual Volumes 管理外部存储。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-SPBM.jpg" alt=""></p><p>目前6.0版本提供的存储策略一共五种。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-capability.jpg" alt=""></p><h2 id="允许故障数"><a href="#允许故障数" class="headerlink" title="允许故障数"></a>允许故障数</h2><p>即FTT</p><p>为了保证虚拟机持续可访问，组成虚拟机存储对象的组件必须至少有50%可用。所以在保证vSAN可用性的前提下，在故障数为1 的策略时，vSAN环境最少需要3台主机，因为</p><p>3台主机具有2个镜像副本和一个见证，你总是可以具有大于50%的可用组件。</p><p>那么，允许N个故障，vSAN群集要多少台主机？</p><table><thead><tr><th>允许的故障数N</th><th>RAID-1副本数N+1</th><th>vSAN群集中需要的主机数2N+1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>5</td></tr><tr><td>3</td><td>4</td><td>7</td></tr></tbody></table><h2 id="条带宽数"><a href="#条带宽数" class="headerlink" title="条带宽数"></a>条带宽数</h2><p>一般而言，默认条带宽度设置为 1 应能满足大部分虚拟机工作负载的需求。只有在确定写入取消暂存操作或读取缓存未命中的情况影响到了性能时，才应该更改条带宽度。</p><h2 id="闪存读取缓存预留"><a href="#闪存读取缓存预留" class="headerlink" title="闪存读取缓存预留"></a>闪存读取缓存预留</h2><p>该容量是指 SSD 上作为读取缓存保留给存储对象的闪存容量。以1TB 磁盘为例，如果我们将读取缓存预留限定为 1% 的增量，也就意味着缓存预留的增量为 10GB，在大多数情况下，这一增量远远超出了一个虚拟机的需求。</p><h2 id="对象空间预留"><a href="#对象空间预留" class="headerlink" title="对象空间预留"></a>对象空间预留</h2><p>vSAN 上部署的所有对象都采用精简置备。此功能定义了初始化期间可以预留的存储对象逻辑大小百分比。<strong>对象空间预留</strong>表示要预留的空间量,以整个对象地址空间的百分比来表示。</p><h2 id="强制置备"><a href="#强制置备" class="headerlink" title="强制置备"></a>强制置备</h2><p> 如果将此参数设置为非零值，则即使数据存储不满足虚拟机存储策略中指定的策略要求，也会置备对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.vmware.com/products/vSAN.html" target="_blank" rel="external">VMware官方关于vSAN产品的介绍</a></li><li><a href="https://baijia.baidu.com/s?old_id=269575" target="_blank" rel="external">VMware SDS 之一 :什么是vSAN</a></li><li><a href="http://blog.csdn.net/mooncarp/article/details/51012700" target="_blank" rel="external">vSAN的体系架构</a></li><li><a href="http://bbs.vmsky.com/thread-55484-1-1.html" target="_blank" rel="external">vSAN与传统存储的比较</a></li><li><a href="http://sanshileilei.blog.51cto.com/3105269/1374604" target="_blank" rel="external">VMware vSAN入门与配置</a></li><li><a href="http://vsdsrevolution.blog.51cto.com/8674155/1381072" target="_blank" rel="external">VMware R&amp;D 的集成工程团队存储架构师对vSAN的介绍与配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vSAN&quot;&gt;&lt;a href=&quot;#vSAN&quot; class=&quot;headerlink&quot; title=&quot;vSAN&quot;&gt;&lt;/a&gt;vSAN&lt;/h1&gt;&lt;p&gt;要说vSAN就不得不提下&lt;strong&gt;超融合&lt;/strong&gt;的概念，超融合是一个整体解决方案，是将&lt;strong&gt;计算虚拟化&lt;/strong&gt;，&lt;strong&gt;软件定义存储&lt;/strong&gt;，&lt;strong&gt;软件定义网络&lt;/strong&gt;等解决方案集成到一起的一个整体解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="虚拟化" scheme="http://binlv.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="vSAN" scheme="http://binlv.top/tags/vSAN/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi + OpenHab 打造智能安防监控报警系统</title>
    <link href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab打造智能安防监控报警系统/</id>
    <published>2017-06-10T08:43:50.000Z</published>
    <updated>2017-09-09T04:28:55.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是我毕业设计的项目，从选题到设计完成都是一个人独立完成，当然我参考了网上无数教程代码，最后完成算是达到我的预期，可最后答辩时功能演示出现状况，使老师觉得我做的也不怎么样（可能也是我表达能力差），不管了。反正我觉得特别好，至少我这段时间处理解决各种问题最终完成这个开始自己挖的坑还是非常有成就感。所以为感谢网上各位贡献的教程代码，让我可以顺利完成毕设，我也将自己的成果展示出来，与大家共享。</p><a id="more"></a><p>我打算把这篇文章作为整个设计过程的目录，方便整体把握和学习，希望和大家一起交流。</p><p><strong>特别说明：</strong></p><p>本设计中使用的代码大部分来源网络，参考了我都会注明出处。如果遗漏，可以留言，或原作者介意，也可联系我删除。</p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>咱先看实现的最终效果，如果你觉得喜欢或则有兴趣，可以继续往下读，没兴趣就随意了~</p><p><a href="http://binlv.top/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/">智能安防监控报警系统效果展示</a></p><h1 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h1><p>这里面包括硬件部分（树莓派以及各传感器）的选择还有软件部分（操作系统、控制语言、开源物联网平台）的选择。</p><p><a href="http://binlv.top/2017/02/11/20170211-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9/">智能安防监控报警系统—硬件设备选择</a></p><h1 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h1><p>这里包括了树莓派操作系统的安装、配置以及开源平台OpenHab的安装等。</p><p><a href="http://binlv.top/2017/04/05/20170405-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">树莓派系统安装配置</a></p><p><a href="http://binlv.top/2017/05/10/20170510-OpenHab%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">OpenHab安装配置</a></p><h1 id="传感器部分"><a href="#传感器部分" class="headerlink" title="传感器部分"></a>传感器部分</h1><p>这里包括了我选择的各个传感器怎么去使用、获取数据等。</p><p><a href="http://binlv.top/2017/04/10/20170410-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E5%85%A5%E9%97%A8/">树莓派GIPO入门(一)：LED灯</a></p><h1 id="OpenHab实践"><a href="#OpenHab实践" class="headerlink" title="OpenHab实践"></a>OpenHab实践</h1><p>OpenHab是国外的一个开源物联网平台，我也是误打误撞发现的，之前用的yeelink，感觉界面不太友好还经常有BUG，只能放弃。</p><h1 id="邮件及短信提醒的实现"><a href="#邮件及短信提醒的实现" class="headerlink" title="邮件及短信提醒的实现"></a>邮件及短信提醒的实现</h1><p>这一部分折腾我比较久，因为邮件很容易被当作垃圾邮件发不出去，短信也几经波折。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是我毕业设计的项目，从选题到设计完成都是一个人独立完成，当然我参考了网上无数教程代码，最后完成算是达到我的预期，可最后答辩时功能演示出现状况，使老师觉得我做的也不怎么样（可能也是我表达能力差），不管了。反正我觉得特别好，至少我这段时间处理解决各种问题最终完成这个开始自己挖的坑还是非常有成就感。所以为感谢网上各位贡献的教程代码，让我可以顺利完成毕设，我也将自己的成果展示出来，与大家共享。&lt;/p&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="树莓派" scheme="http://binlv.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
  <entry>
    <title>智能安防监控报警系统---效果展示</title>
    <link href="http://binlv.top/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/"/>
    <id>http://binlv.top/2017/06/08/20170608-智能安防监控报警系统效果展示/</id>
    <published>2017-06-08T05:23:50.000Z</published>
    <updated>2017-09-09T04:28:55.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章是我分享的智能安防监控报警系统系列文章的效果展示部分。</p><blockquote><p>目录：<a href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/">RaspberryPi+OpenHab打造智能安防监控报警系统</a></p></blockquote><a id="more"></a><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><ul><li>温度监测、湿度监测、易燃气体检测等，并将温湿度等参数显示在APP中。</li><li>视频监控并通过客户端APP显示</li><li>控制及报警系统<ul><li>环境指数超过阈值通过邮件、短信等报警提醒</li><li>客户端APP能控制LED、安防功能</li><li>当实验室触发报警时及时将实验室情况给管理人员</li></ul></li></ul><p>下图是我最后连接好各传感器后的实物图</p><p><img src="http://olvboulzy.bkt.clouddn.com/Raspberry_full.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="硬件部分实物展示"></p><p>下面是连线图，用frizing画的，比较丑，将就着看看把。</p><p><img src="http://olvboulzy.bkt.clouddn.com/raspberry_lianxian.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="连线图"></p><p>然后是客户端APP主界面</p><p><img src="http://olvboulzy.bkt.clouddn.com/OpenHab_running.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="主界面"></p><p>可以看到第一组远程控制部分包括LED灯开关控制、安防（也就是红外感应）的控制；然后第二组实验室环境显示，包括温度、湿度，烟雾；第三组是视频监控部分，包括第一个动态和第二个静态；第四组是树莓派设备的运行状况显示，主要是CPU和GPU温度；最后一组是当前系统时间（我用来凑数的，哈哈哈）。</p><p><img src="http://olvboulzy.bkt.clouddn.com/Camera.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="视频监控部分"></p><p><img src="http://olvboulzy.bkt.clouddn.com/temperature.png" alt="系统运行状况"></p><p>报警包括蜂鸣器报警、邮件报警、短信报警</p><p>其中，邮件报警基本使用的是yeelink平台的阈值提醒，就是把数据上传，然后在上面设置触发阈值、邮件地址即可，不过经常不灵。也用OpenHab里自带邮件发送，还有自己写的Python版的邮件发送，都不是很理想。短信使用的是阿里大于Python接口，那叫一个方便。</p><p><img src="http://olvboulzy.bkt.clouddn.com/warning.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="报警系统"></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本来我录了个演示视频的。。。后来手贱被我删了，找不到了，我在写这篇文章的时候设备已经上交学校，也演示不了好尴尬额。唉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章是我分享的智能安防监控报警系统系列文章的效果展示部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录：&lt;a href=&quot;http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/&quot;&gt;RaspberryPi+OpenHab打造智能安防监控报警系统&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="树莓派" scheme="http://binlv.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
  <entry>
    <title>Oracle备份恢复</title>
    <link href="http://binlv.top/2017/05/30/20170530-Oracle%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D(%E4%B8%80)/"/>
    <id>http://binlv.top/2017/05/30/20170530-Oracle备份恢复(一)/</id>
    <published>2017-05-30T04:50:00.000Z</published>
    <updated>2017-12-10T14:21:50.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://yq.aliyun.com/articles/45990?spm=5176.100239.blogcont156.11.X4s9k0" target="_blank" rel="external">细谈Oracle备份方法</a><br><a href="http://blog.csdn.net/leshami/article/details/5791585" target="_blank" rel="external">Oracle备份恢复概念</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p> Oracle数据库有两种运行方式：一是归档方式（ArchiveLog），二是不归档方式（NoArchiveLog）。</p><ul><li><p>归档方式<br>  当数据库发生故障时最大限度恢复数据库，可以保证不丢失任何已提交的数据，即恢复到最后一次commit；</p><p>  可实现冷备和热备；</p><p>  支持完全备份和非完全备份以及完全恢复与非完全恢复；</p><p>  但消耗系统10%性能，同时需要消耗更多存储空间；</p></li><li><p>非归档方式<br>  只能恢复数据库到最近的回收点，即最后一次全备；</p><p>  只支持冷备份（又称为一致性备份）；</p><p>  只能完全备份与完全恢复；</p></li></ul><a id="more"></a><h2 id="备份分类"><a href="#备份分类" class="headerlink" title="备份分类"></a>备份分类</h2><ul><li>物理备份<ul><li>冷备份<br>脱机备份—备份前数据库必须彻底关闭。</li><li>热备份<br>联机备份—只适用于归档方式</li></ul></li><li>逻辑备份<br> 将表、存储过程等数据使用Oracle的export等工具导出到二进制文件，后续根据需要再使用import工具导入数据库。</li></ul><h2 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h2><ul><li>RMAN<br> Recovery Manager。Oracle提供的DBA工具，用于管理备份和恢复操作。</li><li>EXP/IMP<br> 导入/导出方式—转储。如表空间迁移、表的抽取、检测逻辑和物理冲突等，适合小型数据库。</li><li>OS脚本</li></ul><h2 id="数据库实例启动关闭过程"><a href="#数据库实例启动关闭过程" class="headerlink" title="数据库实例启动关闭过程"></a>数据库实例启动关闭过程</h2><h3 id="数据库实例启动过程"><a href="#数据库实例启动过程" class="headerlink" title="数据库实例启动过程"></a>数据库实例启动过程</h3><p>当我们<code>startup</code>数据库时，数据库首先到<code>nomount</code>状态，然后启动到<code>mount</code>状态，再到<code>open</code>状态。</p><ul><li><p>nomount</p><p>实例启动</p><p>​        实例的启动通常包含下列任务：</p><p>​           a.按以下顺序在$ORACLE_HOME/dbs[win平台为database]目录下搜索下列文件,即如果第一个没找到，就找下一个</p><p>​               spfile<sid>.ora —&gt; spfile.ora —&gt; init<sid>.ora</sid></sid></p><p>​           b.分配SGA</p><p>​           c.启动后台进程</p><p>​           d.打开并修改告警<sid>.log文件及跟踪文件</sid></p><p>​       注意：</p><p>​           此阶段不打开任何的控制文件及数据文件。</p></li><li><p>mount</p></li></ul><p>​        mount阶段完成的任务：</p><p>​           a.启动实例并打开控制文件，将数据库与实例关联起来</p><p>​           b.利用参数文件中的说明，打开并锁定控制文件</p><p>​           c.读取控制文件以获取数据文件和重做日志文件的名字和状态信息，但不检查数据日志文件是否存在</p><p>​    注意：</p><p>​               这一步会读控制文件，如果这一步有一个控制文件损坏就无法启动</p><ul><li>open</li></ul><p>​       mount阶段完成的任务：</p><p>​           a.打开数据文件</p><p>​           b.打开联机日志文件</p><p>​     注意：</p><p>​            a.在此期间，Oracle服务器将校验所偶的数据文件和联机日志文件能否打开并对数据库作一致性检查</p><p>​           b.如果出现一致性错误，SMON进程将启动实例恢复</p><p>​           c.如果任一数据文件或联机日志文件丢失，Oracle服务器将报错</p><h3 id="数据库实例关闭"><a href="#数据库实例关闭" class="headerlink" title="数据库实例关闭"></a>数据库实例关闭</h3><p>​    关闭命令：shutdowm abort | immediate | transactional | normal (shutdown不带参数将缺省为normal)</p><p>​    关闭选项：</p><p>​       normal         —&gt;不准许新的连接，等待当前的session 结束，等待当前的事务结束，强制检查点并关闭文件</p><p>​       transactional —&gt;不准许新的连接，不等待当前的session结束，等待当前的事务结束，强制检查点并关闭文件。</p><p>​       immediate      —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，强制检查点并关闭文件。</p><p>​       abort          —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，不作强制检查点。</p><h2 id="数据库恢复过程"><a href="#数据库恢复过程" class="headerlink" title="数据库恢复过程"></a>数据库恢复过程</h2><p>restore  -&gt;  recover   -&gt;  open</p><p>数据文件转储  -&gt;  根据log等将差异弥补  -&gt;  打开数据库</p><p>datafile            control scn    </p><h1 id="备份策略选择"><a href="#备份策略选择" class="headerlink" title="备份策略选择"></a>备份策略选择</h1><h1 id="Oracle实例和Oracle数据库"><a href="#Oracle实例和Oracle数据库" class="headerlink" title="Oracle实例和Oracle数据库"></a>Oracle实例和Oracle数据库</h1><p>一个Oracle Server 由Oracle 实例和Oracle 数据库组成。一台SQL server服务器上可以<strong>存在</strong>多个不同的实例。一个实例下可以存在多个<strong>不同</strong>的数据库。</p><ul><li><p>Oracle实例（Instance）</p><p>内存结构（SGA）+一系列后台进程（Background Process）</p></li><li><p>Oracle数据库（Database）</p><p>控制文件（Controlfile）+  数据文件（datafile）+  联机日志文件（logfile） +  参数文件(pfile、spfile)  +  密码文件等</p><p>​</p></li></ul><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/45990?spm=5176.100239.blogcont156.11.X4s9k0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;细谈Oracle备份方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/5791585&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oracle备份恢复概念&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;运行方式&quot;&gt;&lt;a href=&quot;#运行方式&quot; class=&quot;headerlink&quot; title=&quot;运行方式&quot;&gt;&lt;/a&gt;运行方式&lt;/h2&gt;&lt;p&gt; Oracle数据库有两种运行方式：一是归档方式（ArchiveLog），二是不归档方式（NoArchiveLog）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;归档方式&lt;br&gt;  当数据库发生故障时最大限度恢复数据库，可以保证不丢失任何已提交的数据，即恢复到最后一次commit；&lt;/p&gt;
&lt;p&gt;  可实现冷备和热备；&lt;/p&gt;
&lt;p&gt;  支持完全备份和非完全备份以及完全恢复与非完全恢复；&lt;/p&gt;
&lt;p&gt;  但消耗系统10%性能，同时需要消耗更多存储空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非归档方式&lt;br&gt;  只能恢复数据库到最近的回收点，即最后一次全备；&lt;/p&gt;
&lt;p&gt;  只支持冷备份（又称为一致性备份）；&lt;/p&gt;
&lt;p&gt;  只能完全备份与完全恢复；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="RMAN" scheme="http://binlv.top/tags/RMAN/"/>
    
  </entry>
  
  <entry>
    <title>RAC学习记录</title>
    <link href="http://binlv.top/2017/05/23/20170523-Oracle%2011g%20RAC%20Installation%20Guide/"/>
    <id>http://binlv.top/2017/05/23/20170523-Oracle 11g RAC Installation Guide/</id>
    <published>2017-05-23T07:00:00.000Z</published>
    <updated>2017-11-01T11:30:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAC理论基础"><a href="#RAC理论基础" class="headerlink" title="RAC理论基础"></a>RAC理论基础</h1><p>在RAC术语中，主机通常叫做“节点”。<br>每个主机的硬件配置应该一样：</p><ul><li>每个主机至少需要两块网卡，一个用于集群内部私有通信—Private NIC，另一个网卡用于对外提供服务，如提供用户数据查询—公共网卡（Public NIC）；</li><li>每个主机还要有一个HBA卡，通过光纤连接到存储设备</li><li>除公共和私有IP，每个节点还有VIP（Virtual IP），宕机时使用<br>  共享存储</li><li>多实例，单一数据 架构</li><li>所有节点共享一个数据库</li><li>数据文件、联机日志、参数文件、控制文件必须存放在共享存储上</li><li>保证每个节点都能访问这个存储设备  <a id="more"></a></li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h2><ul><li>操作系统及补丁包<br>要求：OEL 使用 ASMlib、其他Linux使用udev<pre><code>内存：2G以上、SWAP 4G 、硬盘 30G以上</code></pre></li><li>创建所需组、用户和软件home目录<br> oracle - oinstall dba<br>  grid   - asmadmin</li><li>若部署GNS，需提前设置</li><li>设置存储空间</li></ul><h2 id="安装Oracle-Grid-Infrastructure"><a href="#安装Oracle-Grid-Infrastructure" class="headerlink" title="安装Oracle Grid Infrastructure"></a>安装Oracle Grid Infrastructure</h2><ul><li>包括Oracle Clusterware和Oracle ASM<br>11gR2 整合了Clusterware</li></ul><p>ASM安装是个重点<br>如使用OEL系统，自带asmlib但还是要安装asm-support（系统光盘中有）<br>如使用非OEL系统，有两种解决方案：</p><ol><li>安装对应内核的asmlib和asm-support，一般只适合较老版本Linux（Oracle对非自家Linux不提供支持，oracleasm最新支持到oracleasm-2.6.18-238.9.1.el5）</li><li>使用linux自带设备管理器udev，其中又有两种情形：<br>2.1 6.0版本以前的可以用scsi_id -g -u -s</li></ol><p>1.确认在所有RAC节点上已经安装了必要的UDEV包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@rh2 ~]# rpm -qa|grep udev</div><div class="line">udev-095-14.21.el5</div></pre></td></tr></table></figure></p><p>2.通过scsi_id获取设备的块设备的唯一标识名，假设系统上已有LUN sdc-sdp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in c d e f g h i j k l m n o p ;</div><div class="line">do</div><div class="line">echo "sd$i" "`scsi_id -g -u -s /block/sd$i` ";</div><div class="line">done</div></pre></td></tr></table></figure></p><p>sdc 1IET_00010001<br>sdd 1IET_00010002<br>sde 1IET_00010003<br>sdf 1IET_00010004<br>sdg 1IET_00010005<br>sdh 1IET_00010006<br>sdi 1IET_00010007<br>sdj 1IET_00010008<br>sdk 1IET_00010009<br>sdl 1IET_0001000a<br>sdm 1IET_0001000b<br>sdn 1IET_0001000c<br>sdo 1IET_0001000d<br>sdp 1IET_0001000e </p><p>以上列出于块设备名对应的唯一标识名</p><p>3.创建必要的UDEV配置文件，</p><p>首先切换到配置文件目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rh2 ~]# cd /etc/udev/rules.d</div></pre></td></tr></table></figure></p><p>定义必要的规则配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# touch 99-oracle-asmdevices.rules </div><div class="line">[root@rh2 rules.d]# cat 99-oracle-asmdevices.rules</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010001", NAME="ocr1", OWNER="grid", GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010002", NAME="ocr2", OWNER="grid", GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010003", NAME="asm-disk1",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010004", NAME="asm-disk2",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010005", NAME="asm-disk3",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010006", NAME="asm-disk4",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010007", NAME="asm-disk5",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010008", NAME="asm-disk6",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010009", NAME="asm-disk7",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000a", NAME="asm-disk8",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000b", NAME="asm-disk9",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000c", NAME="asm-disk10", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000d", NAME="asm-disk11", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000e", NAME="asm-disk12", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div></pre></td></tr></table></figure></p><p>Result 为/sbin/scsi_id -g -u -s %p的输出–Match the returned string of the last PROGRAM call. This key may be<br>used in any following rule after a PROGRAM call.<br>按顺序填入刚才获取的唯一标识名即可</p><p>OWNER为安装Grid Infrastructure的用户，在11gr2中一般为grid，GROUP为asmadmin<br>MODE采用0660即可</p><p>NAME为UDEV映射后的设备名，<br>建议为OCR和VOTE DISK创建独立的DISKGROUP，为了容易区分将该DISKGROUP专用的设备命名为ocr1..ocrn的形式<br>其余磁盘可以根据其实际用途或磁盘组名来命名</p><ol><li>将该规则文件拷贝到其他节点上<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# scp 99-oracle-asmdevices.rules Other_node:/etc/udev/rules.d</div></pre></td></tr></table></figure></li></ol><p>5.在所有节点上启动udev服务，或者重启服务器即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# /sbin/udevcontrol reload_rules</div><div class="line">[root@rh2 rules.d]# /sbin/start_udev</div><div class="line">Starting udev:                                            [  OK  ]</div></pre></td></tr></table></figure></p><p>6.检查设备是否到位<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# cd /dev</div><div class="line">[root@rh2 dev]# ls -l ocr*</div><div class="line">brw-rw---- 1 grid asmadmin 8, 32 Jul 10 17:31 ocr1</div><div class="line">brw-rw---- 1 grid asmadmin 8, 48 Jul 10 17:31 ocr2</div><div class="line"></div><div class="line">[root@rh2 dev]# ls -l asm-disk*</div><div class="line">brw-rw---- 1 grid asmadmin 8,  64 Jul 10 17:31 asm-disk1</div><div class="line">brw-rw---- 1 grid asmadmin 8, 208 Jul 10 17:31 asm-disk10</div><div class="line">brw-rw---- 1 grid asmadmin 8, 224 Jul 10 17:31 asm-disk11</div><div class="line">brw-rw---- 1 grid asmadmin 8, 240 Jul 10 17:31 asm-disk12</div><div class="line">brw-rw---- 1 grid asmadmin 8,  80 Jul 10 17:31 asm-disk2</div><div class="line">brw-rw---- 1 grid asmadmin 8,  96 Jul 10 17:31 asm-disk3</div><div class="line">brw-rw---- 1 grid asmadmin 8, 112 Jul 10 17:31 asm-disk4</div><div class="line">brw-rw---- 1 grid asmadmin 8, 128 Jul 10 17:31 asm-disk5</div><div class="line">brw-rw---- 1 grid asmadmin 8, 144 Jul 10 17:31 asm-disk6</div><div class="line">brw-rw---- 1 grid asmadmin 8, 160 Jul 10 17:31 asm-disk7</div><div class="line">brw-rw---- 1 grid asmadmin 8, 176 Jul 10 17:31 asm-disk8</div><div class="line">brw-rw---- 1 grid asmadmin 8, 192 Jul 10 17:31 asm-disk9</div></pre></td></tr></table></figure></p><p>  2.2 6.0版本以后的-g失效,需使用</p><p>1.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">首先确认是 Linux 6.0以上版本</span></div><div class="line">[root@vrh6 dev]# cat /etc/issue          </div><div class="line">Oracle Linux Server release 6.2</div><div class="line">Kernel \r on an \m</div></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">添加记录到/etc/scsi_id.config</span></div><div class="line"></div><div class="line">echo "options=--whitelisted --replace-whitespace"  &gt;&gt; /etc/scsi_id.config</div></pre></td></tr></table></figure></p><ol><li>​<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">确认哪些块设备需要udev绑定</span></div><div class="line"></div><div class="line">[root@vrh6 dev]# ls -l sd*</div><div class="line">brw-rw----. 1 root disk 8,  0 Jun 30 09:29 sda</div><div class="line">brw-rw----. 1 root disk 8,  1 Jun 30 09:29 sda1</div><div class="line">brw-rw----. 1 root disk 8,  2 Jun 30 09:29 sda2</div><div class="line">brw-rw----. 1 root disk 8, 16 Jun 30 09:29 sdb</div><div class="line">brw-rw----. 1 root disk 8, 32 Jun 30 09:29 sdc</div><div class="line">brw-rw----. 1 root disk 8, 48 Jun 30 09:29 sdd</div><div class="line">brw-rw----. 1 root disk 8, 64 Jun 30 09:29 sde</div><div class="line">brw-rw----. 1 root disk 8, 80 Jun 30 09:29 sdf</div></pre></td></tr></table></figure></li></ol><p>例如在本实例中 sdb-&gt; sdf的块设备需要绑定</p><ol><li>将 b-&gt;f的编号放入for 循环中，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span></div><div class="line">for i in b c d e f ;</div><div class="line">do</div><div class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      </div><div class="line">done</div></pre></td></tr></table></figure></li></ol><p>就会生成sdb-&gt;sdf 设备绑定的RULE，在将这些RULE写入到/etc/udev/rules.d/99-oracle-asmdevices.rules中</p><p>也可以直接利用以下脚本 ，写出RULE到99-oracle-asmdevices.rules<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span></div><div class="line">for i in b c d e f ;</div><div class="line">do</div><div class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      &gt;&gt; /etc/udev/rules.d/99-oracle-asmdevices.rules</div><div class="line">done</div></pre></td></tr></table></figure></p><ol><li>之后运行用root运行/sbin/start_udev  即可</li></ol><blockquote><p>注：</p><p>使用vmware，需要在主机vmx文件中加入： disk.EnableUUID = “TRUE”，否则UUID出不来</p></blockquote><h2 id="安装Oracle-RAC"><a href="#安装Oracle-RAC" class="headerlink" title="安装Oracle RAC"></a>安装Oracle RAC</h2><h1 id="学会使用集群验证实用程序（CVU）"><a href="#学会使用集群验证实用程序（CVU）" class="headerlink" title="学会使用集群验证实用程序（CVU）"></a>学会使用集群验证实用程序（CVU）</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RAC理论基础&quot;&gt;&lt;a href=&quot;#RAC理论基础&quot; class=&quot;headerlink&quot; title=&quot;RAC理论基础&quot;&gt;&lt;/a&gt;RAC理论基础&lt;/h1&gt;&lt;p&gt;在RAC术语中，主机通常叫做“节点”。&lt;br&gt;每个主机的硬件配置应该一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个主机至少需要两块网卡，一个用于集群内部私有通信—Private NIC，另一个网卡用于对外提供服务，如提供用户数据查询—公共网卡（Public NIC）；&lt;/li&gt;
&lt;li&gt;每个主机还要有一个HBA卡，通过光纤连接到存储设备&lt;/li&gt;
&lt;li&gt;除公共和私有IP，每个节点还有VIP（Virtual IP），宕机时使用&lt;br&gt;  共享存储&lt;/li&gt;
&lt;li&gt;多实例，单一数据 架构&lt;/li&gt;
&lt;li&gt;所有节点共享一个数据库&lt;/li&gt;
&lt;li&gt;数据文件、联机日志、参数文件、控制文件必须存放在共享存储上&lt;/li&gt;
&lt;li&gt;保证每个节点都能访问这个存储设备
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="RAC" scheme="http://binlv.top/tags/RAC/"/>
    
      <category term="cluster" scheme="http://binlv.top/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>OpenHab安装配置</title>
    <link href="http://binlv.top/2017/05/10/20170510-OpenHab%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://binlv.top/2017/05/10/20170510-OpenHab安装配置/</id>
    <published>2017-05-10T08:10:32.000Z</published>
    <updated>2017-09-09T04:28:55.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a><h1 id="OpenHab简介"><a href="#OpenHab简介" class="headerlink" title="OpenHab简介"></a>OpenHab简介</h1><p>开源物联网平台，吸引我的是它可实现一次部署，即可同时支持Web、安卓、苹果等控制管理，且界面美观、可定制性强。较国内如yeelink。</p><h1 id="OpenHab原理"><a href="#OpenHab原理" class="headerlink" title="OpenHab原理"></a>OpenHab原理</h1><p>安装前首先要懂原理，不然后面出现啥问题会一脸懵逼。</p><h1 id="OpenHab安装"><a href="#OpenHab安装" class="headerlink" title="OpenHab安装"></a>OpenHab安装</h1><p>参考官方教程</p><h1 id="OpenHab配置"><a href="#OpenHab配置" class="headerlink" title="OpenHab配置"></a>OpenHab配置</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
</feed>
