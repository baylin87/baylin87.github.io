<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lvbin&#39;s Blog</title>
  
  <subtitle>甲丐内美吕</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://binlv.top/"/>
  <updated>2018-03-03T02:30:51.103Z</updated>
  <id>http://binlv.top/</id>
  
  <author>
    <name>吕滨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于JS中变量、函数声明提升优先级问题的实验</title>
    <link href="http://binlv.top/2018/03/03/20180302-%E5%85%B3%E4%BA%8EJS%E4%B8%AD%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E9%AA%8C/"/>
    <id>http://binlv.top/2018/03/03/20180302-关于JS中变量、函数声明提升优先级问题的实验/</id>
    <published>2018-03-03T13:54:00.000Z</published>
    <updated>2018-03-03T02:30:51.103Z</updated>
    
    <content type="html"><![CDATA[<p>在复习JS-函数时遇到函数声明提升，回想起之前的变量声明的提升，加上JS无重载一说，若出现同名函数，则后者会覆盖前者。想搞清楚既然变量、函数都能提升，那他们之间的优先级是什么，遂做个小实验验证一下。</p><p>其实我是被自己写的一题给绕晕了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); </div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>变量声明会提升至其作用域的<strong>执行顺序最前</strong>；</li><li>优先级：变量 (全局) 声明 &gt; 函数声明</li></ul><p>验证过程如下：</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="变量声明的提升"><a href="#变量声明的提升" class="headerlink" title="变量声明的提升"></a>变量声明的提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;  </div><div class="line"><span class="comment">//结果为控制台打印 undefined</span></div></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a=<span class="number">100</span>;</div></pre></td></tr></table></figure><p>这就是变量声明提升–JS中，变量的声明会在其作用域内的最先运行。</p><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><p>直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//结果为控制台打印该函数</span></div></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><h3 id="函数表达式声明"><a href="#函数表达式声明" class="headerlink" title="函数表达式声明"></a>函数表达式声明</h3><p>函数声明提升不适用于函数表达式，但在判断优先级时可作为很强的干扰项，看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//结果为控制台打印 undefined</span></div></pre></td></tr></table></figure><p>其实这个就是变量声明的提升。。。等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Chrome 63.0.3239.132 (正式版)  （64位）</li></ul><h2 id="变量声明与函数表达式声明"><a href="#变量声明与函数表达式声明" class="headerlink" title="变量声明与函数表达式声明"></a>变量声明与函数表达式声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span> <span class="comment">//变量声明提升</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//后者覆盖前者</span></div></pre></td></tr></table></figure><h2 id="变量声明与函数声明"><a href="#变量声明与函数声明" class="headerlink" title="变量声明与函数声明"></a>变量声明与函数声明</h2><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>结果为控制台打印如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//函数声明提升</span></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure><p>代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;<span class="comment">//变量声明提升</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;<span class="comment">//函数声明提升</span></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line">a = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p>这里有个疑问，到底是var a;变量声明提升在前，还是function a 函数声明在前。验证了一下，不管谁在前，运行结果都一样。</p><p>个人开始认为应该是 变量 (全局) 声明在前，函数声明提升在后，后者覆盖前者，所以第一个 <code>console.log(a);</code> 打印函数a。</p><p><strong>验证：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>);</div><div class="line"><span class="comment">//控制台打印出window对象</span></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure><p><img src="http://olvboulzy.bkt.clouddn.com/20180302-102320.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt=""></p><p>后查阅<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="external">《You Don’t Know JS:Scope &amp; Closures》</a>的第四章关于声明提升的说法是，<code>function</code> 声明 优先于 <code>var</code> 声明，尽管 <code>var</code> 写在前，但 <code>function</code> 声明优先，<code>var</code> 声明被忽略了。</p><p>被忽略了？？</p><p>emmmm…</p><p>这或许是要看JS引擎源码才能知道答案吧…</p><p>所以，</p><p><strong>开头那题的答案：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//function a () &#123;console.log("a")&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"aa"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//function () &#123;console("a")&#125;</span></div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions" target="_blank" rel="external">MDN关于函数的讲解</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="external">You-Dont Know-JS:Scope &amp; Closures—Chapter 4: Hoisting</a></li><li><a href="https://www.cnblogs.com/oxiaojiano/p/7918967.html" target="_blank" rel="external">cnblogs上一篇关于优先级问题的文章</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在复习JS-函数时遇到函数声明提升，回想起之前的变量声明的提升，加上JS无重载一说，若出现同名函数，则后者会覆盖前者。想搞清楚既然变量、函数都能提升，那他们之间的优先级是什么，遂做个小实验验证一下。&lt;/p&gt;
&lt;p&gt;其实我是被自己写的一题给绕晕了&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;aa&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;变量声明会提升至其作用域的&lt;strong&gt;执行顺序最前&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;优先级：变量 (全局) 声明 &amp;gt; 函数声明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="编程开发" scheme="http://binlv.top/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://binlv.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo同步源文件至GitHub</title>
    <link href="http://binlv.top/2018/02/26/20180226-Hexo%E5%90%8C%E6%AD%A5%E6%BA%90%E6%96%87%E4%BB%B6%E8%87%B3GitHub/"/>
    <id>http://binlv.top/2018/02/26/20180226-Hexo同步源文件至GitHub/</id>
    <published>2018-02-26T09:00:34.000Z</published>
    <updated>2018-02-26T12:05:17.043Z</updated>
    
    <content type="html"><![CDATA[<p>以前用Hexo最大的痛点就是想在其他电脑上写文章然后更新站点很麻烦，或者换系统后发现忘记备份源文件，然后以前写的东西又得通过各种方法找回再重新部署。没办法，静态站点就是这样。</p><p>此时程序员思维就出现了，能不能在我每次写完新文章后自动备份源文件，或者我在<code>hexo d</code>的时候一起把我的<code>.md</code>文件也deploy上去。</p><p>当然，方法各种，这里我直接使用 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a> 这个小插件的功能，相对简单些。</p><a id="more"></a><h1 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h1><p>直接一句话搞定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>当然，作者说如果想使用最新版，可用下面的命令：</p><ul><li>对于npm版本低于4的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm install git+git@github.com:hexojs/hexo-deployer-git.git --save</span></div></pre></td></tr></table></figure><ul><li>对于npm版本低于5的用户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> npm install git+ssh://git@github.com:hexojs/hexo-deployer-git.git --save</span></div></pre></td></tr></table></figure><blockquote><p>查看自己npm版本的命令：<code>npm --version</code></p></blockquote><p>其实如果你原先就是将hexo部署在GitHub Pages，那这个插件是已经安装过了，只需要进行相关配置就行。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>修改hexo根目录下的<code>_config.yml</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> _config.yaml</span></div><div class="line">deploy:</div><div class="line">  - type: git</div><div class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</div><div class="line">    branch: master</div><div class="line">  - type: git</div><div class="line">    repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</div><div class="line">    branch: src</div><div class="line">    extend_dirs: /</div><div class="line">    ignore_hidden: false</div><div class="line">    ignore_pattern:</div><div class="line">        public: .</div></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>第一个master分支是你静态页面所在分支，也就是<code>hexo g</code>后生成的<code>public</code>文件夹中的内容</li><li>第二个src分支就是备份你源文件的，具体参数请参考原作者写的</li></ul><p>如此之后，在每次<code>hexo d</code>后就能将你的源文件备份至<code>src</code>分支，没有更爽。</p><p>当然，安装后每次 deploy 会比原来稍慢点。</p><p>还有，未配置过<code>git user</code>信息的会提示要配置user.mail和user.name：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.email "you@example.com"</div><div class="line">git config --global user.name "Your Name"</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git 的GitHub地址</a> </li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">Hexo官方关于deployment的说明</a></li><li><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">知乎上关于换电脑后hexo该怎么更新的回答</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前用Hexo最大的痛点就是想在其他电脑上写文章然后更新站点很麻烦，或者换系统后发现忘记备份源文件，然后以前写的东西又得通过各种方法找回再重新部署。没办法，静态站点就是这样。&lt;/p&gt;
&lt;p&gt;此时程序员思维就出现了，能不能在我每次写完新文章后自动备份源文件，或者我在&lt;code&gt;hexo d&lt;/code&gt;的时候一起把我的&lt;code&gt;.md&lt;/code&gt;文件也deploy上去。&lt;/p&gt;
&lt;p&gt;当然，方法各种，这里我直接使用 &lt;a href=&quot;https://github.com/hexojs/hexo-deployer-git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-deployer-git&lt;/a&gt; 这个小插件的功能，相对简单些。&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://binlv.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="Hexo" scheme="http://binlv.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JS笔试基础知识点</title>
    <link href="http://binlv.top/2018/01/18/20180118-JS%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://binlv.top/2018/01/18/20180118-JS面试基础知识点/</id>
    <published>2018-01-18T12:20:00.000Z</published>
    <updated>2018-01-25T03:07:45.703Z</updated>
    
    <content type="html"><![CDATA[<p>听公开课讲得一些JS笔试中容易出现的知识点。</p><p>与其说是知识点，不如说是—“那些年走过的JS大坑”</p><p>一般关于JS的笔试会走两极端—-要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）</p><a id="more"></a><h1 id="字面量相关"><a href="#字面量相关" class="headerlink" title="字面量相关"></a>字面量相关</h1><p>定义：计算机能识别类型的数据。</p><h2 id="特殊字面量"><a href="#特殊字面量" class="headerlink" title="特殊字面量"></a>特殊字面量</h2><p>顾名思义，计算机识别不了的—NaN，指的不是一个正常的数。</p><h2 id="常见考察点"><a href="#常见考察点" class="headerlink" title="常见考察点"></a>常见考察点</h2><ul><li>正数/0=正无穷Infinity</li><li>0/0=NaN</li><li>parseInt(“string”); 将字符串转为整数的数字类型，条件：纯数字字符串或数字开头字符串，其他为NaN</li><li>数据类型参与数值运算：<ul><li>”数据类型—数字、字符串、undefined、布尔、null”；</li><li>”数学运算— + - * / %”。</li><li>非数字参与数学运算会把非数字转换（<strong>隐式转换</strong>）为数字再参与运算。除null、false转换为0，数字字符串转为数字，其余包括undefined为NaN</li></ul></li></ul><h1 id="各种运算符"><a href="#各种运算符" class="headerlink" title="各种运算符"></a>各种运算符</h1><h2 id="比较运算符（关系运算符）"><a href="#比较运算符（关系运算符）" class="headerlink" title="比较运算符（关系运算符）"></a>比较运算符（关系运算符）</h2><ul><li><code>==</code> 相等  <code>===</code>全等于，即除判断值是否相等，还要判断数据类型，如<code>1</code>和<code>true</code>。<code>!=</code> 不相等（与<code>==</code>相反）</li><li>比较运算的结果就是布尔值，<code>true</code>/<code>false</code></li><li>其他数据参与比较运算时，也会隐式转换为数字参与运算</li><li><code>NaN</code>参与的话，无论与谁都是不等于<code>false</code></li><li><code>IsNaN()</code>方法，判断一个数是否能转为<code>NaN</code>，能<code>true</code>，否<code>false</code>，能转的有：非数字字符串、<code>undefined</code></li></ul><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>上面说到了比较运算符 <code>==</code> 和<code>===</code>，下面总结一下与等式(包括<code>==</code>, <code>===</code>, <code>!=</code>, 和 <code>!==</code>)相关的东西。</p><p>首先说下<code>==</code>和<code>===</code>的区别，<code>==</code>只检查<strong>值(value)</strong>是否相同，而<code>===</code>不仅比较<strong>值(value)</strong>还要检查<strong>数据类型(type)</strong>是否相同，所以<code>==</code>又叫做<strong>松等于(loose-equality)</strong> ，<code>===</code>又叫做<strong>严格等于(strict-equality)</strong>。</p><blockquote><p><strong>注1：</strong>在比较时，若比较两端非<code>number</code>类型，则会自动转换为<code>number</code>类型再进行比较。</p><p><strong>注2：</strong>如果比较两个非原始值，比如对象<code>object</code>（包括函数<code>function</code>和数组<code>array</code>）。因为这些值实际上是通过引用保存的，所以<code>==</code>和<code>===</code>比较都只是检查引用是否匹配，而不是基本值。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"42"</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">42</span>;</div><div class="line"></div><div class="line">a == b;<span class="comment">// true</span></div><div class="line">a === b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> c = <span class="string">"1,2,3"</span>;</div><div class="line"></div><div class="line">a == c;<span class="comment">// true</span></div><div class="line">b == c;<span class="comment">// true</span></div><div class="line">a == b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>这时候就有一个问题，什么时候使用<code>==</code>，什么时候使用<code>===</code>呢？有如下几个基本规则：</p><ul><li>如果比较两端值的类型是<code>boolean</code>类型，<code>true/false</code>，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>如果比较两端的值是些特别的值(<code>0</code>, <code>&quot;&quot;</code>, or <code>[]</code> – empty array)，则尽量使用<code>===</code>，而不用<code>==</code>；</li><li>其他都用<code>==</code>吧</li></ul><h2 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h2><p>有等式当然就有不等式，有<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, 和 <code>&gt;=</code>四种不等式。一般用于比较<code>number</code>类型，但在JavaScript中<code>string</code>值也能被比较。</p><blockquote><p><strong>注：</strong>这里没有严格不等式。</p></blockquote><p>例子一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">41</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"42"</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="string">"43"</span>;</div><div class="line"></div><div class="line">a &lt; b;<span class="comment">// true</span></div><div class="line">b &lt; c;<span class="comment">// true</span></div></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"foo"</span>;</div><div class="line"></div><div class="line">a &lt; b;<span class="comment">// false</span></div><div class="line">a &gt; b;<span class="comment">// false</span></div><div class="line">a == b;<span class="comment">// false</span></div></pre></td></tr></table></figure><p>例子二中 b值的类型是<code>string</code>，在参与不等式比较时，会强制转换为<code>NaN</code>，而<code>NaN</code>和谁都不相等，包括和它自己。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 +="></a>赋值运算符 +=</h2><ul><li>必须有变量参与运算</li><li>特殊：++递加- -递减，变量出现一次叫做使用一次。可为a++或++a</li></ul><h2 id="逻辑运算符-amp-amp-、-、"><a href="#逻辑运算符-amp-amp-、-、" class="headerlink" title="逻辑运算符 &amp;&amp; 、||、!"></a>逻辑运算符 &amp;&amp; 、||、!</h2><ul><li>规律：逻辑与和逻辑或，答案都与第一个操作数a能够判读为true/false有关，如判断为假的有—null、undefined、0、NaN、” ” 空字符串；判断为真—非0非NaN数字、非空字符串</li><li>与运算&amp;&amp;：a&amp;&amp;b，如果a为true，则结果就是b；如果a为false，则为false</li><li>逻辑或||：a||b，如果a为true，结果就是true；如果a为false，则结果为b</li><li>逻辑非：</li></ul><h2 id="Truthy-amp-Falsy"><a href="#Truthy-amp-Falsy" class="headerlink" title="Truthy &amp; Falsy"></a>Truthy &amp; Falsy</h2><p>总结一下一些奇葩的<code>boolean</code>类型，一般性的布尔值没什么好说的。特别提下一些会被判断为truthy和falsy。</p><p>一些特别的”falsy”如下：</p><ul><li><code>&quot;&quot;</code> (empty string)</li><li><code>0</code>，<code>-0</code>，<code>NaN</code> (invalid number)</li><li><code>null</code>,<code>undefined</code></li><li><code>false</code></li></ul><p>一些特别的“truthy”如下:</p><ul><li><code>&quot;hello&quot;</code></li><li><code>42</code></li><li><code>true</code></li><li><code>[ ]</code>, <code>[ 1, &quot;2&quot;, 3 ]</code> (arrays)</li><li><code>{ }</code>, <code>{ a: 42 }</code> (objects)</li><li><code>function foo() { .. }</code> (functions)</li></ul><h2 id="三元运算符—"><a href="#三元运算符—" class="headerlink" title="三元运算符— ? :"></a>三元运算符— ? :</h2><p>或作为条件分支语句</p><p>​         Boolean_expression? true_value : false_value;</p><h1 id="变量、作用域"><a href="#变量、作用域" class="headerlink" title="变量、作用域"></a>变量、作用域</h1><ul><li>JS中无{}块作用域，只有函数结构function封住一个作用域。</li><li>局部变量/全局变量。不同作用域中如都定义了同一个名字的变量，有一个查找作用域链—从内到外(如本层(层指的是function)有直接使用，如无依次向外层查找)</li><li>如变量未定义直接使用会提示引用错误，但可先使用再定义变量，但会导致变量声明提升问题undefined—JS解释器解释代码时，会将所有变量定义的过程提升到作用域代码最前面，相当于先定义了，但未赋值，默认undefined。</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>这个必考。。。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>函数就是闭包。</li><li>函数是一种对象型数据，对象型数据创建时有一个数据原型，如果将一个对象型数据赋值给变量，则变量中存的不是原型，而是指针/地址</li><li>如果将一个变量赋值给另一个变量，相当于将地址复制一份给另一个变量</li><li>每一个通过function定义的函数都是一个新的闭包</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(n+ i++);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = fo();</div><div class="line">f(<span class="number">20</span>);</div><div class="line">fo()(<span class="number">20</span>);</div><div class="line">fo()(<span class="number">10</span>);</div><div class="line">f(<span class="number">10</span>);</div></pre></td></tr></table></figure><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">20</span>   <span class="comment">//n=20,i=0,n+i=20,i++后得1，输出20</span></div><div class="line"><span class="number">20</span> <span class="comment">//创建新闭包，结果同上</span></div><div class="line"><span class="number">10</span> <span class="comment">//同理</span></div><div class="line"><span class="number">11</span> <span class="comment">//由于前f(20);影响，i为1，第二次执行f();则为11，I、i++后得3</span></div></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr1;</div><div class="line">arr2[<span class="number">0</span>] = <span class="number">8</span>;</div><div class="line">arr1.push(arr1.shift());</div><div class="line"><span class="built_in">console</span>.log(arr1);</div><div class="line"><span class="built_in">console</span>.log(arr2);</div></pre></td></tr></table></figure><p>说明：</p><ul><li>数组也是对象型数据，存储给变量时，给的是指向数据原型的地址。</li><li>shift();</li><li>push();</li></ul><p>结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">5.6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr2[0]=8;    #[8,5,6,7]</span></div><div class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]<span class="comment">//arr1.push(arr1.shift());#[5,6,7,8]</span></div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md" target="_blank" rel="external">You-Dont-Know-JS:: Up &amp; Going</a></li></ul><p>待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听公开课讲得一些JS笔试中容易出现的知识点。&lt;/p&gt;
&lt;p&gt;与其说是知识点，不如说是—“那些年走过的JS大坑”&lt;/p&gt;
&lt;p&gt;一般关于JS的笔试会走两极端—-要么很基础的知识点，要么考察最新JS框架（或结合公司已使用技术）&lt;/p&gt;
    
    </summary>
    
      <category term="编程开发" scheme="http://binlv.top/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="面筋" scheme="http://binlv.top/tags/%E9%9D%A2%E7%AD%8B/"/>
    
      <category term="JavaScript" scheme="http://binlv.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>RHEL7.0日志分析记录</title>
    <link href="http://binlv.top/2017/12/20/20171220-RHEL7.0%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"/>
    <id>http://binlv.top/2017/12/20/20171220-RHEL7.0日志分析记录/</id>
    <published>2017-12-20T00:20:00.000Z</published>
    <updated>2017-12-21T06:03:29.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近一个客户服务老挂，检查服务器，无法ping通且登录界面黑屏，只能强行重启，尝试检查日志发现默认日志为重启删除，坑。</p><a id="more"></a><p><strong>服务器信息</strong></p><ul><li>Red Hat Enterprise Linux Server release 7.0 (Maipo)</li></ul><h1 id="日志相关回顾"><a href="#日志相关回顾" class="headerlink" title="日志相关回顾"></a>日志相关回顾</h1><p>一般位置：<code>/var/log</code></p><h2 id="常见日志："><a href="#常见日志：" class="headerlink" title="常见日志："></a>常见日志：</h2><ul><li><p>/var/log/boot.log</p><p>顾名思义，系统启动日志，仅保留本次开机</p></li><li><p>/var/log/cron</p><p>所有<code>crontab</code>计划任务日志</p></li><li><p>/var/log/lastlog</p><p>记录系统所有账号最后登录信息</p></li></ul><ul><li><p>/var/log/maillog &amp;  /var/log/mail/*</p><p>往来邮件日志记录</p></li><li><p>/var/log/messages</p><p>系统重要信息基本都在这，为必看日志</p></li><li><p>/var/log/secure</p><p>凡是需要账号密码的日志都在里面</p></li></ul><h2 id="主要进程服务-daemon"><a href="#主要进程服务-daemon" class="headerlink" title="主要进程服务(daemon)"></a>主要进程服务(daemon)</h2><ul><li>systemd-journald.service  7系列版本新增，默认存在内存中，重启即失效，本次日志分析主要用的</li><li>rsyslog.service 记录系统和网络的信息，配置文件<code>/etc/rsyslog.conf</code></li><li>logrotate 用于日志自动化处理的服务，配置文件<code>/etc/logrotate.conf</code></li></ul><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><ul><li>debug </li><li>info</li><li>notice</li><li>warning(warn) </li><li>err(error)  重大错误信息</li><li>crit</li><li>alert</li><li>emerg(panic)</li></ul><blockquote><p>注：在讯息等级之前还有.[=!] 的连结符号，代表的意思是这样的：</p><ul><li>.：代表『比后面还要严重的等级(含该等级)都被记录下来』的意思，例如： mail.info代表只要是mail的资讯，而且该资讯等级严重于info (含info本身)时，就会被记录下来的意思。</li><li>.=：代表所需要的等级就是后面接的等级而已，其他的不要！</li><li>.!：有点反向选择的感觉，代表忽略大于等于这个等级的讯息！亦即是低于这个等级的才会被纪录的意思！</li></ul></blockquote><h1 id="使用journalctl查看日志"><a href="#使用journalctl查看日志" class="headerlink" title="使用journalctl查看日志"></a>使用journalctl查看日志</h1><h2 id="journalctl命令"><a href="#journalctl命令" class="headerlink" title="journalctl命令"></a>journalctl命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl [-nrpf] [--since TIME] [--until TIME] _optional </span></div><div class="line">选项与参数：</div><div class="line">预设会show出全部的<span class="built_in">log</span> 内容，从旧的输出到最新的日志</div><div class="line">-n ：show出最近的几行的意思～找最新的日志相当有用</div><div class="line">-r ：反向输出，从最新的输出到最旧的资料</div><div class="line">-p ：show出后面所接的日志重要性排序！</div><div class="line">-f ：类似tail -f 的功能，持续显示journal 日志的内容(即时监测时相当有帮助！)</div><div class="line">--since --until：设定开始与结束的时间，让在该期间的资料输出而已</div><div class="line">_SYSTEMD_UNIT=unit.service ：只输出unit.service 的日志而已</div><div class="line">_COMM=bash ：只输出与bash 有关的日志</div><div class="line">_PID=pid ：只输出PID 号码的日志</div><div class="line">_UID=uid ：只输出UID 为uid 的日志</div><div class="line">SYSLOG_FACILITY=[0-23] ：使用syslog.h 规范的服务相对序号来呼叫出正确的资料！</div></pre></td></tr></table></figure><p>例子：</p><p>查看特定优先级日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl -p err</span></div></pre></td></tr></table></figure><p>查看特定时间日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl --since "2017-12-17" --until "2017-12-19"</span></div></pre></td></tr></table></figure><p>显示本次启动后日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># journalctl -b [-0/-1/-2] #-0表本次启动信息，-1表上次启动</span></div></pre></td></tr></table></figure><h2 id="永久保存记录办法"><a href="#永久保存记录办法" class="headerlink" title="永久保存记录办法"></a>永久保存记录办法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@binlv ~]<span class="comment"># mkdir /var/log/journal</span></div><div class="line">[root@binlv ~]<span class="comment"># chown root:systemd-journal /var/log/journal/</span></div><div class="line">[root@binlv ~]<span class="comment"># chmod 2755 /var/log/journal/</span></div><div class="line">[root@binlv ~]<span class="comment"># killall -USR1 systemd-journald</span></div></pre></td></tr></table></figure><blockquote><p>注：默认情况下，日志大小不能超过所处文件系统的10%，也不可使所处文件系统空间低于15%。在 /etc/systemd/journald.conf 可进行大小容量上的调节；而在 /etc/logrotate.conf 则定义了那些日志文件记录、怎么记录、记录多少。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.linuxidc.com/Linux/2016-01/127729.htm" target="_blank" rel="external">RHEL7.0日志系统</a></li><li><a href="http://linux.vbird.org/linux_basic/0570syslog.php#whatis_syslog_1" target="_blank" rel="external">鸟哥私房菜之syslog</a></li><li><a href="http://www.cnblogs.com/itxdm/p/Systemd_log_system_journalctl.html" target="_blank" rel="external">Systemd 日志系统</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近一个客户服务老挂，检查服务器，无法ping通且登录界面黑屏，只能强行重启，尝试检查日志发现默认日志为重启删除，坑。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="log" scheme="http://binlv.top/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>NBU catalog报错处理办法</title>
    <link href="http://binlv.top/2017/12/08/20171208-NBU%20catalog%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://binlv.top/2017/12/08/20171208-NBU catalog报错处理办法/</id>
    <published>2017-12-08T04:19:12.000Z</published>
    <updated>2017-12-10T14:19:26.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h1><ul><li><p>环境说明：</p><ul><li>NBU 7.7.3 Master Server</li><li>Windows Server 2008R2 x64操作系统</li></ul></li><li><p>NBU Master Server备份catalog一直报错，错误代码2</p><ul><li><p>status详细信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging relational database files <span class="keyword">for</span> catalog backup</div><div class="line">2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:24 - Info bpdbm (pid=12608) staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:30 - Info bpdbm (pid=12608) <span class="keyword">done</span> staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBAZDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</div><div class="line">2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging</div><div class="line">2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBDB backup <span class="keyword">in</span> C:\Program Files\Veritas\NetBackupDB\staging.</div><div class="line">none of the requested files were backed up  (2)</div></pre></td></tr></table></figure></li></ul></li><li><p>检查系统进程 已运行700+进程，怀疑进程过多导致Master hang死</p></li></ul><a id="more"></a><h1 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h1><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>根据报错信息，定位<code>C:\Program Files\Veritas\NetBackupDB\staging</code>目录，删除该目录文件，重启服务后手动发起catalog备份，成功。</p><p>第二天再发起再次报错，非长久之计。</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>报case，协助工程师收集cab。</p><p>对于Windows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">C:\windows\system32\chcp 437</div><div class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -use_reg_cmd 64 (<span class="keyword">for</span> 64bit)</div></pre></td></tr></table></figure><p>执行nbsu到network service卡住，询问工程师终止命令，执行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files\Veritas\netbackup\bin\support\nbsu -c -use_reg_cmd 64</div></pre></td></tr></table></figure><p>产生LOG 的路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Program Files\Veritas\netbackup\bin\support\output\nbsu (后缀名是cab)</div></pre></td></tr></table></figure><p>后操作如下</p><ol><li><p>Delete the outstanding nbtelemetry.exe processes in task manager, this in turn stopped the nbtelesched.exe processes. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tasklist</div><div class="line">taskkill /im nbtelemetry.exe /f</div></pre></td></tr></table></figure><p>强制结束进程</p></li><li><p>Once these were deleted, went into directory Program files\Veritas\Netbackup\bin<br>Renamed nbtelemetry.exe and nbtelesched.exe to nbtelemetry.exe.old and nbtelesched.exe.old. </p><p>若无法重命名，重启机器再修改</p></li><li><p>Run regedit and go to the following key<br>HKLM(HKEY_LOCAL_MACHINE)\Software\VERITAS\NetBackup\CurrentVersion\Config\TELEMETRY_UPLOAD<br>Changed TELEMETRY_UPLOAD from YES to NO under the registry editor.</p><p>再次发起catalog备份，正常。</p></li></ol><p>观察几天，进程数不超过100，且备份catalog不报错.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="NBU-catalog"><a href="#NBU-catalog" class="headerlink" title="NBU catalog"></a>NBU catalog</h2><p>NetBackup自身有一索引数据库，主要记录每次备份的相关信息。比如从哪个Client备<br>份的，保留多长时间等。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;环境说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NBU 7.7.3 Master Server&lt;/li&gt;
&lt;li&gt;Windows Server 2008R2 x64操作系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NBU Master Server备份catalog一直报错，错误代码2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;status详细信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging relational database files &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; catalog backup&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:23 - Info bpdbm (pid=12608) staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:24 - Info bpdbm (pid=12608) &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; staging NBAZDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:24 - Info bpdbm (pid=12608) staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:30 - Info bpdbm (pid=12608) &lt;span class=&quot;keyword&quot;&gt;done&lt;/span&gt; staging NBDB backup to C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBAZDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBAZDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Info bpdbm (pid=12608) validating NBDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2017-12-8 8:40:59 - Error bpdbm (pid=12608) error validating NBDB backup &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; C:\Program Files\Veritas\NetBackupDB\staging.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;none of the requested files were backed up  (2)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检查系统进程 已运行700+进程，怀疑进程过多导致Master hang死&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Netbackup" scheme="http://binlv.top/tags/Netbackup/"/>
    
  </entry>
  
  <entry>
    <title>Oracle参数文件</title>
    <link href="http://binlv.top/2017/12/05/20171205-Oracle%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6/"/>
    <id>http://binlv.top/2017/12/05/20171205-Oracle参数文件/</id>
    <published>2017-12-05T14:20:00.000Z</published>
    <updated>2017-12-10T14:21:36.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为平时做数据库恢复需检查pfile文件，对这方面空白较多，查了点资料，详细了解一下。</p><a id="more"></a><h1 id="参数文件类型"><a href="#参数文件类型" class="headerlink" title="参数文件类型"></a>参数文件类型</h1><p>pfile –parameter file 文本文件</p><p>spfile –server parameter file  二进制文件</p><p>9i后才有，通过alter system 修改到spfile 下次启动生效</p><h2 id="pfile"><a href="#pfile" class="headerlink" title="pfile"></a>pfile</h2><p>作用：文件记录数据库配置与功能开启或关闭</p><p>数据库启动时需读取参数文件内容，实例启动后就一直在内存中。</p><p>文件位置：通过dbca图形工具建立数据库，有一个模板参数文件pfile</p><p><code>$ORACLE_BASE/admin/&lt;db_unique_name&gt;/pfile/init.ora.&lt;n+&gt;</code></p><p>修改到参数文件达到时候需要关闭数据库然后才有效</p><p>10g后只有spfile <code>$ORACLE_BASE/dbs/spfile$ORACLE_SID.ora</code></p><p>手工建库没有模板参数文件</p><p>##spfile</p><p>通过pfile文件可以定义spfile=’’路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sql&gt; show parameter spfile</div></pre></td></tr></table></figure><p>数据库读取参数文件顺序</p><ol><li><code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code></li><li><code>ORACLE_HOME/dbs/spfile.ora</code></li><li><code>ORACLE_HOME/dbs/init&lt;SID&gt;.ora</code></li></ol><blockquote><p>注：</p><p>若维护的是RAC，不要执行create pfile from spfile;</p><p>因为若spfile文件丢失，启动一个实例，执行create spfile from pfile;后sfile会存放在<code>ORACLE_HOME/dbs/spfile&lt;SID&gt;.ora</code>，再启动一个实例后会想修改参数文件会报错，为非共享文件。</p><p>维护ASM存放参数文件也不能使用create pfile命令</p></blockquote><h1 id="修改参数文件"><a href="#修改参数文件" class="headerlink" title="修改参数文件"></a>修改参数文件</h1><h2 id="修改pfile"><a href="#修改pfile" class="headerlink" title="修改pfile"></a>修改pfile</h2><p>pfile一般修改需要重启数据库才能生效</p><p>startup force</p><h2 id="修改spfile"><a href="#修改spfile" class="headerlink" title="修改spfile"></a>修改spfile</h2><p>参数分类：</p><p>系统参数：alter system set 参数=值 scope=memory|spfile|both [sid=’…’];</p><p>会话参数 alter session set 参数=值;</p><p>系统参数的分类：</p><ol><li>动态 alter system set 参数=值; alter system set 参数=值 scope=memory;</li><li>静态 alter system set 参数=值 scope=spfile;</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;因为平时做数据库恢复需检查pfile文件，对这方面空白较多，查了点资料，详细了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="pfile" scheme="http://binlv.top/tags/pfile/"/>
    
      <category term="spfile" scheme="http://binlv.top/tags/spfile/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Hexo+SSL搭建个人站点</title>
    <link href="http://binlv.top/2017/11/28/20171128-Nginx-Hexo-SSL%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"/>
    <id>http://binlv.top/2017/11/28/20171128-Nginx-Hexo-SSL搭建个人站点/</id>
    <published>2017-11-28T06:09:02.000Z</published>
    <updated>2018-02-25T13:35:53.226Z</updated>
    
    <content type="html"><![CDATA[<p>给闲置VPS增加点用处系列</p><a id="more"></a><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx相关安装配置参照我的<a href="https://binlv.top/2017/11/27/20171127-部署Nginx服务与基本配置/">上一篇关于Nginx配置的文章</a></p><h1 id="Hexo-部署至Nginx"><a href="#Hexo-部署至Nginx" class="headerlink" title="Hexo 部署至Nginx"></a>Hexo 部署至Nginx</h1><p>一般有三种方法</p><ul><li>git设置git hook方式</li><li>rsync同步本地Hexo至VPS</li><li>VPS上部署Hexo，并执行<code>hexo server</code> ，再配置Nginx反向代理，让域名指向 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></li></ul><h2 id="git-hook方式"><a href="#git-hook方式" class="headerlink" title="git hook方式"></a>git hook方式</h2><h3 id="配置服务器环境"><a href="#配置服务器环境" class="headerlink" title="配置服务器环境"></a>配置服务器环境</h3><p>安装git并创建仓库，设置git hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-get install git -y</div><div class="line">mkdir &lt;git工作目录&gt; &amp;&amp; <span class="built_in">cd</span> &lt;git工作目录&gt;</div><div class="line">git init --bare</div><div class="line">nano &lt;git工作目录&gt;/hook/post-reveive</div></pre></td></tr></table></figure><p>将以下内容修改好放入<code>post-reveive</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">GIT_REPO=/var/www/blog.git  <span class="comment">#git仓库</span></div><div class="line">TMP_GIT_CLONE=/tmp/blog</div><div class="line">PUBLIC_WWW=/var/www/blog <span class="comment">#网站目录</span></div><div class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></div><div class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></div><div class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></div></pre></td></tr></table></figure><p>或使用如下命令放入<code>post-reveive</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/bin/bash -l</span></div><div class="line">git --work-tree=/var/www/blog --git-dir=/var/www/blog.git checkout -f</div></pre></td></tr></table></figure><p>赋予执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive</div></pre></td></tr></table></figure><h3 id="在本机配置"><a href="#在本机配置" class="headerlink" title="在本机配置"></a>在本机配置</h3><p>在博客目录下运行下面命令，安装 git 部署工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>修改博客的配置文件 _config.yml，修改deploy选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy: </div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: 用户名@服务器地址:/var/www/blog.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure><h1 id="开启站点HTTPS"><a href="#开启站点HTTPS" class="headerlink" title="开启站点HTTPS"></a>开启站点HTTPS</h1><p>https需要授权证书，这里使用的是<a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>家的免费证书。</p><p>对了，要开启HTTPS首先你得有个人域名，因为证书是给域名授权的。至于域名申请，万网之类的都行，然后解析指向你的服务器。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install letsencrypt</div></pre></td></tr></table></figure><p>获取证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">letsencrypt certonly</div></pre></td></tr></table></figure><p>根据提示完成获取，中间需要输入你的域名，最后出现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- Congratulations! Your certificate and chain have been saved at</div><div class="line">  /etc/letsencrypt/live/&lt;你的域名&gt;/fullchain.pem. Your cert will</div><div class="line">  expire on 2017-09-17. To obtain a new or tweaked version of this</div><div class="line">  certificate <span class="keyword">in</span> the future, simply run certbot-auto again. To</div><div class="line">  non-interactively renew *all* of your certificates, run</div><div class="line">  <span class="string">"certbot-auto renew"</span></div><div class="line">- If you like Certbot, please consider supporting our work by:</div><div class="line"></div><div class="line">  Donating to ISRG / Let<span class="string">'s Encrypt:   https://letsencrypt.org/donate</span></div><div class="line"><span class="string">  Donating to EFF:                    https://eff.org/donate-le</span></div></pre></td></tr></table></figure><p>  就成功了，看提示，所有的证书文件在 <code>/etc/letsencrypt/live/你的域名</code>下，里面有下面几个文件证书文件，引用别人的解释下：</p><blockquote><ul><li><code>privkey.pem</code></li></ul><p>这是私匙，对应 Nginx 的 ssl_certificate_key 选项，或者 Apache2 的 SSLCertificateKeyFile 选项。</p><ul><li><code>cert.pem</code> </li></ul><p>服务器证书，这个只有 Apache2 低于 2.4.8 版本需要，对应 SSLCertificateFile 选项。</p><ul><li><code>chain.pem</code></li></ul><p>除服务器证书之外的所有证书，对于 1.3.7 版以上的 Nginx 对应 ssl_trusted_certificate 选项，对于低于2.4.8 的 Apache2 对应 SSLCertificateChainFile 选项。</p><ul><li><code>fullchain.pem</code></li></ul><p>包括上面的服务器证书和其他证书, Nginx 对应 ssl_certificate 选项，2.4.8 版以上的 Apache2 对应 SSLCertificateFile 选项。</p><p>如果是 Nginx，需要上面的 privkey.pem（对应 ssl_certificate_key 选项）和 fullchain.pem （对应 ssl_certificate 选项），还需要一个 dhparam.pem（对应 ssl_dhparam 选项） 需自己生成：</p><p>openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</p><p>这个文件创建稍微需要一点时间，注意看我的路径，我的是在 /etc/nginx/ssl/ 下，如果没有ssl这个目录就自己建一个，当然你换其他地方也行。</p></blockquote><p>有了这三个文件: <code>privkey.pem</code>、<code>fullchain.pem</code> 、<code>dhparam.pem</code> 就可以配置 Nginx 了。</p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name binlv.top;</div><div class="line">    <span class="comment">#实现访问http的时候自动跳转到https</span></div><div class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">        listen 443 ssl http2;</div><div class="line">    listen [::]:443 ssl http2;</div><div class="line">    server_name binlv.top;</div><div class="line">    </div><div class="line">    <span class="comment">#不输出 Nginx 版本号及其他错误信息</span></div><div class="line">    server_tokens off;</div><div class="line">    </div><div class="line">    <span class="comment"># 开启 HSTS,这么写是为了提交到 https://hstspreload.org/</span></div><div class="line">        add_header Strict-Transport-Security <span class="string">"max-age=31536000; includeSubDomains"</span> always;</div><div class="line">        <span class="comment"># 启用 XSS 保护，检查到 XSS 攻击时，停止渲染页面。</span></div><div class="line">    add_header X-XSS-Protection <span class="string">"1; mode=block"</span>;</div><div class="line">    </div><div class="line">        ssl_certificate /etc/letsencrypt/live/binlv.top/fullchain.pem;</div><div class="line">        ssl_certificate_key /etc/letsencrypt/live/binlv.top/privkey.pem;</div><div class="line">        ssl_dhparam /etc/nginx/ssl/dhparam.pem;</div><div class="line">        ssl_session_cache shared:SSL:50m;</div><div class="line">        ssl_session_timeout 1d;</div><div class="line">        ssl_session_tickets off;</div><div class="line">        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">        ssl_ciphers <span class="string">'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'</span>;</div><div class="line">        ssl_prefer_server_ciphers on;</div><div class="line">        ssl_stapling on;</div><div class="line">        ssl_stapling_verify on;</div><div class="line">    </div><div class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></div><div class="line">    location / &#123;</div><div class="line">        root /var/www/blog;</div><div class="line">        index index.php index.htm index.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更新配置后要重启一下Nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart nginx</div></pre></td></tr></table></figure></p><h2 id="设置证书自动更新"><a href="#设置证书自动更新" class="headerlink" title="设置证书自动更新"></a>设置证书自动更新</h2><p>Let’s Encrypt SSL 免费证书为短期证书，只有 90 天期限，提示到期前可以运行命令 <code>letsencrypt renew</code> 续期</p><p>实现定时更新证书，我们可以用linux自带的定时器crontab<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ crontab -e</div></pre></td></tr></table></figure></p><p>输入：　<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　　30 2 1 * * /usr/bin/letsencrypt renew &gt;&gt; /var/<span class="built_in">log</span>/letsencrypt/le-renew.log</div><div class="line">　　35 2 1 * * /usr/bin/systemctl reload nginx</div></pre></td></tr></table></figure></p><h2 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h2><p>如果想把授权的域名取消该怎么办呢？因为免费证书如果不定期更新的话几个月就会自动过期，所以删掉本地部署时对应创建的几个文件就行啦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rm -rf /etc/letsencrypt/live/www.example.com/</div><div class="line">rm -rf /etc/letsencrypt/archive/www.example.com/</div><div class="line">rm /etc/letsencrypt/renewal/www.example.com.conf</div></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>很多。。。</p><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-centos-7" target="_blank" rel="external">CentOS 7配置Nginx+SSL，参考</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="external">git hooks 官方文档</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给闲置VPS增加点用处系列&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://binlv.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://binlv.top/tags/Nginx/"/>
    
      <category term="Hexo" scheme="http://binlv.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>部署Nginx服务与基本配置</title>
    <link href="http://binlv.top/2017/11/27/20171127-%E9%83%A8%E7%BD%B2Nginx%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://binlv.top/2017/11/27/20171127-部署Nginx服务与基本配置/</id>
    <published>2017-11-27T03:01:06.000Z</published>
    <updated>2018-01-24T06:38:22.380Z</updated>
    
    <content type="html"><![CDATA[<p>个人站点原部署在<a href="https://github.com/baylin87/baylin87.github.io" target="_blank" rel="external">GitHub</a>，借助其<a href="https://pages.github.com/" target="_blank" rel="external">GitHub-Pages</a>功能实现免费的个人站点部署。后考虑到VPS资源闲置，加上GitHub-Pages貌似不能用<code>https</code>，就想迁移过去玩玩。</p><p>当然，实现方法有很多，我选的是用Nginx + Hexo部署。</p><a id="more"></a><h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><ul><li>操作系统：Ubuntu 16.04.2 LTS (xenial)</li><li>Nginx version : nginx/1.12.2  built with OpenSSL 1.0.2g</li></ul><h1 id="Nginx相关"><a href="#Nginx相关" class="headerlink" title="Nginx相关"></a>Nginx相关</h1><p>Nginx安装与配置。</p><h2 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h2><p>Ubuntu 有对应apt安装包，但需配置。</p><p>1.获取Nginx认证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://nginx.org/keys/nginx_signing.key</div></pre></td></tr></table></figure><p>2.将该key添加到apt中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-key add nginx_signing.key</div></pre></td></tr></table></figure><p>3.添加nginx软件源</p><p>For Ubuntu replace codename with Ubuntu distribution codename, and append the following to the end of the <code>etc/apt/sources.list</code>file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://nginx.org/packages/ubuntu/ xenial nginx</div><div class="line">deb-src http://nginx.org/packages/ubuntu/ xenial nginx</div></pre></td></tr></table></figure><p>4.更新源并安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt-get install nginx</div></pre></td></tr></table></figure><p>5.启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start nginx</div></pre></td></tr></table></figure><p>6.默认nginx配置文件路径</p><p><code>/usr/local/nginx/conf</code>,<code>/etc/nginx</code>, or<code>/usr/local/etc/nginx</code></p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>编辑 <code>/etc/nginx/conf.d/xx.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 80;</div><div class="line">        server_name binlv.top;</div><div class="line"><span class="comment">#实现访问http的时候自动跳转到https</span></div><div class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">        listen 443 ssl http2;</div><div class="line">listen [::]:443 ssl http2;</div><div class="line">server_name binlv.top;</div><div class="line"></div><div class="line"><span class="comment">#不输出 Nginx 版本号及其他错误信息</span></div><div class="line">server_tokens off;</div><div class="line"></div><div class="line">    <span class="comment">#设置根目录，必须为已存在目录</span></div><div class="line">    location / &#123;</div><div class="line">        root &lt;--路径--&gt;;</div><div class="line">        index index.php index.htm index.html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart nginx</div></pre></td></tr></table></figure><p>使nginx开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> nginx</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://nginx.org/en/docs/" target="_blank" rel="external">Nginx document</a></li></ul><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人站点原部署在&lt;a href=&quot;https://github.com/baylin87/baylin87.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;，借助其&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub-Pages&lt;/a&gt;功能实现免费的个人站点部署。后考虑到VPS资源闲置，加上GitHub-Pages貌似不能用&lt;code&gt;https&lt;/code&gt;，就想迁移过去玩玩。&lt;/p&gt;
&lt;p&gt;当然，实现方法有很多，我选的是用Nginx + Hexo部署。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://binlv.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://binlv.top/2017/10/12/20171012-iptables/"/>
    <id>http://binlv.top/2017/10/12/20171012-iptables/</id>
    <published>2017-10-12T02:20:00.000Z</published>
    <updated>2018-01-24T06:39:45.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables完全控制"><a href="#iptables完全控制" class="headerlink" title="iptables完全控制"></a>iptables完全控制</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>搭建一套企业实际使用的防火墙规则</li><li>防攻击</li><li>数据包转发</li><li>实际使用意义</li></ol><a id="more"></a><h2 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h2><p>—Linux用于数据包处理，iptables会调用其使用</p><h2 id="Hook-point"><a href="#Hook-point" class="headerlink" title="Hook point"></a>Hook point</h2><p>—数据包在Netfilter中的挂载点</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-01.png" alt="Netfilter与iptables关系"></p><h2 id="iptables规则组成"><a href="#iptables规则组成" class="headerlink" title="iptables规则组成"></a>iptables规则组成</h2><p><strong>4表5链</strong><br>表：filter、nat、mangle、raw<br>链：INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING</p><p><strong>作用：</strong></p><p>mangle:修改数据包，改变包头内容（TTL、TOS、MARK）<br>raw：数据包状态跟踪分析</p><p>filter：访问控制、规则匹配<br>nat：地址转发</p><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-02.png" alt="数据包在规则表、链匹配流程"></p><h2 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h2><ol><li>访问控制：ACCEPT、DROP、REJECT</li><li>改写数据包：SNAT、DNAT</li><li>信息记录：LOG</li></ol><h2 id="规则组成"><a href="#规则组成" class="headerlink" title="规则组成"></a>规则组成</h2><p><img src="http://olvboulzy.bkt.clouddn.com/20171012-iptables-03.png" alt="iptables规则组成"></p><hr><h1 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -I INPUT -p tcp dprot 80 -j ACCEPT</div></pre></td></tr></table></figure><p>待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables完全控制&quot;&gt;&lt;a href=&quot;#iptables完全控制&quot; class=&quot;headerlink&quot; title=&quot;iptables完全控制&quot;&gt;&lt;/a&gt;iptables完全控制&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;搭建一套企业实际使用的防火墙规则&lt;/li&gt;
&lt;li&gt;防攻击&lt;/li&gt;
&lt;li&gt;数据包转发&lt;/li&gt;
&lt;li&gt;实际使用意义&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://binlv.top/tags/Linux/"/>
    
      <category term="iptables" scheme="http://binlv.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>ansible初步</title>
    <link href="http://binlv.top/2017/09/01/20170901-ansible%E5%88%9D%E6%AD%A5/"/>
    <id>http://binlv.top/2017/09/01/20170901-ansible初步/</id>
    <published>2017-09-01T02:19:12.000Z</published>
    <updated>2017-09-23T01:47:52.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h1><ul><li>了解ansible能做什么</li><li>了解ansible部署环境</li><li>安装ansible管理主机</li></ul><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.ansible.com/" target="_blank" rel="external">ansible官方</a></li><li><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible的github Project</a></li><li><a href="http://ansible-tran.readthedocs.io" target="_blank" rel="external">ansible中文权威指南</a></li></ul><h1 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h1><h2 id="why-ansible"><a href="#why-ansible" class="headerlink" title="why ansible?"></a>why ansible?</h2><p>引用ansible在github上的介绍：</p><blockquote><p>Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applications— automate in a language that approaches plain English, using SSH, with no agents to install on remote systems. </p></blockquote><p>简单说就是运维自动化，减少重复部署，使用SSH协议，且无需安装客户端。</p><p>要说缺点嘛，管理主机不能是Windows，Nagios也是==。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><ul><li>Python2.6以上</li><li>Linux/Unix各发行版</li></ul><p>安装过程略。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170901-ansible01.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="python模块"></p><p>本机环境</p><ul><li>Ubuntu 16.04.3 LTS (GNU/Linux 4.10.0-28-generic x86_64)</li><li>Python 2.7.12</li><li>OpenSSH_7.2p2 Ubuntu-4ubuntu2.2, OpenSSL 1.0.2g  1 Mar 2016</li><li>ansible 2.0.0.2</li></ul><h2 id="ansible连接远程主机原理"><a href="#ansible连接远程主机原理" class="headerlink" title="ansible连接远程主机原理"></a>ansible连接远程主机原理</h2><p>默认会在本地的 OpenSSH可用时会尝试用其进行远程通讯.这会启用ControlPersist(一个性能特性,SSH_5.6以上支持),<a href="https://zh.wikipedia.org/zh-hans/Kerberos" target="_blank" rel="external">Kerberos</a>,和在~/.ssh/config中的配置选项如 Jump Host setup.然而,当你使用Linux企业版6作为主控机(红帽企业版及其衍生版如CentOS),其OpenSSH版本可能过于老旧无法支持ControlPersist. 在这些操作系统中,Ansible将会退回并采用 paramiko (由Python实现的高质量OpenSSH库). 如果你希望能够使用像是Kerberized SSH之类的特性,烦请考虑使用Fedora, OS X, 或 Ubuntu 作为你的主控机直到相关平台上有更新版本的OpenSSH可供使用,或者启用Ansible的“accelerated mode”.</p><h2 id="添加受控主机"><a href="#添加受控主机" class="headerlink" title="添加受控主机"></a>添加受控主机</h2><p>将管理主机公钥添加到受控主机的.ssh/authorized_keys文件中。</p><p>最快的方法是使用<code>ssh_copy_id</code>命令。</p><p>添加好测试一下。</p><p>然后编辑<code>/etc/ansible/hosts</code>文件，将受控主机IP地址添加到文件中。</p><p>执行<code>ansible all -m ping</code>，如返回<code>SUCCESS</code>则成功，如其他，则可使用<code>-vvvv</code>参数输出详细log，排错。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Purpose&quot;&gt;&lt;a href=&quot;#Purpose&quot; class=&quot;headerlink&quot; title=&quot;Purpose&quot;&gt;&lt;/a&gt;Purpose&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;了解ansible能做什么&lt;/li&gt;
&lt;li&gt;了解ansible部署环境&lt;/li&gt;
&lt;li&gt;安装ansible管理主机&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="ansible" scheme="http://binlv.top/tags/ansible/"/>
    
      <category term="自动化运维" scheme="http://binlv.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>docker machine</title>
    <link href="http://binlv.top/2017/08/14/20170814-docker-machine/"/>
    <id>http://binlv.top/2017/08/14/20170814-docker-machine/</id>
    <published>2017-08-14T04:50:30.000Z</published>
    <updated>2017-10-02T05:42:23.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/machine/overview/" target="_blank" rel="external">官方参考文档</a></p><p><a href="https://yq.aliyun.com/articles/110806" target="_blank" rel="external">阿里Docker CE镜像源站</a></p></blockquote><h1 id="What-is-Docker-Machine"><a href="#What-is-Docker-Machine" class="headerlink" title="What is Docker Machine ?"></a>What is Docker Machine ?</h1><p>Docker Machine is <strong>a tool that lets you install Docker Engine on virtual hosts</strong>, and manage the hosts with <code>docker-machine</code> commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.</p><p>当在一台宿主机上安装docker，我们需要如下几个步骤（Ubuntu）</p><ol><li>安装 https CA 证书</li><li>添加 GPG key</li><li>添加 docker apt 源</li><li>安装 docker</li></ol><p>但对于多主机环境，每台都如此则显得重复工作且效率低下，因此有了docker-machine—能在多台主机上批量安装配置docker，主机可以是本地虚拟机、物理机、云主机等，支持环境如下：</p><ol><li>常规 Linux 操作系统</li><li>虚拟化平台 - VirtualBox、VMWare、Hyper-V</li><li>OpenStack</li><li>公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、Digital Ocean 等</li></ol><p>在docker machine中，都称之为Provider，不同Provider对应不同driver来安装配置docker host。</p><a id="more"></a><h1 id="Install-Docker-Machine"><a href="#Install-Docker-Machine" class="headerlink" title="Install Docker Machine"></a>Install Docker Machine</h1><ol><li><p>Install Docker </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure><p>If you would like to use Docker as a non-root user, you should now consider<br>adding your user to the “docker” group with something like:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod -aG docker &lt;your username&gt;</div></pre></td></tr></table></figure><p><strong><a href="https://yq.aliyun.com/articles/29941?spm=5176.100239.blogcont110806.19.d0XnVG" target="_blank" rel="external">配置镜像加速器</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /etc/docker</div><div class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"填入你的阿里云专属加速器地址"</span>]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl restart docker</div></pre></td></tr></table></figure><p>​</p></li><li><p>Download the Docker Machine binary and extract it to your PATH.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.12.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</div><div class="line">chmod +x /tmp/docker-machine &amp;&amp;</div><div class="line">sudo cp /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure><p>​</p></li><li><p>Check the installation by displaying the Machine version:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker-machine version</div><div class="line">docker-machine version 0.12.2, build 9371605</div></pre></td></tr></table></figure><p>​</p></li><li><p>Installing bash completion scripts</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scripts=( docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash ); <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;scripts[@]&#125;</span>"</span>; <span class="keyword">do</span> sudo wget https://raw.githubusercontent.com/docker/machine/v0.12.2/contrib/completion/bash/<span class="variable">$&#123;i&#125;</span> -P /etc/bash_completion.d; <span class="keyword">done</span></div></pre></td></tr></table></figure><p>To enable the <code>docker-machine</code> shell prompt, add <code>$(__docker_machine_ps1)</code> to your <code>PS1</code>setting in <code>~/.bashrc</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=<span class="string">'[\u@\h \W$(__docker_machine_ps1)]\$ '</span></div></pre></td></tr></table></figure></li></ol><h1 id="Use-Machine-to-run-Docker-containers"><a href="#Use-Machine-to-run-Docker-containers" class="headerlink" title="Use Machine to run Docker containers"></a>Use Machine to run Docker containers</h1><p>To run a Docker container,you:</p><ul><li>create a new(or start an exiting) Docker virtual machine</li><li>switch your environment to your new VM</li><li>use the docker client to create,load and manage containers</li></ul><h2 id="Machine-drivers—Generic"><a href="#Machine-drivers—Generic" class="headerlink" title="Machine drivers—Generic"></a>Machine drivers—Generic</h2><p>Create machines using an existing VM/Host with SSH.</p><p>This is useful if you are using a provider that Machine does not support directly or if you would like to import an existing host to allow Docker Machine to manage.</p><p>The driver will perform a list of tasks on create:</p><ul><li>If docker is not running on the host, it will be installed automatically.</li><li>It will update the host packages (<code>apt-get update</code>, <code>yum update</code>…).</li><li>It will generate certificates to secure the docker daemon.</li><li>The docker daemon will be restarted, thus all running containers will be stopped.</li><li>The hostname will be changed to fit the machine name.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic --generic-ip-address=192.168.56.104 host1</div></pre></td></tr></table></figure><h3 id="Sudo-privileges"><a href="#Sudo-privileges" class="headerlink" title="Sudo privileges"></a>Sudo privileges</h3><p>The user that is used to SSH into the host can be specified with <code>--generic-ssh-user</code> flag. This user has to have password-less sudo privileges. If it’s not the case, you need to edit the <code>sudoers</code>file and configure the user as a sudoer with <code>NOPASSWD</code>. See <a href="https://help.ubuntu.com/community/Sudoers" target="_blank" rel="external">https://help.ubuntu.com/community/Sudoers</a> .</p><h4 id="ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES"><a href="#ENVIRONMENT-VARIABLES-AND-DEFAULT-VALUES" class="headerlink" title="ENVIRONMENT VARIABLES AND DEFAULT VALUES"></a>ENVIRONMENT VARIABLES AND DEFAULT VALUES</h4><table><thead><tr><th>CLI option</th><th>Environment variable</th><th>Default</th></tr></thead><tbody><tr><td><code>--generic-engine-port</code></td><td><code>GENERIC_ENGINE_PORT</code></td><td><code>2376</code></td></tr><tr><td><strong>–generic-ip-address</strong></td><td><code>GENERIC_IP_ADDRESS</code></td><td>-</td></tr><tr><td><code>--generic-ssh-key</code></td><td><code>GENERIC_SSH_KEY</code></td><td>-</td></tr><tr><td><code>--generic-ssh-user</code></td><td><code>GENERIC_SSH_USER</code></td><td><code>root</code></td></tr><tr><td><code>--generic-ssh-port</code></td><td><code>GENERIC_SSH_PORT</code></td><td><code>22</code></td></tr></tbody></table><h2 id="create-过程："><a href="#create-过程：" class="headerlink" title="create 过程："></a>create 过程：</h2><p>① 通过 ssh 登录到远程主机。<br>② 安装 docker。<br>③ 拷贝证书。<br>④ 配置 docker daemon。<br>⑤ 启动 docker。</p><h1 id="Machine-CLI"><a href="#Machine-CLI" class="headerlink" title="Machine CLI"></a>Machine CLI</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line"></div><div class="line">  --debug, -DEnable debug mode</div><div class="line"></div><div class="line">  --storage-path, -s "/home/binlv/.docker/machine"Configures storage path [$MACHINE_STORAGE_PATH]</div><div class="line"></div><div class="line">  --tls-ca-cert CA to verify remotes against [$MACHINE_TLS_CA_CERT]</div><div class="line"></div><div class="line">  --tls-ca-key Private key to generate certificates [$MACHINE_TLS_CA_KEY]</div><div class="line"></div><div class="line">  --tls-client-cert Client cert to use for TLS [$MACHINE_TLS_CLIENT_CERT]</div><div class="line"></div><div class="line">  --tls-client-key Private key used in client TLS auth [$MACHINE_TLS_CLIENT_KEY]</div><div class="line"></div><div class="line">  --github-api-token Token to use for requests to the Github API [$MACHINE_GITHUB_API_TOKEN]</div><div class="line"></div><div class="line">  --native-sshUse the native (Go-based) SSH implementation. [$MACHINE_NATIVE_SSH]</div><div class="line"></div><div class="line">  --bugsnag-api-token BugSnag API token for crash reporting [$MACHINE_BUGSNAG_API_TOKEN]</div><div class="line"></div><div class="line">  --help, -hshow help</div><div class="line"></div><div class="line">  --version, -vprint the version</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Commands:</div><div class="line"></div><div class="line">  activePrint which machine is active</div><div class="line"></div><div class="line">  configPrint the connection config for machine</div><div class="line"></div><div class="line">  createCreate a machine</div><div class="line"></div><div class="line">  envDisplay the commands to set up the environment for the Docker client</div><div class="line"></div><div class="line">  inspectInspect information about a machine</div><div class="line"></div><div class="line">  ipGet the IP address of a machine</div><div class="line"></div><div class="line">  killKill a machine</div><div class="line"></div><div class="line">  lsList machines</div><div class="line"></div><div class="line">  provisionRe-provision existing machines</div><div class="line"></div><div class="line">  regenerate-certsRegenerate TLS Certificates for a machine</div><div class="line"></div><div class="line">  restartRestart a machine</div><div class="line"></div><div class="line">  rmRemove a machine</div><div class="line"></div><div class="line">  sshLog into or run a command on a machine with SSH.</div><div class="line"></div><div class="line">  scpCopy files between machines</div><div class="line"></div><div class="line">  startStart a machine</div><div class="line"></div><div class="line">  statusGet the status of a machine</div><div class="line"></div><div class="line">  stopStop a machine</div><div class="line"></div><div class="line">  upgradeUpgrade a machine to the latest version of Docker</div><div class="line"></div><div class="line">  urlGet the URL of a machine</div><div class="line"></div><div class="line">  versionShow the Docker Machine version or a machine docker version</div><div class="line"></div><div class="line">  helpShows a list of commands or help for one command</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/machine/overview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/110806&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里Docker CE镜像源站&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;What-is-Docker-Machine&quot;&gt;&lt;a href=&quot;#What-is-Docker-Machine&quot; class=&quot;headerlink&quot; title=&quot;What is Docker Machine ?&quot;&gt;&lt;/a&gt;What is Docker Machine ?&lt;/h1&gt;&lt;p&gt;Docker Machine is &lt;strong&gt;a tool that lets you install Docker Engine on virtual hosts&lt;/strong&gt;, and manage the hosts with &lt;code&gt;docker-machine&lt;/code&gt; commands. You can use Machine to create Docker hosts on your local Mac or Windows box, on your company network, in your data center, or on cloud providers like Azure, AWS, or Digital Ocean.&lt;/p&gt;
&lt;p&gt;当在一台宿主机上安装docker，我们需要如下几个步骤（Ubuntu）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 https CA 证书&lt;/li&gt;
&lt;li&gt;添加 GPG key&lt;/li&gt;
&lt;li&gt;添加 docker apt 源&lt;/li&gt;
&lt;li&gt;安装 docker&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但对于多主机环境，每台都如此则显得重复工作且效率低下，因此有了docker-machine—能在多台主机上批量安装配置docker，主机可以是本地虚拟机、物理机、云主机等，支持环境如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常规 Linux 操作系统&lt;/li&gt;
&lt;li&gt;虚拟化平台 - VirtualBox、VMWare、Hyper-V&lt;/li&gt;
&lt;li&gt;OpenStack&lt;/li&gt;
&lt;li&gt;公有云 - Amazon Web Services、Microsoft Azure、Google Compute Engine、Digital Ocean 等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在docker machine中，都称之为Provider，不同Provider对应不同driver来安装配置docker host。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="http://binlv.top/tags/Docker/"/>
    
      <category term="docker-machine" scheme="http://binlv.top/tags/docker-machine/"/>
    
  </entry>
  
  <entry>
    <title>docker单主机网络管理实践</title>
    <link href="http://binlv.top/2017/08/05/20170805-docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    <id>http://binlv.top/2017/08/05/20170805-docker网络管理/</id>
    <published>2017-08-05T02:36:08.000Z</published>
    <updated>2017-09-23T01:43:36.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>容器作为应用，必然需要与外界通信，包括容器之间和外部网络。</p><p>Docker网络从覆盖范围分</p><ul><li>单台主机上的容器网络★</li><li>跨多台主机的容器网络</li></ul><a id="more"></a><h1 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h1><p>容器间通信的三种方式：</p><ul><li>IP</li><li>Docker DNS Server</li><li>joined</li></ul><h2 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h2><p>Docker安装时，默认会在主机上创建三个网络，bridge、host、none。可用<code>docker network ls</code>查看</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>就是只有loopback的网络，无其他任何网卡。容器创建时可以用 <code>--network=none</code>来指定容器使用none网络</p><p>适应场景：一些安全性要求较高且不需联网的应用，如生成随机密码的容器，放在none里防止窃取。</p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>类似于虚拟机中共享主机网络的选项，即使容器共享其所在主机的网络栈，该容器的网络配置和主机完全一样。</p><p>适应场景：如容器对网络传输效率较高要求，则可使用host网络。注意考虑端口冲突。</p><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>类似于虚拟机中的桥接模式，可理解为一个软件交换机。默认情况下，不指定<code>--network</code>参数，创建的容器都会挂到一个叫<code>docker0</code>的Linux bridge上。可以使用命令<code>brctl show</code>查看。</p><p>注：首次使用<code>brctl</code>命令，可能会提示安装。<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-network.png" alt="network"></p><h3 id="自定义容器网络"><a href="#自定义容器网络" class="headerlink" title="自定义容器网络"></a>自定义容器网络</h3><p>user-defined网络</p><p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。bridge与前面类似，overlay 和 macvlan 用于创建跨主机的网络。</p><p><code>docker network create --driver bridge my_net</code></p><p>还可指定网段和网关，增加参数<code>--subnet</code>和<code>--gateway</code></p><p><code>docker network create --driver bridge --subnet 172.22.16.0/24 --gatewat 172.22.16.1 my_net2</code></p><p>要使用相关网络驱动即在创建docker容器时，指定<code>--network==xxx</code>其中xxx为驱动名称，当指定为有<code>--subnet</code>参数的驱动时，该容器可以通<code>ip</code>参数指定静态IP地址</p><p><code>docker run it --network=my_net2 --ip 172.22.16.8 busybox</code></p><h3 id="容器间连通"><a href="#容器间连通" class="headerlink" title="容器间连通"></a>容器间连通</h3><p>增加网卡使用<code>docker network connect</code>实现。</p><p>例如：为  CONTAINER ID为2a256932添加my_net2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network connect my_net2 2a256932</div></pre></td></tr></table></figure><h4 id="Linux路由转发功能"><a href="#Linux路由转发功能" class="headerlink" title="Linux路由转发功能"></a>Linux路由转发功能</h4><p>Linux默认一般不开启路由转发 ip forwarding，查看/etc/sysctl.cfg中的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure><p>‘1’ 说明启用。</p><p>查看防火墙iptables</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iptables-save</div><div class="line"></div><div class="line">-A DOCKER-ISOLATION -i br-5d863e9f78b6 -o docker0 -j DROP</div><div class="line">-A DOCKER-ISOLATION -i docker0 -o br-5d863e9f78b6 -j DROP</div></pre></td></tr></table></figure><p><strong>iptables DROP 掉了网桥 docker0 与 br-5d863e9f78b6 之间双向的流量</strong>。</p><p>从规则的命名 <code>DOCKER-ISOLATION</code> 可知 docker 在设计上就是要隔离不同的 netwrok。</p><h2 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h2><p>当部署应用之前可能无法确定IP，部署之后再指定要访问的IP会比较麻烦。可通过docker自带的DNS解决问题。</p><p>在docker daemon中实现了一个内嵌的DNS Server ，使容器可以直接通过“容器名”通信。容器名为创建运行容器时指定<code>--name</code>参数确定。</p><p>注：docker dns 只能在user-defined网络中使用。</p><h2 id="joined容器"><a href="#joined容器" class="headerlink" title="joined容器"></a>joined容器</h2><p>joined指多个容器共享网络栈，使容器之间可以通过127.0.0.1直接通信。</p><p>当一个容器需要joined另一个容器，则在创建运行使指定<code>--network=container:容器name</code>即可。</p><p>joined 容器非常适合以下场景：</p><ol><li>不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。</li><li>希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。</li></ol><h1 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h1><p>注意：这里外部网络指的是容器网络以外的网络环境，而非特指Internet</p><p>具体过程已docker0 为例：</p><p>当容器要访问外网时，将数据包封装丢给网关，到达docker0，收到后将其交给MASQUERADE处理（将包源地址替换为主机地址发出去，即做了一次网络地址转换（NAT）），然后就和主机访问外网一样了。</p><h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>在主机通过 <code>iptables -t nat -S</code>可查看到一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</div></pre></td></tr></table></figure><p>其含义是：如果网桥 <code>docker0</code> 收到来自 172.17.0.0/16 网段的外出包，把它交给 MASQUERADE 处理。</p><h2 id="抓包过程"><a href="#抓包过程" class="headerlink" title="抓包过程"></a>抓包过程</h2><p>使用tcpdump</p><ol><li>查看主机路由表</li><li>抓取相关网卡上数据包</li><li>结果分析</li></ol><p><code>ip r</code>查看默认路由从enp0s3出去，故监控enp0s3和docker0上的icmp数据包。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-ip%20route.jpg" alt=""></p><h1 id="外部世界访问容器"><a href="#外部世界访问容器" class="headerlink" title="外部世界访问容器"></a>外部世界访问容器</h1><p>docker可将容器对外提供服务的端口映射到主机的某个端口，外网通过该端口访问容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;host ip&gt;:&lt;映射的端口&gt;</div></pre></td></tr></table></figure><p>在容器启动时通过-p参数来映射端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80 httpd</div></pre></td></tr></table></figure><p>默认情况下容器的端口会随机映射到主机的一个端口。</p><p>可通过<code>docker ps</code>和<code>docker port</code>查看映射的端口情况、</p><p>若要指定映射到主机的某个端口，则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:80 httpd</div></pre></td></tr></table></figure><p>意思是将容器的80端口映射到主机的8080端口上<strong>（别搞反了）</strong></p><p>每一个映射的端口，host 都会启动一个 <code>docker-proxy</code> 进程来处理访问容器的流量。</p><p>过程如下：</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170805-docker%20port.jpg" alt=""></p><ol><li>docker-proxy 监听 host 的 32773 端口。</li><li>当 curl 访问 10.0.2.15:32773 时，docker-proxy 转发给容器 172.17.0.2:80。</li><li>httpd 容器响应请求并返回结果。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;容器作为应用，必然需要与外界通信，包括容器之间和外部网络。&lt;/p&gt;
&lt;p&gt;Docker网络从覆盖范围分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单台主机上的容器网络★&lt;/li&gt;
&lt;li&gt;跨多台主机的容器网络&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="虚拟化" scheme="http://binlv.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="http://binlv.top/tags/Docker/"/>
    
      <category term="网络管理" scheme="http://binlv.top/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>说说vSAN</title>
    <link href="http://binlv.top/2017/07/29/20170729-VSAN/"/>
    <id>http://binlv.top/2017/07/29/20170729-VSAN/</id>
    <published>2017-07-29T05:50:00.000Z</published>
    <updated>2017-11-06T02:13:44.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vSAN"><a href="#vSAN" class="headerlink" title="vSAN"></a>vSAN</h1><p>要说vSAN就不得不提下<strong>超融合</strong>的概念，超融合是一个整体解决方案，是将<strong>计算虚拟化</strong>，<strong>软件定义存储</strong>，<strong>软件定义网络</strong>等解决方案集成到一起的一个整体解决方案。</p><a id="more"></a><p><strong>软件定义分布式存储</strong>是超融合(Hyper-Converged)的核心。引用VMware关于vSAN的一句介绍：</p><blockquote><p>VMware vSAN (formerly Virtual SAN), is the industry-leading software powering Hyper-Converged Infrastructure solutions.</p></blockquote><p>即vSAN是VMware对<a href="https://baike.baidu.com/item/%E8%B6%85%E8%9E%8D%E5%90%88%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84" target="_blank" rel="external">超融合架构</a>的一种解决方案。</p><p>而从功能上说，vSAN是基于<strong>对象</strong>的<strong>分布式策略</strong>存储，这里面的关键词有三个：</p><ul><li>对象</li><li>分布式</li><li>策略</li></ul><p>下面，将以这三个关键词展开对与vSAN的介绍。</p><h1 id="存储对象和组件"><a href="#存储对象和组件" class="headerlink" title="存储对象和组件"></a>存储对象和组件</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象指的是一个独立的存储块设备，大小没限制。vSAN的对象是<strong>带有叶子的RAID树</strong> 。在vSAN存储池Datastore 上虚拟机有五种不同类型的对象，每个虚拟机都是由这些对象的部分组合而成。这些对象是：</p><ul><li>VM Home（虚拟机主页）或“名字空间目录”；</li><li>VM swap （交换文件对象），开机时才会创建；</li><li>VMDK（虚拟磁盘），vSAN 5.5时最大2TB，6.0最大62TB；</li><li>Snapshots（快照），也叫增量盘，建立快照的每个对象都有，每个增量磁盘都是一个对象。</li><li>Memory（vmem，虚拟机内存文件），vSAN5.5时，当快照创建时，虚拟机内存以文件形式存放在VM Home里；而在vSAN 6.0时，虚拟机内存在vSANDatastore里实例化为独立的对象。</li></ul><blockquote><p>注：</p><ul><li>除虚拟机磁盘、增量磁盘（快照）和交换对象外，所有虚拟机文件都驻留在 vSAN 上一个称为虚拟机命名空间的区域中。这里的文件可以是.vmx、.log 文件、.vmdk 和快照增量磁盘描述符文件，以及可能位于虚拟机主目录中的所有其他文件。</li></ul><p>—-<a href="http://vsdsrevolution.blog.51cto.com/8674155/1384474/" target="_blank" rel="external">vSAN 第 4 部分 – 了解对象和组件</a></p></blockquote><p>因为由vSAN搭的vSphere虚拟化环境和我们平时玩的VMware Workstation中的虚机略有不同，在vSAN中，虚机是由大量不同的<strong>存储对象</strong>组成的，而非文件。</p><h2 id="组件-含Witness"><a href="#组件-含Witness" class="headerlink" title="组件(含Witness)"></a>组件(含Witness)</h2><p>组件（ Components）是对象的RAID树上的叶子，分布在vSAN集群中的各个主机上。其实，组件是按照两种主要的技术分布的：Striping（条带），即RAID 0；和Mirroring（镜像），即RAID 1。</p><p>注意，RAID的构成和组件的分布取决于最初创建的存储策略。下图是副本为2，条带为2的组件分布情况。每个存储对象都会以 RAID 树的形式部署在vSAN 中，树中的每一片叶子都视为一个组件。</p><p>条带数（也即副本横跨的盘数）</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-VMDKObject.jpeg" alt=""></p><p>vSAN5.5目前支持每台主机最多包含3000个组件，<strong>vSAN 6.0可达9000个组件</strong>。</p><p>容量大于255GB的对象会自动被分为多个组件。我们知道，vSAN6.0现在支持62TB的VMDK。然而，考虑到vSAN集群支持的最大组件数，需要谨慎衡量应用程序]是否真的需要这么大的VMDK。以单个62TBD VMDK为例，假设副本数为2时，按照255GB拆分，需要消耗约500个组件。</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>需要清楚的是，vSAN不是分布式文件系统，<strong>而是分布式对象存储系统。</strong>所谓分布式就是一个业务拆分成多个子业务，部署在不同服务器上，经常对比的一个概念就是集群，集群是同一个业务，部署在多个服务器上。</p><p>搭建vSAN，至少要三台服务器节点（即ESXi主机），两台主机存放副本，剩下一台存放“见证”（也即Witness，当群集中的虚拟机存储对象出现故障的时候，作为必要的仲裁对象）组件，可允许最多一台主机故障。</p><p>需要注意的是，尽管vSAN完全支持3个主机的配置，但如果可行，<strong>建议至少4个主机</strong>。这是因为，只有3个主机的vSAN集群，在发生故障时，有些情况下，vSAN无法在群集中的其他主机上重新构建（Rebuild）组件（Components）来允许另一次故障。同样，在3个主机配置下，vSAN不能在维护模式（Maintenance Mode）期间从主机迁移所有数据。</p><p>而4个主机的vSAN群集可以提供更高的灵活性。vSAN集群最多时可以支持64个主机。每台为vSAN提供存储资源的主机至少有一个SSD，及一个HDD（每个主机满配5个磁盘组，每个磁盘组为1块SSD+7块HDD，SSD作为缓存层，HDD作为持久化层，也称容量层）。每台主机至少6GB内存。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-vSAN.jpg" alt=""></p><p>上种属于混合配置，在混合配置中，缓存算法会尝试最大限度提高读写性能。<strong>缓存的70%为读缓存</strong>，用于存储频繁读取的磁盘块，从而最大限度减少对速度缓慢的磁盘的访问。<strong>缓存的30%为写缓存</strong>，用于执行写入操作，每个IO会先写入缓存层，再批量写入持久化层。如果可行，系统会合并多个写操作，并按顺序写入，从而再次最大限度提高磁盘性能。</p><p>并且在混合配置下，<strong>强烈推荐使用支持直通（Pass-Through）模式的磁盘控制器</strong>。方便扩容，只需简单插入新盘即可。</p><blockquote><p>注：</p><ul><li>Pass Through意味着，此控制器支持把磁盘直接呈现给ESXi主机。监控和管理由vSAN来实现</li><li>RAID 0 指每个磁盘必须配置为RAID 0卷，才能让ESXi主机看到它们。</li></ul></blockquote><p>还有一种为全闪存配置，全闪存配置下，vSAN必须使用万兆网口。</p><h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>VMware通过SPBM (Storage Policy Based Management) 来实现SDS自动化。SPBM 是一种通用的存储策略框架，可跨 Virtual SAN 控制并自动执行<strong>以虚拟机为中心的存储策略</strong>，并通过 Virtual Volumes 管理外部存储。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-SPBM.jpg" alt=""></p><p>目前6.0版本提供的存储策略一共五种。</p><p><img src="http://olvboulzy.bkt.clouddn.com/20170729-capability.jpg" alt=""></p><h2 id="允许故障数"><a href="#允许故障数" class="headerlink" title="允许故障数"></a>允许故障数</h2><p>即FTT</p><p>为了保证虚拟机持续可访问，组成虚拟机存储对象的组件必须至少有50%可用。所以在保证vSAN可用性的前提下，在故障数为1 的策略时，vSAN环境最少需要3台主机，因为</p><p>3台主机具有2个镜像副本和一个见证，你总是可以具有大于50%的可用组件。</p><p>那么，允许N个故障，vSAN群集要多少台主机？</p><table><thead><tr><th>允许的故障数N</th><th>RAID-1副本数N+1</th><th>vSAN群集中需要的主机数2N+1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>5</td></tr><tr><td>3</td><td>4</td><td>7</td></tr></tbody></table><h2 id="条带宽数"><a href="#条带宽数" class="headerlink" title="条带宽数"></a>条带宽数</h2><p>一般而言，默认条带宽度设置为 1 应能满足大部分虚拟机工作负载的需求。只有在确定写入取消暂存操作或读取缓存未命中的情况影响到了性能时，才应该更改条带宽度。</p><h2 id="闪存读取缓存预留"><a href="#闪存读取缓存预留" class="headerlink" title="闪存读取缓存预留"></a>闪存读取缓存预留</h2><p>该容量是指 SSD 上作为读取缓存保留给存储对象的闪存容量。以1TB 磁盘为例，如果我们将读取缓存预留限定为 1% 的增量，也就意味着缓存预留的增量为 10GB，在大多数情况下，这一增量远远超出了一个虚拟机的需求。</p><h2 id="对象空间预留"><a href="#对象空间预留" class="headerlink" title="对象空间预留"></a>对象空间预留</h2><p>vSAN 上部署的所有对象都采用精简置备。此功能定义了初始化期间可以预留的存储对象逻辑大小百分比。<strong>对象空间预留</strong>表示要预留的空间量,以整个对象地址空间的百分比来表示。</p><h2 id="强制置备"><a href="#强制置备" class="headerlink" title="强制置备"></a>强制置备</h2><p> 如果将此参数设置为非零值，则即使数据存储不满足虚拟机存储策略中指定的策略要求，也会置备对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.vmware.com/products/vSAN.html" target="_blank" rel="external">VMware官方关于vSAN产品的介绍</a></li><li><a href="https://baijia.baidu.com/s?old_id=269575" target="_blank" rel="external">VMware SDS 之一 :什么是vSAN</a></li><li><a href="http://blog.csdn.net/mooncarp/article/details/51012700" target="_blank" rel="external">vSAN的体系架构</a></li><li><a href="http://bbs.vmsky.com/thread-55484-1-1.html" target="_blank" rel="external">vSAN与传统存储的比较</a></li><li><a href="http://sanshileilei.blog.51cto.com/3105269/1374604" target="_blank" rel="external">VMware vSAN入门与配置</a></li><li><a href="http://vsdsrevolution.blog.51cto.com/8674155/1381072" target="_blank" rel="external">VMware R&amp;D 的集成工程团队存储架构师对vSAN的介绍与配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vSAN&quot;&gt;&lt;a href=&quot;#vSAN&quot; class=&quot;headerlink&quot; title=&quot;vSAN&quot;&gt;&lt;/a&gt;vSAN&lt;/h1&gt;&lt;p&gt;要说vSAN就不得不提下&lt;strong&gt;超融合&lt;/strong&gt;的概念，超融合是一个整体解决方案，是将&lt;strong&gt;计算虚拟化&lt;/strong&gt;，&lt;strong&gt;软件定义存储&lt;/strong&gt;，&lt;strong&gt;软件定义网络&lt;/strong&gt;等解决方案集成到一起的一个整体解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="虚拟化" scheme="http://binlv.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="vSAN" scheme="http://binlv.top/tags/vSAN/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi + OpenHab 打造智能安防监控报警系统</title>
    <link href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab打造智能安防监控报警系统/</id>
    <published>2017-06-10T08:43:50.000Z</published>
    <updated>2017-09-09T04:28:55.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是我毕业设计的项目，从选题到设计完成都是一个人独立完成，当然我参考了网上无数教程代码，最后完成算是达到我的预期，可最后答辩时功能演示出现状况，使老师觉得我做的也不怎么样（可能也是我表达能力差），不管了。反正我觉得特别好，至少我这段时间处理解决各种问题最终完成这个开始自己挖的坑还是非常有成就感。所以为感谢网上各位贡献的教程代码，让我可以顺利完成毕设，我也将自己的成果展示出来，与大家共享。</p><a id="more"></a><p>我打算把这篇文章作为整个设计过程的目录，方便整体把握和学习，希望和大家一起交流。</p><p><strong>特别说明：</strong></p><p>本设计中使用的代码大部分来源网络，参考了我都会注明出处。如果遗漏，可以留言，或原作者介意，也可联系我删除。</p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>咱先看实现的最终效果，如果你觉得喜欢或则有兴趣，可以继续往下读，没兴趣就随意了~</p><p><a href="http://binlv.top/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/">智能安防监控报警系统效果展示</a></p><h1 id="设备选择"><a href="#设备选择" class="headerlink" title="设备选择"></a>设备选择</h1><p>这里面包括硬件部分（树莓派以及各传感器）的选择还有软件部分（操作系统、控制语言、开源物联网平台）的选择。</p><p><a href="http://binlv.top/2017/02/11/20170211-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E9%80%89%E6%8B%A9/">智能安防监控报警系统—硬件设备选择</a></p><h1 id="环境安装配置"><a href="#环境安装配置" class="headerlink" title="环境安装配置"></a>环境安装配置</h1><p>这里包括了树莓派操作系统的安装、配置以及开源平台OpenHab的安装等。</p><p><a href="http://binlv.top/2017/04/05/20170405-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">树莓派系统安装配置</a></p><p><a href="http://binlv.top/2017/05/10/20170510-OpenHab%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">OpenHab安装配置</a></p><h1 id="传感器部分"><a href="#传感器部分" class="headerlink" title="传感器部分"></a>传感器部分</h1><p>这里包括了我选择的各个传感器怎么去使用、获取数据等。</p><p><a href="http://binlv.top/2017/04/10/20170410-%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E5%85%A5%E9%97%A8/">树莓派GIPO入门(一)：LED灯</a></p><h1 id="OpenHab实践"><a href="#OpenHab实践" class="headerlink" title="OpenHab实践"></a>OpenHab实践</h1><p>OpenHab是国外的一个开源物联网平台，我也是误打误撞发现的，之前用的yeelink，感觉界面不太友好还经常有BUG，只能放弃。</p><h1 id="邮件及短信提醒的实现"><a href="#邮件及短信提醒的实现" class="headerlink" title="邮件及短信提醒的实现"></a>邮件及短信提醒的实现</h1><p>这一部分折腾我比较久，因为邮件很容易被当作垃圾邮件发不出去，短信也几经波折。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是我毕业设计的项目，从选题到设计完成都是一个人独立完成，当然我参考了网上无数教程代码，最后完成算是达到我的预期，可最后答辩时功能演示出现状况，使老师觉得我做的也不怎么样（可能也是我表达能力差），不管了。反正我觉得特别好，至少我这段时间处理解决各种问题最终完成这个开始自己挖的坑还是非常有成就感。所以为感谢网上各位贡献的教程代码，让我可以顺利完成毕设，我也将自己的成果展示出来，与大家共享。&lt;/p&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="树莓派" scheme="http://binlv.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
  <entry>
    <title>智能安防监控报警系统---效果展示</title>
    <link href="http://binlv.top/2017/06/08/20170608-%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/"/>
    <id>http://binlv.top/2017/06/08/20170608-智能安防监控报警系统效果展示/</id>
    <published>2017-06-08T05:23:50.000Z</published>
    <updated>2017-09-09T04:28:55.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章是我分享的智能安防监控报警系统系列文章的效果展示部分。</p><blockquote><p>目录：<a href="http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/">RaspberryPi+OpenHab打造智能安防监控报警系统</a></p></blockquote><a id="more"></a><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><ul><li>温度监测、湿度监测、易燃气体检测等，并将温湿度等参数显示在APP中。</li><li>视频监控并通过客户端APP显示</li><li>控制及报警系统<ul><li>环境指数超过阈值通过邮件、短信等报警提醒</li><li>客户端APP能控制LED、安防功能</li><li>当实验室触发报警时及时将实验室情况给管理人员</li></ul></li></ul><p>下图是我最后连接好各传感器后的实物图</p><p><img src="http://olvboulzy.bkt.clouddn.com/Raspberry_full.jpg?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="硬件部分实物展示"></p><p>下面是连线图，用frizing画的，比较丑，将就着看看把。</p><p><img src="http://olvboulzy.bkt.clouddn.com/raspberry_lianxian.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="连线图"></p><p>然后是客户端APP主界面</p><p><img src="http://olvboulzy.bkt.clouddn.com/OpenHab_running.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="主界面"></p><p>可以看到第一组远程控制部分包括LED灯开关控制、安防（也就是红外感应）的控制；然后第二组实验室环境显示，包括温度、湿度，烟雾；第三组是视频监控部分，包括第一个动态和第二个静态；第四组是树莓派设备的运行状况显示，主要是CPU和GPU温度；最后一组是当前系统时间（我用来凑数的，哈哈哈）。</p><p><img src="http://olvboulzy.bkt.clouddn.com/Camera.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="视频监控部分"></p><p><img src="http://olvboulzy.bkt.clouddn.com/temperature.png" alt="系统运行状况"></p><p>报警包括蜂鸣器报警、邮件报警、短信报警</p><p>其中，邮件报警基本使用的是yeelink平台的阈值提醒，就是把数据上传，然后在上面设置触发阈值、邮件地址即可，不过经常不灵。也用OpenHab里自带邮件发送，还有自己写的Python版的邮件发送，都不是很理想。短信使用的是阿里大于Python接口，那叫一个方便。</p><p><img src="http://olvboulzy.bkt.clouddn.com/warning.png?watermark/2/text/aHR0cDovL2Jpbmx2LnRvcA==/font/YXJpYWw=/fontsize/260/fill/I0VGRUZFRg==/dissolve/100/gravity/South/dx/10/dy/10" alt="报警系统"></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本来我录了个演示视频的。。。后来手贱被我删了，找不到了，我在写这篇文章的时候设备已经上交学校，也演示不了好尴尬额。唉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章是我分享的智能安防监控报警系统系列文章的效果展示部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录：&lt;a href=&quot;http://binlv.top/2017/06/10/20170610-RaspberryPi+OpenHab%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%AE%89%E9%98%B2%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/&quot;&gt;RaspberryPi+OpenHab打造智能安防监控报警系统&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="树莓派" scheme="http://binlv.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
  <entry>
    <title>Oracle备份恢复</title>
    <link href="http://binlv.top/2017/05/30/20170530-Oracle%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D(%E4%B8%80)/"/>
    <id>http://binlv.top/2017/05/30/20170530-Oracle备份恢复(一)/</id>
    <published>2017-05-30T04:50:00.000Z</published>
    <updated>2017-12-10T14:21:50.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://yq.aliyun.com/articles/45990?spm=5176.100239.blogcont156.11.X4s9k0" target="_blank" rel="external">细谈Oracle备份方法</a><br><a href="http://blog.csdn.net/leshami/article/details/5791585" target="_blank" rel="external">Oracle备份恢复概念</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p> Oracle数据库有两种运行方式：一是归档方式（ArchiveLog），二是不归档方式（NoArchiveLog）。</p><ul><li><p>归档方式<br>  当数据库发生故障时最大限度恢复数据库，可以保证不丢失任何已提交的数据，即恢复到最后一次commit；</p><p>  可实现冷备和热备；</p><p>  支持完全备份和非完全备份以及完全恢复与非完全恢复；</p><p>  但消耗系统10%性能，同时需要消耗更多存储空间；</p></li><li><p>非归档方式<br>  只能恢复数据库到最近的回收点，即最后一次全备；</p><p>  只支持冷备份（又称为一致性备份）；</p><p>  只能完全备份与完全恢复；</p></li></ul><a id="more"></a><h2 id="备份分类"><a href="#备份分类" class="headerlink" title="备份分类"></a>备份分类</h2><ul><li>物理备份<ul><li>冷备份<br>脱机备份—备份前数据库必须彻底关闭。</li><li>热备份<br>联机备份—只适用于归档方式</li></ul></li><li>逻辑备份<br> 将表、存储过程等数据使用Oracle的export等工具导出到二进制文件，后续根据需要再使用import工具导入数据库。</li></ul><h2 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h2><ul><li>RMAN<br> Recovery Manager。Oracle提供的DBA工具，用于管理备份和恢复操作。</li><li>EXP/IMP<br> 导入/导出方式—转储。如表空间迁移、表的抽取、检测逻辑和物理冲突等，适合小型数据库。</li><li>OS脚本</li></ul><h2 id="数据库实例启动关闭过程"><a href="#数据库实例启动关闭过程" class="headerlink" title="数据库实例启动关闭过程"></a>数据库实例启动关闭过程</h2><h3 id="数据库实例启动过程"><a href="#数据库实例启动过程" class="headerlink" title="数据库实例启动过程"></a>数据库实例启动过程</h3><p>当我们<code>startup</code>数据库时，数据库首先到<code>nomount</code>状态，然后启动到<code>mount</code>状态，再到<code>open</code>状态。</p><ul><li><p>nomount</p><p>实例启动</p><p>​        实例的启动通常包含下列任务：</p><p>​           a.按以下顺序在$ORACLE_HOME/dbs[win平台为database]目录下搜索下列文件,即如果第一个没找到，就找下一个</p><p>​               spfile<sid>.ora —&gt; spfile.ora —&gt; init<sid>.ora</sid></sid></p><p>​           b.分配SGA</p><p>​           c.启动后台进程</p><p>​           d.打开并修改告警<sid>.log文件及跟踪文件</sid></p><p>​       注意：</p><p>​           此阶段不打开任何的控制文件及数据文件。</p></li><li><p>mount</p></li></ul><p>​        mount阶段完成的任务：</p><p>​           a.启动实例并打开控制文件，将数据库与实例关联起来</p><p>​           b.利用参数文件中的说明，打开并锁定控制文件</p><p>​           c.读取控制文件以获取数据文件和重做日志文件的名字和状态信息，但不检查数据日志文件是否存在</p><p>​    注意：</p><p>​               这一步会读控制文件，如果这一步有一个控制文件损坏就无法启动</p><ul><li>open</li></ul><p>​       mount阶段完成的任务：</p><p>​           a.打开数据文件</p><p>​           b.打开联机日志文件</p><p>​     注意：</p><p>​            a.在此期间，Oracle服务器将校验所偶的数据文件和联机日志文件能否打开并对数据库作一致性检查</p><p>​           b.如果出现一致性错误，SMON进程将启动实例恢复</p><p>​           c.如果任一数据文件或联机日志文件丢失，Oracle服务器将报错</p><h3 id="数据库实例关闭"><a href="#数据库实例关闭" class="headerlink" title="数据库实例关闭"></a>数据库实例关闭</h3><p>​    关闭命令：shutdowm abort | immediate | transactional | normal (shutdown不带参数将缺省为normal)</p><p>​    关闭选项：</p><p>​       normal         —&gt;不准许新的连接，等待当前的session 结束，等待当前的事务结束，强制检查点并关闭文件</p><p>​       transactional —&gt;不准许新的连接，不等待当前的session结束，等待当前的事务结束，强制检查点并关闭文件。</p><p>​       immediate      —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，强制检查点并关闭文件。</p><p>​       abort          —&gt;不准许新的连接，不等待当前的session结束，不等待当前的事务结束，不作强制检查点。</p><h2 id="数据库恢复过程"><a href="#数据库恢复过程" class="headerlink" title="数据库恢复过程"></a>数据库恢复过程</h2><p>restore  -&gt;  recover   -&gt;  open</p><p>数据文件转储  -&gt;  根据log等将差异弥补  -&gt;  打开数据库</p><p>datafile            control scn    </p><h1 id="备份策略选择"><a href="#备份策略选择" class="headerlink" title="备份策略选择"></a>备份策略选择</h1><h1 id="Oracle实例和Oracle数据库"><a href="#Oracle实例和Oracle数据库" class="headerlink" title="Oracle实例和Oracle数据库"></a>Oracle实例和Oracle数据库</h1><p>一个Oracle Server 由Oracle 实例和Oracle 数据库组成。一台SQL server服务器上可以<strong>存在</strong>多个不同的实例。一个实例下可以存在多个<strong>不同</strong>的数据库。</p><ul><li><p>Oracle实例（Instance）</p><p>内存结构（SGA）+一系列后台进程（Background Process）</p></li><li><p>Oracle数据库（Database）</p><p>控制文件（Controlfile）+  数据文件（datafile）+  联机日志文件（logfile） +  参数文件(pfile、spfile)  +  密码文件等</p><p>​</p></li></ul><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/45990?spm=5176.100239.blogcont156.11.X4s9k0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;细谈Oracle备份方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/5791585&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oracle备份恢复概念&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;运行方式&quot;&gt;&lt;a href=&quot;#运行方式&quot; class=&quot;headerlink&quot; title=&quot;运行方式&quot;&gt;&lt;/a&gt;运行方式&lt;/h2&gt;&lt;p&gt; Oracle数据库有两种运行方式：一是归档方式（ArchiveLog），二是不归档方式（NoArchiveLog）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;归档方式&lt;br&gt;  当数据库发生故障时最大限度恢复数据库，可以保证不丢失任何已提交的数据，即恢复到最后一次commit；&lt;/p&gt;
&lt;p&gt;  可实现冷备和热备；&lt;/p&gt;
&lt;p&gt;  支持完全备份和非完全备份以及完全恢复与非完全恢复；&lt;/p&gt;
&lt;p&gt;  但消耗系统10%性能，同时需要消耗更多存储空间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非归档方式&lt;br&gt;  只能恢复数据库到最近的回收点，即最后一次全备；&lt;/p&gt;
&lt;p&gt;  只支持冷备份（又称为一致性备份）；&lt;/p&gt;
&lt;p&gt;  只能完全备份与完全恢复；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="RMAN" scheme="http://binlv.top/tags/RMAN/"/>
    
  </entry>
  
  <entry>
    <title>RAC学习记录</title>
    <link href="http://binlv.top/2017/05/23/20170523-Oracle%2011g%20RAC%20Installation%20Guide/"/>
    <id>http://binlv.top/2017/05/23/20170523-Oracle 11g RAC Installation Guide/</id>
    <published>2017-05-23T07:00:00.000Z</published>
    <updated>2017-11-01T11:30:28.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAC理论基础"><a href="#RAC理论基础" class="headerlink" title="RAC理论基础"></a>RAC理论基础</h1><p>在RAC术语中，主机通常叫做“节点”。<br>每个主机的硬件配置应该一样：</p><ul><li>每个主机至少需要两块网卡，一个用于集群内部私有通信—Private NIC，另一个网卡用于对外提供服务，如提供用户数据查询—公共网卡（Public NIC）；</li><li>每个主机还要有一个HBA卡，通过光纤连接到存储设备</li><li>除公共和私有IP，每个节点还有VIP（Virtual IP），宕机时使用<br>  共享存储</li><li>多实例，单一数据 架构</li><li>所有节点共享一个数据库</li><li>数据文件、联机日志、参数文件、控制文件必须存放在共享存储上</li><li>保证每个节点都能访问这个存储设备  <a id="more"></a></li></ul><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h2><ul><li>操作系统及补丁包<br>要求：OEL 使用 ASMlib、其他Linux使用udev<pre><code>内存：2G以上、SWAP 4G 、硬盘 30G以上</code></pre></li><li>创建所需组、用户和软件home目录<br> oracle - oinstall dba<br>  grid   - asmadmin</li><li>若部署GNS，需提前设置</li><li>设置存储空间</li></ul><h2 id="安装Oracle-Grid-Infrastructure"><a href="#安装Oracle-Grid-Infrastructure" class="headerlink" title="安装Oracle Grid Infrastructure"></a>安装Oracle Grid Infrastructure</h2><ul><li>包括Oracle Clusterware和Oracle ASM<br>11gR2 整合了Clusterware</li></ul><p>ASM安装是个重点<br>如使用OEL系统，自带asmlib但还是要安装asm-support（系统光盘中有）<br>如使用非OEL系统，有两种解决方案：</p><ol><li>安装对应内核的asmlib和asm-support，一般只适合较老版本Linux（Oracle对非自家Linux不提供支持，oracleasm最新支持到oracleasm-2.6.18-238.9.1.el5）</li><li>使用linux自带设备管理器udev，其中又有两种情形：<br>2.1 6.0版本以前的可以用scsi_id -g -u -s</li></ol><p>1.确认在所有RAC节点上已经安装了必要的UDEV包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@rh2 ~]# rpm -qa|grep udev</div><div class="line">udev-095-14.21.el5</div></pre></td></tr></table></figure></p><p>2.通过scsi_id获取设备的块设备的唯一标识名，假设系统上已有LUN sdc-sdp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for i in c d e f g h i j k l m n o p ;</div><div class="line">do</div><div class="line">echo "sd$i" "`scsi_id -g -u -s /block/sd$i` ";</div><div class="line">done</div></pre></td></tr></table></figure></p><p>sdc 1IET_00010001<br>sdd 1IET_00010002<br>sde 1IET_00010003<br>sdf 1IET_00010004<br>sdg 1IET_00010005<br>sdh 1IET_00010006<br>sdi 1IET_00010007<br>sdj 1IET_00010008<br>sdk 1IET_00010009<br>sdl 1IET_0001000a<br>sdm 1IET_0001000b<br>sdn 1IET_0001000c<br>sdo 1IET_0001000d<br>sdp 1IET_0001000e </p><p>以上列出于块设备名对应的唯一标识名</p><p>3.创建必要的UDEV配置文件，</p><p>首先切换到配置文件目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rh2 ~]# cd /etc/udev/rules.d</div></pre></td></tr></table></figure></p><p>定义必要的规则配置文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# touch 99-oracle-asmdevices.rules </div><div class="line">[root@rh2 rules.d]# cat 99-oracle-asmdevices.rules</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010001", NAME="ocr1", OWNER="grid", GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010002", NAME="ocr2", OWNER="grid", GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010003", NAME="asm-disk1",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010004", NAME="asm-disk2",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010005", NAME="asm-disk3",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010006", NAME="asm-disk4",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010007", NAME="asm-disk5",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010008", NAME="asm-disk6",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_00010009", NAME="asm-disk7",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000a", NAME="asm-disk8",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000b", NAME="asm-disk9",  OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000c", NAME="asm-disk10", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000d", NAME="asm-disk11", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div><div class="line">KERNEL=="sd*", BUS=="scsi", PROGRAM=="/sbin/scsi_id -g -u -s %p", RESULT=="1IET_0001000e", NAME="asm-disk12", OWNER="grid",  GROUP="asmadmin", MODE="0660"</div></pre></td></tr></table></figure></p><p>Result 为/sbin/scsi_id -g -u -s %p的输出–Match the returned string of the last PROGRAM call. This key may be<br>used in any following rule after a PROGRAM call.<br>按顺序填入刚才获取的唯一标识名即可</p><p>OWNER为安装Grid Infrastructure的用户，在11gr2中一般为grid，GROUP为asmadmin<br>MODE采用0660即可</p><p>NAME为UDEV映射后的设备名，<br>建议为OCR和VOTE DISK创建独立的DISKGROUP，为了容易区分将该DISKGROUP专用的设备命名为ocr1..ocrn的形式<br>其余磁盘可以根据其实际用途或磁盘组名来命名</p><ol><li>将该规则文件拷贝到其他节点上<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# scp 99-oracle-asmdevices.rules Other_node:/etc/udev/rules.d</div></pre></td></tr></table></figure></li></ol><p>5.在所有节点上启动udev服务，或者重启服务器即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# /sbin/udevcontrol reload_rules</div><div class="line">[root@rh2 rules.d]# /sbin/start_udev</div><div class="line">Starting udev:                                            [  OK  ]</div></pre></td></tr></table></figure></p><p>6.检查设备是否到位<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@rh2 rules.d]# cd /dev</div><div class="line">[root@rh2 dev]# ls -l ocr*</div><div class="line">brw-rw---- 1 grid asmadmin 8, 32 Jul 10 17:31 ocr1</div><div class="line">brw-rw---- 1 grid asmadmin 8, 48 Jul 10 17:31 ocr2</div><div class="line"></div><div class="line">[root@rh2 dev]# ls -l asm-disk*</div><div class="line">brw-rw---- 1 grid asmadmin 8,  64 Jul 10 17:31 asm-disk1</div><div class="line">brw-rw---- 1 grid asmadmin 8, 208 Jul 10 17:31 asm-disk10</div><div class="line">brw-rw---- 1 grid asmadmin 8, 224 Jul 10 17:31 asm-disk11</div><div class="line">brw-rw---- 1 grid asmadmin 8, 240 Jul 10 17:31 asm-disk12</div><div class="line">brw-rw---- 1 grid asmadmin 8,  80 Jul 10 17:31 asm-disk2</div><div class="line">brw-rw---- 1 grid asmadmin 8,  96 Jul 10 17:31 asm-disk3</div><div class="line">brw-rw---- 1 grid asmadmin 8, 112 Jul 10 17:31 asm-disk4</div><div class="line">brw-rw---- 1 grid asmadmin 8, 128 Jul 10 17:31 asm-disk5</div><div class="line">brw-rw---- 1 grid asmadmin 8, 144 Jul 10 17:31 asm-disk6</div><div class="line">brw-rw---- 1 grid asmadmin 8, 160 Jul 10 17:31 asm-disk7</div><div class="line">brw-rw---- 1 grid asmadmin 8, 176 Jul 10 17:31 asm-disk8</div><div class="line">brw-rw---- 1 grid asmadmin 8, 192 Jul 10 17:31 asm-disk9</div></pre></td></tr></table></figure></p><p>  2.2 6.0版本以后的-g失效,需使用</p><p>1.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">首先确认是 Linux 6.0以上版本</span></div><div class="line">[root@vrh6 dev]# cat /etc/issue          </div><div class="line">Oracle Linux Server release 6.2</div><div class="line">Kernel \r on an \m</div></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">添加记录到/etc/scsi_id.config</span></div><div class="line"></div><div class="line">echo "options=--whitelisted --replace-whitespace"  &gt;&gt; /etc/scsi_id.config</div></pre></td></tr></table></figure></p><ol><li>​<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">确认哪些块设备需要udev绑定</span></div><div class="line"></div><div class="line">[root@vrh6 dev]# ls -l sd*</div><div class="line">brw-rw----. 1 root disk 8,  0 Jun 30 09:29 sda</div><div class="line">brw-rw----. 1 root disk 8,  1 Jun 30 09:29 sda1</div><div class="line">brw-rw----. 1 root disk 8,  2 Jun 30 09:29 sda2</div><div class="line">brw-rw----. 1 root disk 8, 16 Jun 30 09:29 sdb</div><div class="line">brw-rw----. 1 root disk 8, 32 Jun 30 09:29 sdc</div><div class="line">brw-rw----. 1 root disk 8, 48 Jun 30 09:29 sdd</div><div class="line">brw-rw----. 1 root disk 8, 64 Jun 30 09:29 sde</div><div class="line">brw-rw----. 1 root disk 8, 80 Jun 30 09:29 sdf</div></pre></td></tr></table></figure></li></ol><p>例如在本实例中 sdb-&gt; sdf的块设备需要绑定</p><ol><li>将 b-&gt;f的编号放入for 循环中，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span></div><div class="line">for i in b c d e f ;</div><div class="line">do</div><div class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      </div><div class="line">done</div></pre></td></tr></table></figure></li></ol><p>就会生成sdb-&gt;sdf 设备绑定的RULE，在将这些RULE写入到/etc/udev/rules.d/99-oracle-asmdevices.rules中</p><p>也可以直接利用以下脚本 ，写出RULE到99-oracle-asmdevices.rules<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> AUTO UDEV RULE BY Maclean Liu 2012/06/30</span></div><div class="line">for i in b c d e f ;</div><div class="line">do</div><div class="line">echo "KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/\$name\", RESULT==\"`/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/sd$i`\", NAME=\"asm-disk$i\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""      &gt;&gt; /etc/udev/rules.d/99-oracle-asmdevices.rules</div><div class="line">done</div></pre></td></tr></table></figure></p><ol><li>之后运行用root运行/sbin/start_udev  即可</li></ol><blockquote><p>注：</p><p>使用vmware，需要在主机vmx文件中加入： disk.EnableUUID = “TRUE”，否则UUID出不来</p></blockquote><h2 id="安装Oracle-RAC"><a href="#安装Oracle-RAC" class="headerlink" title="安装Oracle RAC"></a>安装Oracle RAC</h2><h1 id="学会使用集群验证实用程序（CVU）"><a href="#学会使用集群验证实用程序（CVU）" class="headerlink" title="学会使用集群验证实用程序（CVU）"></a>学会使用集群验证实用程序（CVU）</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RAC理论基础&quot;&gt;&lt;a href=&quot;#RAC理论基础&quot; class=&quot;headerlink&quot; title=&quot;RAC理论基础&quot;&gt;&lt;/a&gt;RAC理论基础&lt;/h1&gt;&lt;p&gt;在RAC术语中，主机通常叫做“节点”。&lt;br&gt;每个主机的硬件配置应该一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个主机至少需要两块网卡，一个用于集群内部私有通信—Private NIC，另一个网卡用于对外提供服务，如提供用户数据查询—公共网卡（Public NIC）；&lt;/li&gt;
&lt;li&gt;每个主机还要有一个HBA卡，通过光纤连接到存储设备&lt;/li&gt;
&lt;li&gt;除公共和私有IP，每个节点还有VIP（Virtual IP），宕机时使用&lt;br&gt;  共享存储&lt;/li&gt;
&lt;li&gt;多实例，单一数据 架构&lt;/li&gt;
&lt;li&gt;所有节点共享一个数据库&lt;/li&gt;
&lt;li&gt;数据文件、联机日志、参数文件、控制文件必须存放在共享存储上&lt;/li&gt;
&lt;li&gt;保证每个节点都能访问这个存储设备
    
    </summary>
    
      <category term="数据库" scheme="http://binlv.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://binlv.top/tags/oracle/"/>
    
      <category term="RAC" scheme="http://binlv.top/tags/RAC/"/>
    
      <category term="cluster" scheme="http://binlv.top/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>OpenHab安装配置</title>
    <link href="http://binlv.top/2017/05/10/20170510-OpenHab%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://binlv.top/2017/05/10/20170510-OpenHab安装配置/</id>
    <published>2017-05-10T08:10:32.000Z</published>
    <updated>2017-09-09T04:28:55.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a><h1 id="OpenHab简介"><a href="#OpenHab简介" class="headerlink" title="OpenHab简介"></a>OpenHab简介</h1><p>开源物联网平台，吸引我的是它可实现一次部署，即可同时支持Web、安卓、苹果等控制管理，且界面美观、可定制性强。较国内如yeelink。</p><h1 id="OpenHab原理"><a href="#OpenHab原理" class="headerlink" title="OpenHab原理"></a>OpenHab原理</h1><p>安装前首先要懂原理，不然后面出现啥问题会一脸懵逼。</p><h1 id="OpenHab安装"><a href="#OpenHab安装" class="headerlink" title="OpenHab安装"></a>OpenHab安装</h1><p>参考官方教程</p><h1 id="OpenHab配置"><a href="#OpenHab配置" class="headerlink" title="OpenHab配置"></a>OpenHab配置</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
    
    </summary>
    
      <category term="物联网" scheme="http://binlv.top/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="OpenHab" scheme="http://binlv.top/tags/OpenHab/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack初步</title>
    <link href="http://binlv.top/2017/05/09/20170509-OpenStack%E5%88%9D%E6%AD%A5/"/>
    <id>http://binlv.top/2017/05/09/20170509-OpenStack初步/</id>
    <published>2017-05-09T03:13:21.000Z</published>
    <updated>2017-09-09T04:28:55.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="一型虚拟化"><a href="#一型虚拟化" class="headerlink" title="一型虚拟化"></a>一型虚拟化</h2><p>虚拟化平台直接安装在物理机上，如ESXi、Xen</p><h2 id="二型虚拟化"><a href="#二型虚拟化" class="headerlink" title="二型虚拟化"></a>二型虚拟化</h2><p>物理机安装操作系统，操作系统上再安装虚拟化软件，如KVM</p><a id="more"></a><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>KVM有一个内核模块—kvm.ko ，只用于管理<strong>虚拟CPU</strong>和<strong>内存</strong>。</p><p>IO虚拟化，如存储和网络设备虚拟化交给Linux内核和Qemu</p><h4 id="Libvirt"><a href="#Libvirt" class="headerlink" title="Libvirt"></a>Libvirt</h4><p>—KVM管理工具</p><p>包含 </p><p>  1、后台daemon程序libvirtd</p><p>服务程序，接收和处理API请求</p><p>  2、API库</p><p>用于开发基于Libvirt的高级工具，如virt-manager</p><p>  3、命令行工具virsh</p><p>KVM命令行工具</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;一型虚拟化&quot;&gt;&lt;a href=&quot;#一型虚拟化&quot; class=&quot;headerlink&quot; title=&quot;一型虚拟化&quot;&gt;&lt;/a&gt;一型虚拟化&lt;/h2&gt;&lt;p&gt;虚拟化平台直接安装在物理机上，如ESXi、Xen&lt;/p&gt;
&lt;h2 id=&quot;二型虚拟化&quot;&gt;&lt;a href=&quot;#二型虚拟化&quot; class=&quot;headerlink&quot; title=&quot;二型虚拟化&quot;&gt;&lt;/a&gt;二型虚拟化&lt;/h2&gt;&lt;p&gt;物理机安装操作系统，操作系统上再安装虚拟化软件，如KVM&lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://binlv.top/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="虚拟化" scheme="http://binlv.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="OpenStack" scheme="http://binlv.top/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>职业规划与自我认知</title>
    <link href="http://binlv.top/2017/05/02/20170502-%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E4%B8%8E%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    <id>http://binlv.top/2017/05/02/20170502-关于职业规划与自我认知/</id>
    <published>2017-05-02T05:17:23.000Z</published>
    <updated>2017-09-09T04:28:55.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要毕业了，实习了一个多月。。。职业规划还一片空白，房价又那么贵，我该怎么办==。</p><p>这篇文章是我前几天无意间发现了，发现居然是挖坟，贴来自己看看，觉得还是很有启发意义的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>程序人生的四个象限和两条主线</p><a id="more"></a><p>| 作者 陈理捷 发布于 2013年12月18日. 估计阅读时间: 不到一分钟 | 14  讨论</p><p>零</p><p>为什么我们要自己做职业生涯规划？记得《社交网络》里边，CFO同学在知道自己股权被稀释时说了一句话，“我以为那些律师是我的律师。”</p><p>其实我们大多数人对HR几乎都存在类似的误解—— 你以为她是你的HR，其实她只是公司的HR。她们care的是如何编个理由用老板给的那点小钱留住一个高性价比的人才，而不是真正有助于你发展的职业路线图。昨天还含情脉脉和你讨论人生的知心姐姐明天就可能变成拿着劳动合同逼你主动离职的凶婆娘。和人性无关——这就是她们的工作，越专业的HR越擅长。</p><p>所以，你要自己来做这件事情。另外还有一个原因，你该去什么样的公司、做什么样的事情、拿多少钱，都取决于一个问题：你想成为一个什么样的人。工作只是人生的一部分，是用来支撑你人生价值的核心框架之一。在你自己没有想明白的时候，没有人能帮你。这就是为什么猎头基本只谈钱——他们没空去和客户讨论人生的意义。</p><p>一</p><p>我曾花了很长的时间去思考人生的意义，最终发现其实人生本来没有意义，意义都是我们赋予它的。</p><p>在创业做人才服务后，我开始和很多的程序员聊天，开始去了解他们的现状和他们对于自己职业的RoadMap。我发现技术人员的职业生涯形态并不是千变万化的，绝大多数都大同小异，可以用四个象限和两条主线概括清楚。虽然我无法代替你去定义人生的意义，但是我可以和大家分享下各种职业规划下的人生都是什么样子的。当然，这些想法只是我总结出来的东西，未必正确、更不权威大体是一些自以为是的最佳实践。如果你觉得有用，就把它分享给更多的程序员；如果你觉得无趣，就无视掉吧，毕竟我也只能从自己的视角来讨论这个事情。</p><p>二</p><p>写《穷爸爸富爸爸》的那个胖子——罗伯特清崎，从现金流向将人类分到了四个象限，从而总结出来了这么一张图。</p><p><img src="" alt=""></p><p>你也许已经看过，但这次我会从程序员的角度来进行解读。</p><p>E象限</p><p>E象限是雇员象限，绝大多数程序员都在这个象限里边。这里是风险最小的地方，只要你准时上下班别一个SQL把公司的数据库Drop掉，基本都能每月领到应得的银子。这里本应该是程序员们的天堂，因为比起改变世界，他们更多的只是很单纯的喜欢写代码。但现实很残酷，北上广的房价高不可攀。你可以不在乎房子，你女朋友能不在乎吗？你女朋友不在乎，她妈能不在乎吗？再考虑到将来小孩上学之类，只要你还打算留下来，房子其实还是必需品。</p><p>在E象限要低风险的搞定房子，只有一个攻略：靠股票和期权。找一家上市公司，或者即将要上市的公司，在里边成为核心员工，再待上几年，就能拿到一定数量的股票或期权。如果运气好，变卖掉这些东西，可以有百万级的收益。前几年这些钱还可以买房子，现在大概只能交首付了。</p><p>S象限</p><p>E象限的整体薪资是有天花板的，很多公司总监的月薪也就3万到5万，扣掉税和每月花销，其实攒不了太多钱。所以有一部分人就选择了S象限——自由职业者和小企业主的领域。S象限的魅力在于你的收益不再完全由你的劳动来获得，你可以开始雇人了。比方说，你可以开一个外包公司，给微博的粉丝服务平台做应用。面向企业的业务一般难在拿到单子，而利润是很高的，一个项目上百万完全不算大，之前有人开玩笑说这些公司一年一个单子就够了、两个单子就赚了。</p><p>在S象限要活得舒服还是有技巧的：如果做外包，一定要有一个不错的客户渠道；依赖于大平台的项目最好能花点钱成为平台的合作伙伴；建站也是Web程序员们做得多的方向，现在可以顺便把移动APP也给做了，很多简单需求用HTML5打个包就能卖几万块钱。</p><p>如果你人脉不好，好吧，程序员人脉好的其实很少，那么就只能用免费+收费模式了。首先把你要做的业务中标准化的部分开发成产品（如CMS）在网络上免费传播，而其中需要定制的部分就可以收费了。开源和免费的Web产品很多，但同质化严重，很少有细分市场的产品，用心定位的话，养活一个小公司绰绰有余的。</p><p>S象限还有一种很悠闲的活法，那就是逃离北上广、回归大自然。去一个风景优美空气清新的二三线城市，雇三五个人（当然就你自己也行）开一个小工作室，给美国人写iOS和Android应用。既没有房价的压力，还能发着人民币挣美金，貌似成都高新区还免税。</p><p>B象限</p><p>按罗伯特他亲戚的定义，B象限本来是大企业主的，那种员工超过500人的。不过在互联网领域这个定义不靠谱，我更乐意把它看成是上市公司和为了上市的创业公司的象限。</p><p>同样是开公司，B象限的玩法和S象限不同，它是以规模化为前提的。天使、种子、VC、上市和出售是这个象限的关键词。</p><p>很少有技术人员适合独立创业，不是说你能力不够，而是很多东西你都没接触过，需要补很多课。之前创业成本比较高，现在有了微博和微信这些开放平台、有了App Store和Google Play这些开放市场，技术人员创业也开始有了一点的优势：自己做个小产品，不停的快速失败，直到成功。说得更直白一点就是你找业余时间开发一个商业应用，放到市场上去卖试试，让客户骂试试。等你经过了共享软件的洗礼，你基本上就知道做生意是怎么一回事了。</p><p>上帝其实挺公平的，他还为程序员们准备了另外一条低风险的捷径——上市公司或者快要上市公司的CTO。在这里要和大家强调一点，同样是CTO职位，初创团队的CTO和相对成熟公司的CTO差别是非常大的。</p><p>A轮（不一定精确，但大致如此）以前的公司，主要在寻找商业模式，会频繁的变更需求，对开发速度要求更高，这时候CTO只要能敏捷的开发产品就OK；A轮以后的公司，着力于规模化，会有大量的推广，可能在某些时间点遭遇高并发，同时技术人员、设备会迅速增加，这时候CTO需要考虑业务的高可用、还要能处理好团队、资源的管理工作。如果原来的CTO没有大型互联网公司的背景，往往很难做好这些事情，所以一般会考虑从大公司去挖一个。</p><p>如果你的规划足够好，是可以从小公司到大公司再即将上市的公司，加薪升职迎娶白富美出任CTO成为人生赢家的，这个等下我们还会具体讨论。</p><p>I象限</p><p>这个土豪和高富帅的象限我还没有待过，所以不多讲。大体是钱多得没处花的人通过投资来保证资产增值的地方。所谓的财务自由（就是一直不干活，钱也够你花），就是通过进入这个象限来实现的。投资未必都是技术活，直接银行存个定期也算是投资，如果你钱够多的话，也能财务自由。对了，投行的投资经理是E象限的，他们其实是雇员。</p><p>三</p><p>当你在上边四个象限里选好了想要的人生区间后，就要设计一个可行的RoadMap来实现它。但既然你都读到这里了，大概既没有一个I象限的亲爹、也没有一个I象限的干爹，所以唯一可以推动你前进的，只能是自身的成长。</p><p>技术人员的成长路径主要就分两条，技术线和管理线。总体来讲，选技术线的同学要选好技术方向；而选管理线的同学要把握好节奏。</p><p>技术线</p><p>这里的技术线是纯技术路线，是专家方向，做到最后title应该是首席科学家、首席架构师或者首席技术顾问之类。如果你对某个方向的技术非常感兴趣，又不喜欢做项目、团队管理工作，那么技术线就是不错的选择。</p><p>选技术线的同学一定要选对技术方向，因为你会在自己选择的这个细分市场里投入三年、五年、甚至十年的时间。</p><p>和大家讲讲我自己的经历。我是2002年开始学习PHP的，当时ASP非常流行，而我只是一个计算机系的学生，并不具备对行业趋势的判断能力，只是因为ASP太受欢迎，以至于图书馆的书都被借完了，我只好借了一本放在旁边的PHP。</p><p>于是在大学时我用PHP写了很多开源项目：留言板、相册、CMS；靠这些东西得到了一家建站公司的兼职工作，除了把学费挣回来以外，还轻松进入新浪实习。到新浪刚过了几个月，受雅虎影响，新浪也全面转向了PHP——而我正好是我们组最懂PHP的。你可以想象接下来我是多么如鱼得水，我和我的小伙伴们用PHP写完一个人才项目后，又用PHP重写了PV近亿的手机新浪网发布系统，一切都风调雨顺有惊无险，以至于后来去另一家公司面试时，面试官问我经历过最失败的项目时，我完全答不出来。</p><p>十年时间过去了，PHP依然如日中天，用我十年前学习的PHP技能，依然可以在一流互联网公司找到一份不错的工作，而ASP——现在谁还知道ASP是什么？</p><p>好了，我无意来仇恨，其实我只是想说同样是一门语言，它的投入产出比是非常不同的。选择技术方向时一定要谨慎。</p><p>那么，怎么选择技术方向呢？我给两个建议。</p><p>学会观察技术潮流</p><p>有一本老外写的书里边讲，如果你要知道什么语言流行，就去看看技术Guru们都在用什么。这话固然不错，但知其然不知其所以然并不是件好事。</p><p>从根源上讲，一个技术是否流行，和人们使用技术的方式密切相关。PHP能大规模流行，并不是因为它的语法好看，而是因为人们使用技术的方式从单机转向了网络，而PHP正好是所有语言里边最专注于Web的。苹果手机大规模流行后，Objective-C 的使用量开始极速上升。在很多程序员眼里OC的语法完全是异端，但这丝毫没有影响他们用异端语言大把挣钱。</p><p>仔细观察下周围，现在人类（是的，普通人类而不是其他程序员）是怎么使用技术的？很多人晚上回家已经不开电脑了，他们用电视盒看电视，用平板玩游戏，用手机吐槽。而这些设备很多都是Android系统，那么你觉得Android程序员会便宜吗？由于有了多个设备，个人的数据需要在多个设备之间进行同步、分散到各处的数据也需要统一管理，所以云计算尤其是云存储的需求会凸现出来。</p><p>知道了多屏合一以及APP流行的背景，你还会觉得现在投入PHP会是一个好选择吗？我们来分析下。PHP最大的优势在于它的胶水特性——简单快速的把HTML和业务数据粘在一起然后显示出来。如果只有浏览器，那么PHP还可以通过响应式设计的方式来兼容移动设备。但是当我们有了手机APP的时候，服务器就必然需要API了。换句话说，多屏合一其实是要求数据和显示分离的——这不是PHP最擅长的，单纯写API接口的话，无论是NodeJS还是Go都更具优势。当然，作为PHP的铁杆粉丝，我要说明，PHP也有很多强化API性能的项目，比如Yar，O+。这些东西让PHP在全平台时代获得了新的竞争资本，具体的大家可以去看看鸟哥在今年InfoQ大会上的PPT。</p><p>投资新兴市场和细分市场</p><p>这是第二个建议。如果把选择一门技术当做一个投资的话，新兴市场和细分市场是特别值得留意的。</p><p>新兴市场对程序员来说，就是一种新的语言、一个新的平台、一套新的框架。新兴市场因为刚刚兴起，所以几乎所有人都在同一个起跑线，特别适合后进者。我认识从一个2011年开始学习iOS开发的同学，他能力中等，但现在已经算是很资深的iOS工程师了，月薪超过2万；而如果他那时选择去学习PHP，那他现在只能算个初级程序员。</p><p>并非只有一个平台的兴起才有机会，很多框架技术也会带来机会。比如说Cocos2d Javascript版。以前开发游戏需要学习OC或者Java，而Cocos2d Javascript版本的出现，让你可以用纯JS同时开发一套运行在浏览器、iOS和Android平台上的游戏——不用改一行代码，由于是把JS解析后直接扔给OpenGL运行，在手机上性能也很不错。这对JS工程师来讲，就是一个全新的、可以进入游戏行业的机会。</p><p>如果你只能进入一个成熟市场，那么记得给自己确立一个细分的定位。前几天国内知名的漏洞报告平台乌云招聘PHP开发工程师，职位薪资不是很高，但是我觉得是一个很不错的机会。乌云平台每天被攻击一百多次， 在乌云工作几个月以后，你就能写出来可能是国内最安全的PHP代码，如果再适时的分享下你在乌云工作的经验教训，一个专注于安全的PHP专家就跃然纸上了。这就是细分市场，比你懂安全的没你懂PHP、比你懂PHP的没你懂安全。</p><p>技术线属于那些赖得住寂寞，还得了房贷，喜欢风险最低化的同学。在自身技术实力不错，专攻的技术方向还未衰落的情况下，踏踏实实熬个五到十年，还是可以有车有房的。如果中间遇到公司上市、出售，那么时间可能更短。</p><p>管理线</p><p>用玩游戏来打比方的话，技术线比较单一，在同一个地方不停的打怪就好了；而管理线则有相对复杂的剧情。技术管理虽然有技术两个字，但更多的是和人相关的管理工作，所以在这条线上，职业逻辑也更不正常（在HR看来可能是更正常）一些——title和资历很重要。</p><p>一个只在小公司上过班的PHP程序员，不管他能力有多好，是不可能直接成为一家500人规模还有半年就上市的企业的CTO的。即使CEO非常相信你的能力，他也需要拿出让投资人和团队其他人信服的证据，很显然一个大型互联网公司的技术总监职位更容易服众。所以别去相信那些没开过公司没当过高管或者就是别有居心的人说的，title很重要，它标记了你做过什么样的事、有怎么样的成绩。虽然它只能证明你的过去，但我们其实都是从别人的过去去判读一个人的将来的。</p><p>不想当CTO的程序员不是好项目经理，所以庸俗的讲，管理线其实就是一个不断升级自己的title，直到CTO的游戏，它有点像某些排序算法的动画。当然，随着title越来越高，管理的人和资源就越多，对沟通能力、管理能力的要求也越高。</p><p>在稍微扁平一点的互联网公司，职位分布大概是这样的：工程师 - 技术主管/技术经理/项目经理 -总监 - CTO。和技术线不同，管理线每一次升级除了能力，还需要机遇的。因为越是高级的管理职位就越少，如果你遇到一位年富力强又对公司衷心耿耿的直接上级，那这条线基本就被堵住了。</p><p>好在我们生活的这个年代换公司比换衣裳还容易，所以我们可以通过跳槽来调节。除了可以跳到相同水平但是发展更好的公司外，也可以去稍微低一级的公司，这样你的title（还有薪资）就可以先调上来，等这家公司发展起来，你的价值就增加了。</p><p>跳槽的时间间隔要把握好，一般两到三年为宜；不要太频繁，否则会让人对你的稳定性产生怀疑。每一次跳槽要设定好自己想要得到的空间、资源、薪资和title。对去创业公司的同学多说一句，虽然我不想承认，但的确99%的创业公司都会失败的，不过公司的失败未必是你的失败，你只要确保在每一家公司都能得到成长，就可以踩着河里的竹竿逆流而上。</p><p>写到这里连我自己都觉得有些势利了，但大部分公司和员工本身就是赤裸裸的利用关系，你不替自己打算是没人帮你的，老实也未必能有好结果。当年有个和我一起入职的同学，因为是应届，所以月薪只有3k，她一直勤勤恳恳的工作了四年，期望能靠自己的努力得到认可，但最后薪水也只有7k，远低于行业平均水平。后来终于想开了，跳槽去了竞争对手那边，直接13k+。公司的人才政策很多时候取决于高管，即使你的直接主管想帮你，也未必能帮上忙。比如之前，我们部门一个技术的同学结婚后经济压力上来了，想找份报酬更高的工作，我们好说歹说愿意留下，但想调调薪资，但公司死活不乐意，宁愿花着同样的钱去新招一个……</p><p>嗯，吐槽就到这里吧，总之，用多家公司作为自己职业生涯的调节杠杆，就像用并行进程处理高并发一样，是非常有意义的。你未必要真的跳来跳去，但多个选择总不是坏事。</p><p>至于要怎么去选择公司，尤其是小公司，你只需要注意两件事：公司的业务方向靠谱不？公司的老板对员工好不好？前者关系到公司能不能挣钱，后者关系到公司挣的钱有不有你的份。</p><p>四</p><p>就写到这里吧，虽然不全面，但如果能在某些点上引发你的思考，那就不枉我打这么多字了。如果你有什么要和我讨论，或者有什么要和大家分享，可以发邮件到 easychen@gmail.com ，我会找时间整理出来的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;要毕业了，实习了一个多月。。。职业规划还一片空白，房价又那么贵，我该怎么办==。&lt;/p&gt;
&lt;p&gt;这篇文章是我前几天无意间发现了，发现居然是挖坟，贴来自己看看，觉得还是很有启发意义的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;程序人生的四个象限和两条主线&lt;/p&gt;
    
    </summary>
    
      <category term="杂七杂八" scheme="http://binlv.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="胡说八道" scheme="http://binlv.top/tags/%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93/"/>
    
  </entry>
  
</feed>
